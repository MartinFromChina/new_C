; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\fattester.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\fattester.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\HARDWARE\LED -I..\HARDWARE\LCD -I..\HARDWARE\KEY -I..\HARDWARE\SRAM -I..\HARDWARE\SDIO -I..\MALLOC -I..\USMART -I..\HARDWARE\SPI -I..\HARDWARE\W25QXX -I..\FATFS\exfuns -I..\FATFS\src -I..\TEXT -I..\FWLIB\inc -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\I2S -I..\HARDWARE\WM8978 -I..\APP -I..\AUDIOCODEC\wav -I..\new_user -I..\new_user\task -I..\new_user\MVC -I..\..\..\module\common -I..\..\..\module\common\InsertLog -I..\..\..\module\common\loopqueue -I..\..\..\module\common\StateMachine -I..\..\..\module\common\priorityqueue -I..\..\..\module\common\Math -I..\..\..\module\component\const_loop_scheduler -I..\..\..\module\component\const_loop_scheduler\TemplateTask -I..\..\..\module\component\const_loop_scheduler\HierarchicalSM -I..\..\..\module\component\BlockableStateMachine -I..\..\..\module\customize\ButtonModule -I..\..\..\module\external\Segger\SEGGER_RTT_V640\Syscalls -I..\..\..\module\external\Segger\SEGGER_RTT_V640\RTT -I.\RTE\_AudioPlayer -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include" -I"D:\Program Files\ARM\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_COMPILER_PRESENT -DX_TASK_LOG_DEBUG_METHOD=SeggerRTT_LogDebug --omf_browse=..\obj\fattester.crf ..\FATFS\exfuns\fattester.c]
                          THUMB

                          AREA ||i.mf_close||, CODE, READONLY, ALIGN=2

                  mf_close PROC
;;;41     //返回值:执行结果
;;;42     u8 mf_close(void)
000000  b510              PUSH     {r4,lr}
;;;43     {
;;;44     	f_close(file);
000002  4803              LDR      r0,|L1.16|
000004  6800              LDR      r0,[r0,#0]  ; file
000006  f7fffffe          BL       f_close
;;;45     	return 0;
00000a  2000              MOVS     r0,#0
;;;46     }
00000c  bd10              POP      {r4,pc}
;;;47     //读出数据
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      file

                          AREA ||i.mf_closedir||, CODE, READONLY, ALIGN=2

                  mf_closedir PROC
;;;112    //返回值:执行结果
;;;113    u8 mf_closedir(void)
000000  b510              PUSH     {r4,lr}
;;;114    {
;;;115    	return f_closedir(&dir);	
000002  4802              LDR      r0,|L2.12|
000004  f7fffffe          BL       f_closedir
;;;116    }
000008  bd10              POP      {r4,pc}
;;;117    //打读取文件夹
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||dir||

                          AREA ||i.mf_fmkfs||, CODE, READONLY, ALIGN=1

                  mf_fmkfs PROC
;;;254    //返回值:执行结果
;;;255    u8 mf_fmkfs(u8* path,u8 mode,u16 au)
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;257    	return f_mkfs((const TCHAR*)path,mode,au);//格式化,drv:盘符;mode:模式;au:簇大小
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       f_mkfs
;;;258    } 
000012  bd70              POP      {r4-r6,pc}
;;;259    //删除文件/目录
                          ENDP


                          AREA ||i.mf_getlabel||, CODE, READONLY, ALIGN=1

                  mf_getlabel PROC
;;;276    //path:磁盘路径，比如"0:"、"1:"  
;;;277    void mf_getlabel(u8 *path)
000000  b530              PUSH     {r4,r5,lr}
;;;278    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;279    	u8 buf[20];
;;;280    	u32 sn=0;
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
;;;281    	u8 res;
;;;282    	res=f_getlabel ((const TCHAR *)path,(TCHAR *)buf,(DWORD*)&sn);
00000a  aa01              ADD      r2,sp,#4
00000c  a902              ADD      r1,sp,#8
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       f_getlabel
000014  4605              MOV      r5,r0
;;;283    //////	if(res==FR_OK)
;;;284    //////	{
;;;285    //////		//printf("\r\n磁盘%s 的盘符为:%s\r\n",path,buf);
;;;286    //////		//printf("磁盘%s 的序列号:%X\r\n\r\n",path,sn); 
;;;287    //////	}else //printf("\r\n获取失败，错误码:%X\r\n",res);
;;;288    }
000016  b007              ADD      sp,sp,#0x1c
000018  bd30              POP      {r4,r5,pc}
;;;289    //设置盘符（磁盘名字），最长11个字符！！，支持数字和大写字母组合以及汉字等
                          ENDP


                          AREA ||i.mf_gets||, CODE, READONLY, ALIGN=2

                  mf_gets PROC
;;;302    //size:要读取的长度
;;;303    void mf_gets(u16 size)
000000  b570              PUSH     {r4-r6,lr}
;;;304    {
000002  4604              MOV      r4,r0
;;;305     	TCHAR* rbuf;
;;;306    	rbuf=f_gets((TCHAR*)fatbuf,size,file);
000004  4806              LDR      r0,|L5.32|
000006  4621              MOV      r1,r4
000008  6802              LDR      r2,[r0,#0]  ; file
00000a  4806              LDR      r0,|L5.36|
00000c  6800              LDR      r0,[r0,#0]  ; fatbuf
00000e  f7fffffe          BL       f_gets
000012  4605              MOV      r5,r0
;;;307    	if(*rbuf==0)return  ;//没有数据读到
000014  7828              LDRB     r0,[r5,#0]
000016  b900              CBNZ     r0,|L5.26|
                  |L5.24|
;;;308    	else
;;;309    	{
;;;310    //////		//printf("\r\nThe String Readed Is:%s\r\n",rbuf);  	  
;;;311    	}			    	
;;;312    }
000018  bd70              POP      {r4-r6,pc}
                  |L5.26|
00001a  bf00              NOP      
00001c  e7fc              B        |L5.24|
;;;313    //需要_USE_STRFUNC>=1
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      file
                  |L5.36|
                          DCD      fatbuf

                          AREA ||i.mf_lseek||, CODE, READONLY, ALIGN=2

                  mf_lseek PROC
;;;226    //返回值:执行结果.
;;;227    u8 mf_lseek(u32 offset)
000000  b510              PUSH     {r4,lr}
;;;228    {
000002  4604              MOV      r4,r0
;;;229    	return f_lseek(file,offset);
000004  4621              MOV      r1,r4
000006  4802              LDR      r0,|L6.16|
000008  6800              LDR      r0,[r0,#0]  ; file
00000a  f7fffffe          BL       f_lseek
;;;230    }
00000e  bd10              POP      {r4,pc}
;;;231    //读取文件当前读写指针的位置.
                          ENDP

                  |L6.16|
                          DCD      file

                          AREA ||i.mf_mkdir||, CODE, READONLY, ALIGN=1

                  mf_mkdir PROC
;;;245    //返回值:执行结果
;;;246    u8 mf_mkdir(u8*pname)
000000  b510              PUSH     {r4,lr}
;;;247    {
000002  4604              MOV      r4,r0
;;;248    	return f_mkdir((const TCHAR *)pname);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       f_mkdir
;;;249    }
00000a  bd10              POP      {r4,pc}
;;;250    //格式化
                          ENDP


                          AREA ||i.mf_mount||, CODE, READONLY, ALIGN=2

                  mf_mount PROC
;;;25     //返回值:执行结果
;;;26     u8 mf_mount(u8* path,u8 mt)
000000  b570              PUSH     {r4-r6,lr}
;;;27     {		   
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;28     	return f_mount(fs[2],(const TCHAR*)path,mt); 
000006  4903              LDR      r1,|L8.20|
000008  462a              MOV      r2,r5
00000a  6888              LDR      r0,[r1,#8]  ; fs
00000c  4621              MOV      r1,r4
00000e  f7fffffe          BL       f_mount
;;;29     }
000012  bd70              POP      {r4-r6,pc}
;;;30     //打开路径下的文件
                          ENDP

                  |L8.20|
                          DCD      ||fs||

                          AREA ||i.mf_open||, CODE, READONLY, ALIGN=2

                  mf_open PROC
;;;33     //返回值:执行结果
;;;34     u8 mf_open(u8*path,u8 mode)
000000  b570              PUSH     {r4-r6,lr}
;;;35     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;36     	u8 res;	 
;;;37     	res=f_open(file,(const TCHAR*)path,mode);//打开文件夹
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  4803              LDR      r0,|L9.24|
00000c  6800              LDR      r0,[r0,#0]  ; file
00000e  f7fffffe          BL       f_open
000012  4606              MOV      r6,r0
;;;38     	return res;
000014  4630              MOV      r0,r6
;;;39     } 
000016  bd70              POP      {r4-r6,pc}
;;;40     //关闭文件
                          ENDP

                  |L9.24|
                          DCD      file

                          AREA ||i.mf_opendir||, CODE, READONLY, ALIGN=2

                  mf_opendir PROC
;;;106    //返回值:执行结果
;;;107    u8 mf_opendir(u8* path)
000000  b510              PUSH     {r4,lr}
;;;108    {
000002  4604              MOV      r4,r0
;;;109    	return f_opendir(&dir,(const TCHAR*)path);	
000004  4621              MOV      r1,r4
000006  4802              LDR      r0,|L10.16|
000008  f7fffffe          BL       f_opendir
;;;110    }
00000c  bd10              POP      {r4,pc}
;;;111    //关闭目录 
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      ||dir||

                          AREA ||i.mf_putc||, CODE, READONLY, ALIGN=2

                  mf_putc PROC
;;;316    //返回值:执行结果
;;;317    u8 mf_putc(u8 c)
000000  b510              PUSH     {r4,lr}
;;;318    {
000002  4604              MOV      r4,r0
;;;319    	return f_putc((TCHAR)c,file);
000004  4803              LDR      r0,|L11.20|
000006  6801              LDR      r1,[r0,#0]  ; file
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       f_putc
00000e  b2c0              UXTB     r0,r0
;;;320    }
000010  bd10              POP      {r4,pc}
;;;321    //写字符串到文件
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      file

                          AREA ||i.mf_puts||, CODE, READONLY, ALIGN=2

                  mf_puts PROC
;;;323    //返回值:写入的字符串长度
;;;324    u8 mf_puts(u8*c)
000000  b510              PUSH     {r4,lr}
;;;325    {
000002  4604              MOV      r4,r0
;;;326    	return f_puts((TCHAR*)c,file);
000004  4803              LDR      r0,|L12.20|
000006  6801              LDR      r1,[r0,#0]  ; file
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       f_puts
00000e  b2c0              UXTB     r0,r0
;;;327    }
000010  bd10              POP      {r4,pc}
;;;328    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      file

                          AREA ||i.mf_read||, CODE, READONLY, ALIGN=2

                  mf_read PROC
;;;49     //返回值:执行结果
;;;50     u8 mf_read(u16 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;51     {
000004  4604              MOV      r4,r0
;;;52     	u16 i,t;
;;;53     	u8 res=0;
000006  2500              MOVS     r5,#0
;;;54     	u16 tlen=0;
000008  46a8              MOV      r8,r5
;;;55     	////printf("\r\nRead file data is:\r\n");
;;;56     	for(i=0;i<len/512;i++)
00000a  2700              MOVS     r7,#0
00000c  e012              B        |L13.52|
                  |L13.14|
;;;57     	{
;;;58     		res=f_read(file,fatbuf,512,&br);
00000e  4b1c              LDR      r3,|L13.128|
000010  f44f7200          MOV      r2,#0x200
000014  481b              LDR      r0,|L13.132|
000016  6801              LDR      r1,[r0,#0]  ; fatbuf
000018  481b              LDR      r0,|L13.136|
00001a  6800              LDR      r0,[r0,#0]  ; file
00001c  f7fffffe          BL       f_read
000020  4605              MOV      r5,r0
;;;59     		if(res)
000022  b105              CBZ      r5,|L13.38|
;;;60     		{
;;;61     			//printf("Read Error:%d\r\n",res);
;;;62     			break;
000024  e00c              B        |L13.64|
                  |L13.38|
;;;63     		}else
;;;64     		{
;;;65     			tlen+=br;
000026  4816              LDR      r0,|L13.128|
000028  8800              LDRH     r0,[r0,#0]  ; br
00002a  4440              ADD      r0,r0,r8
00002c  fa1ff880          UXTH     r8,r0
000030  1c78              ADDS     r0,r7,#1              ;56
000032  b287              UXTH     r7,r0                 ;56
                  |L13.52|
000034  17e1              ASRS     r1,r4,#31             ;56
000036  eb0451d1          ADD      r1,r4,r1,LSR #23      ;56
00003a  ebb72f61          CMP      r7,r1,ASR #9          ;56
00003e  dbe6              BLT      |L13.14|
                  |L13.64|
000040  bf00              NOP                            ;62
;;;66     			//for(t=0;t<br;t++)//printf("%c",fatbuf[t]); 
;;;67     		}
;;;68     	}
;;;69     	if(len%512)
000042  17e1              ASRS     r1,r4,#31
000044  eb0451d1          ADD      r1,r4,r1,LSR #23
000048  1249              ASRS     r1,r1,#9
00004a  eba42141          SUB      r1,r4,r1,LSL #9
00004e  b1a1              CBZ      r1,|L13.122|
;;;70     	{
;;;71     		res=f_read(file,fatbuf,len%512,&br);
000050  4626              MOV      r6,r4
000052  17e0              ASRS     r0,r4,#31
000054  eb0450d0          ADD      r0,r4,r0,LSR #23
000058  1240              ASRS     r0,r0,#9
00005a  eba42240          SUB      r2,r4,r0,LSL #9
00005e  4b08              LDR      r3,|L13.128|
000060  4808              LDR      r0,|L13.132|
000062  6801              LDR      r1,[r0,#0]  ; fatbuf
000064  4808              LDR      r0,|L13.136|
000066  6800              LDR      r0,[r0,#0]  ; file
000068  f7fffffe          BL       f_read
00006c  4605              MOV      r5,r0
;;;72     		if(res)	//读数据出错了
00006e  b925              CBNZ     r5,|L13.122|
;;;73     		{
;;;74     			//printf("\r\nRead Error:%d\r\n",res);   
;;;75     		}else
;;;76     		{
;;;77     			tlen+=br;
000070  4803              LDR      r0,|L13.128|
000072  8800              LDRH     r0,[r0,#0]  ; br
000074  4440              ADD      r0,r0,r8
000076  fa1ff880          UXTH     r8,r0
                  |L13.122|
;;;78     			//for(t=0;t<br;t++)//printf("%c",fatbuf[t]); 
;;;79     		}	 
;;;80     	}
;;;81     	//if(tlen)//printf("\r\nReaded data len:%d\r\n",tlen);//读到的数据长度
;;;82     	//printf("Read data over\r\n");	 
;;;83     	return res;
00007a  4628              MOV      r0,r5
;;;84     }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;85     //写入数据
                          ENDP

                  |L13.128|
                          DCD      ||br||
                  |L13.132|
                          DCD      fatbuf
                  |L13.136|
                          DCD      file

                          AREA ||i.mf_readdir||, CODE, READONLY, ALIGN=2

                  mf_readdir PROC
;;;118    //返回值:执行结果
;;;119    u8 mf_readdir(void)
000000  b570              PUSH     {r4-r6,lr}
;;;120    {
;;;121    	u8 res;
;;;122    	char *fn;			 
;;;123    #if _USE_LFN
;;;124     	fileinfo.lfsize = _MAX_LFN * 2 + 1;
000002  f24010ff          MOV      r0,#0x1ff
000006  4914              LDR      r1,|L14.88|
000008  61c8              STR      r0,[r1,#0x1c]  ; fileinfo
;;;125    	fileinfo.lfname = mymalloc(SRAMIN,fileinfo.lfsize);
00000a  4608              MOV      r0,r1
00000c  69c1              LDR      r1,[r0,#0x1c]  ; fileinfo
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       mymalloc
000014  4910              LDR      r1,|L14.88|
000016  6188              STR      r0,[r1,#0x18]  ; fileinfo
;;;126    #endif		  
;;;127    	res=f_readdir(&dir,&fileinfo);//读取一个文件的信息
000018  4810              LDR      r0,|L14.92|
00001a  f7fffffe          BL       f_readdir
00001e  4604              MOV      r4,r0
;;;128    	if(res!=FR_OK||fileinfo.fname[0]==0)
000020  b914              CBNZ     r4,|L14.40|
000022  480d              LDR      r0,|L14.88|
000024  7a40              LDRB     r0,[r0,#9]  ; fileinfo
000026  b930              CBNZ     r0,|L14.54|
                  |L14.40|
;;;129    	{
;;;130    		myfree(SRAMIN,fileinfo.lfname);
000028  480b              LDR      r0,|L14.88|
00002a  6981              LDR      r1,[r0,#0x18]  ; fileinfo
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       myfree
;;;131    		return res;//读完了.
000032  4620              MOV      r0,r4
                  |L14.52|
;;;132    	}
;;;133    #if _USE_LFN
;;;134    	fn=*fileinfo.lfname ? fileinfo.lfname : fileinfo.fname;
;;;135    #else
;;;136    	fn=fileinfo.fname;;
;;;137    #endif	
;;;138    	//printf("\r\n DIR info:\r\n");
;;;139    
;;;140    	//printf("dir.id:%d\r\n",dir.id);
;;;141    	//printf("dir.index:%d\r\n",dir.index);
;;;142    	//printf("dir.sclust:%d\r\n",dir.sclust);
;;;143    	//printf("dir.clust:%d\r\n",dir.clust);
;;;144    	//printf("dir.sect:%d\r\n",dir.sect);	  
;;;145    
;;;146    	//printf("\r\n");
;;;147    	//printf("File Name is:%s\r\n",fn);
;;;148    	//printf("File Size is:%d\r\n",fileinfo.fsize);
;;;149    	//printf("File data is:%d\r\n",fileinfo.fdate);
;;;150    	//printf("File time is:%d\r\n",fileinfo.ftime);
;;;151    	//printf("File Attr is:%d\r\n",fileinfo.fattrib);
;;;152    	//printf("\r\n");
;;;153    	myfree(SRAMIN,fileinfo.lfname);
;;;154    	return 0;
;;;155    }			 
000034  bd70              POP      {r4-r6,pc}
                  |L14.54|
000036  4808              LDR      r0,|L14.88|
000038  6980              LDR      r0,[r0,#0x18]         ;134  ; fileinfo
00003a  7800              LDRB     r0,[r0,#0]            ;134
00003c  b110              CBZ      r0,|L14.68|
00003e  4806              LDR      r0,|L14.88|
000040  6980              LDR      r0,[r0,#0x18]         ;134  ; fileinfo
000042  e001              B        |L14.72|
                  |L14.68|
000044  4804              LDR      r0,|L14.88|
000046  3009              ADDS     r0,r0,#9              ;134
                  |L14.72|
000048  4605              MOV      r5,r0                 ;134
00004a  4803              LDR      r0,|L14.88|
00004c  6981              LDR      r1,[r0,#0x18]         ;153  ; fileinfo
00004e  2000              MOVS     r0,#0                 ;153
000050  f7fffffe          BL       myfree
000054  2000              MOVS     r0,#0                 ;154
000056  e7ed              B        |L14.52|
;;;156    
                          ENDP

                  |L14.88|
                          DCD      fileinfo
                  |L14.92|
                          DCD      ||dir||

                          AREA ||i.mf_rename||, CODE, READONLY, ALIGN=1

                  mf_rename PROC
;;;270    //返回值:执行结果
;;;271    u8 mf_rename(u8 *oldname,u8* newname)
000000  b570              PUSH     {r4-r6,lr}
;;;272    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;273    	return  f_rename((const TCHAR *)oldname,(const TCHAR *)newname);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       f_rename
;;;274    }
00000e  bd70              POP      {r4-r6,pc}
;;;275    //获取盘符（磁盘名字）
                          ENDP


                          AREA ||i.mf_scan_files||, CODE, READONLY, ALIGN=2

                  mf_scan_files PROC
;;;159     //返回值:执行结果
;;;160    u8 mf_scan_files(u8 * path)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
;;;162    	FRESULT res;	  
;;;163        char *fn;   /* This function is assuming non-Unicode cfg. */
;;;164    #if _USE_LFN
;;;165     	fileinfo.lfsize = _MAX_LFN * 2 + 1;
000004  f24010ff          MOV      r0,#0x1ff
000008  4916              LDR      r1,|L16.100|
00000a  61c8              STR      r0,[r1,#0x1c]  ; fileinfo
;;;166    	fileinfo.lfname = mymalloc(SRAMIN,fileinfo.lfsize);
00000c  4608              MOV      r0,r1
00000e  69c1              LDR      r1,[r0,#0x1c]  ; fileinfo
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       mymalloc
000016  4913              LDR      r1,|L16.100|
000018  6188              STR      r0,[r1,#0x18]  ; fileinfo
;;;167    #endif		  
;;;168    
;;;169        res = f_opendir(&dir,(const TCHAR*)path); //打开一个目录
00001a  4629              MOV      r1,r5
00001c  4812              LDR      r0,|L16.104|
00001e  f7fffffe          BL       f_opendir
000022  4604              MOV      r4,r0
;;;170        if (res == FR_OK) 
000024  b9b4              CBNZ     r4,|L16.84|
;;;171    	{	
;;;172    		//printf("\r\n"); 
;;;173    		while(1)
000026  e013              B        |L16.80|
                  |L16.40|
;;;174    		{
;;;175    	        res = f_readdir(&dir, &fileinfo);                   //读取目录下的一个文件
000028  490e              LDR      r1,|L16.100|
00002a  480f              LDR      r0,|L16.104|
00002c  f7fffffe          BL       f_readdir
000030  4604              MOV      r4,r0
;;;176    	        if (res != FR_OK || fileinfo.fname[0] == 0) break;  //错误了/到末尾了,退出
000032  b914              CBNZ     r4,|L16.58|
000034  480b              LDR      r0,|L16.100|
000036  7a40              LDRB     r0,[r0,#9]  ; fileinfo
000038  b900              CBNZ     r0,|L16.60|
                  |L16.58|
00003a  e00a              B        |L16.82|
                  |L16.60|
;;;177    	        //if (fileinfo.fname[0] == '.') continue;             //忽略上级目录
;;;178    #if _USE_LFN
;;;179            	fn = *fileinfo.lfname ? fileinfo.lfname : fileinfo.fname;
00003c  4809              LDR      r0,|L16.100|
00003e  6980              LDR      r0,[r0,#0x18]  ; fileinfo
000040  7800              LDRB     r0,[r0,#0]
000042  b110              CBZ      r0,|L16.74|
000044  4807              LDR      r0,|L16.100|
000046  6980              LDR      r0,[r0,#0x18]  ; fileinfo
000048  e001              B        |L16.78|
                  |L16.74|
00004a  4806              LDR      r0,|L16.100|
00004c  3009              ADDS     r0,r0,#9
                  |L16.78|
00004e  4606              MOV      r6,r0
                  |L16.80|
000050  e7ea              B        |L16.40|
                  |L16.82|
000052  bf00              NOP                            ;176
                  |L16.84|
;;;180    #else							   
;;;181            	fn = fileinfo.fname;
;;;182    #endif	                                              /* It is a file. */
;;;183    			//printf("%s/", path);//打印路径	
;;;184    			//printf("%s\r\n",  fn);//打印文件名	  
;;;185    		} 
;;;186        }	  
;;;187    	myfree(SRAMIN,fileinfo.lfname);
000054  4803              LDR      r0,|L16.100|
000056  6981              LDR      r1,[r0,#0x18]  ; fileinfo
000058  2000              MOVS     r0,#0
00005a  f7fffffe          BL       myfree
;;;188        return res;	  
00005e  4620              MOV      r0,r4
;;;189    }
000060  bd70              POP      {r4-r6,pc}
;;;190    //显示剩余容量
                          ENDP

000062  0000              DCW      0x0000
                  |L16.100|
                          DCD      fileinfo
                  |L16.104|
                          DCD      ||dir||

                          AREA ||i.mf_setlabel||, CODE, READONLY, ALIGN=1

                  mf_setlabel PROC
;;;290    //path:磁盘号+名字，比如"0:ALIENTEK"、"1:OPENEDV"  
;;;291    void mf_setlabel(u8 *path)
000000  b570              PUSH     {r4-r6,lr}
;;;292    {
000002  4604              MOV      r4,r0
;;;293    	u8 res;
;;;294    	res=f_setlabel ((const TCHAR *)path);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       f_setlabel
00000a  4605              MOV      r5,r0
;;;295    //////	if(res==FR_OK)
;;;296    //////	{
;;;297    //////		//printf("\r\n磁盘盘符设置成功:%s\r\n",path);
;;;298    //////	}else //printf("\r\n磁盘盘符设置失败，错误码:%X\r\n",res);
;;;299    } 
00000c  bd70              POP      {r4-r6,pc}
;;;300    
                          ENDP


                          AREA ||i.mf_showfree||, CODE, READONLY, ALIGN=1

                  mf_showfree PROC
;;;192    //返回值:剩余容量(字节)
;;;193    u32 mf_showfree(u8 *drv)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;194    {
000004  4604              MOV      r4,r0
;;;195    	FATFS *fs1;
;;;196    	u8 res;
;;;197        u32 fre_clust=0, fre_sect=0, tot_sect=0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  2600              MOVS     r6,#0
00000c  2700              MOVS     r7,#0
;;;198        //得到磁盘信息及空闲簇数量
;;;199        res = f_getfree((const TCHAR*)drv,(DWORD*)&fre_clust, &fs1);
00000e  aa01              ADD      r2,sp,#4
000010  4669              MOV      r1,sp
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       f_getfree
000018  4605              MOV      r5,r0
;;;200        if(res==0)
00001a  b965              CBNZ     r5,|L18.54|
;;;201    	{											   
;;;202    	    tot_sect = (fs1->n_fatent - 2) * fs1->csize;//得到总扇区数
00001c  9801              LDR      r0,[sp,#4]
00001e  6940              LDR      r0,[r0,#0x14]
000020  1e80              SUBS     r0,r0,#2
000022  9901              LDR      r1,[sp,#4]
000024  7889              LDRB     r1,[r1,#2]
000026  fb00f701          MUL      r7,r0,r1
;;;203    	    fre_sect = fre_clust * fs1->csize;			//得到空闲扇区数	   
00002a  9801              LDR      r0,[sp,#4]
00002c  7880              LDRB     r0,[r0,#2]
00002e  9900              LDR      r1,[sp,#0]
000030  fb00f601          MUL      r6,r0,r1
;;;204    #if _MAX_SS!=512
;;;205    		tot_sect*=fs1->ssize/512;
;;;206    		fre_sect*=fs1->ssize/512;
;;;207    #endif	  
;;;208    		if(tot_sect<20480)//总容量小于10M
000034  bf00              NOP      
                  |L18.54|
;;;209    		{
;;;210    		    /* Print free space in unit of KB (assuming 512 bytes/sector) */
;;;211    //////		    //printf("\r\n磁盘总容量:%d KB\r\n"
;;;212    //////		           "可用空间:%d KB\r\n",
;;;213    //////		           tot_sect>>1,fre_sect>>1);
;;;214    		}else
;;;215    		{
;;;216    		    /* Print free space in unit of KB (assuming 512 bytes/sector) */
;;;217    		    //printf("\r\n磁盘总容量:%d MB\r\n"
;;;218    //////		           "可用空间:%d MB\r\n",
;;;219    //////		           tot_sect>>11,fre_sect>>11);
;;;220    		}
;;;221    	}
;;;222    	return fre_sect;
000036  4630              MOV      r0,r6
;;;223    }		    
000038  e8bd81fc          POP      {r2-r8,pc}
;;;224    //文件读写指针偏移
                          ENDP


                          AREA ||i.mf_size||, CODE, READONLY, ALIGN=2

                  mf_size PROC
;;;238    //返回值:文件大小
;;;239    u32 mf_size(void)
000000  4801              LDR      r0,|L19.8|
;;;240    {
;;;241    	return f_size(file);
000002  6800              LDR      r0,[r0,#0]  ; file
000004  68c0              LDR      r0,[r0,#0xc]
;;;242    } 
000006  4770              BX       lr
;;;243    //创建目录
                          ENDP

                  |L19.8|
                          DCD      file

                          AREA ||i.mf_tell||, CODE, READONLY, ALIGN=2

                  mf_tell PROC
;;;232    //返回值:位置
;;;233    u32 mf_tell(void)
000000  4801              LDR      r0,|L20.8|
;;;234    {
;;;235    	return f_tell(file);
000002  6800              LDR      r0,[r0,#0]  ; file
000004  6880              LDR      r0,[r0,#8]
;;;236    }
000006  4770              BX       lr
;;;237    //读取文件大小
                          ENDP

                  |L20.8|
                          DCD      file

                          AREA ||i.mf_unlink||, CODE, READONLY, ALIGN=1

                  mf_unlink PROC
;;;261    //返回值:执行结果
;;;262    u8 mf_unlink(u8 *pname)
000000  b510              PUSH     {r4,lr}
;;;263    {
000002  4604              MOV      r4,r0
;;;264    	return  f_unlink((const TCHAR *)pname);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       f_unlink
;;;265    }
00000a  bd10              POP      {r4,pc}
;;;266    
                          ENDP


                          AREA ||i.mf_write||, CODE, READONLY, ALIGN=2

                  mf_write PROC
;;;88     //返回值:执行结果
;;;89     u8 mf_write(u8*dat,u16 len)
000000  b570              PUSH     {r4-r6,lr}
;;;90     {			    
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;91     	u8 res;	   					   
;;;92     
;;;93     	//printf("\r\nBegin Write file...\r\n");
;;;94     	//printf("Write data len:%d\r\n",len);	 
;;;95     	res=f_write(file,dat,len,&bw);
000006  4b05              LDR      r3,|L22.28|
000008  462a              MOV      r2,r5
00000a  4621              MOV      r1,r4
00000c  4804              LDR      r0,|L22.32|
00000e  6800              LDR      r0,[r0,#0]  ; file
000010  f7fffffe          BL       f_write
000014  4606              MOV      r6,r0
;;;96     //////	if(res)
;;;97     //////	{
;;;98     //////		//printf("Write Error:%d\r\n",res);   
;;;99     //////	}else //printf("Writed data len:%d\r\n",bw);
;;;100    //////	//printf("Write data over.\r\n");
;;;101    	return res;
000016  4630              MOV      r0,r6
;;;102    }
000018  bd70              POP      {r4-r6,pc}
;;;103    
                          ENDP

00001a  0000              DCW      0x0000
                  |L22.28|
                          DCD      ||bw||
                  |L22.32|
                          DCD      file

;*** Start embedded assembler ***

#line 1 "..\\FATFS\\exfuns\\fattester.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_fattester_c_mf_mount____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___11_fattester_c_mf_mount____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_fattester_c_mf_mount____REVSH|
#line 144
|__asm___11_fattester_c_mf_mount____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
