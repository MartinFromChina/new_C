; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\segger_rtt.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\segger_rtt.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\HARDWARE\LED -I..\HARDWARE\LCD -I..\HARDWARE\KEY -I..\HARDWARE\SRAM -I..\HARDWARE\SDIO -I..\MALLOC -I..\USMART -I..\HARDWARE\SPI -I..\HARDWARE\W25QXX -I..\FATFS\exfuns -I..\FATFS\src -I..\TEXT -I..\FWLIB\inc -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\I2S -I..\HARDWARE\WM8978 -I..\APP -I..\AUDIOCODEC\wav -I..\new_user -I..\new_user\task -I..\new_user\MVC -I..\..\..\module\common -I..\..\..\module\common\InsertLog -I..\..\..\module\common\loopqueue -I..\..\..\module\common\StateMachine -I..\..\..\module\common\priorityqueue -I..\..\..\module\common\Math -I..\..\..\module\component\const_loop_scheduler -I..\..\..\module\component\const_loop_scheduler\TemplateTask -I..\..\..\module\component\const_loop_scheduler\HierarchicalSM -I..\..\..\module\component\BlockableStateMachine -I..\..\..\module\customize\ButtonModule -I..\..\..\module\external\Segger\SEGGER_RTT_V640\Syscalls -I..\..\..\module\external\Segger\SEGGER_RTT_V640\RTT -I.\RTE\_AudioPlayer -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include" -I"D:\Program Files\ARM\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_COMPILER_PRESENT -DX_TASK_LOG_DEBUG_METHOD=SeggerRTT_LogDebug --omf_browse=..\obj\segger_rtt.crf ..\..\..\module\external\Segger\SEGGER_RTT_V640\RTT\SEGGER_RTT.c]
                          THUMB

                          AREA ||i.SEGGER_RTT_AllocDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_AllocDownBuffer PROC
;;;1322   */
;;;1323   int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1324     int BufferIndex;
;;;1325   
;;;1326     INIT();
00000c  bf00              NOP      
00000e  482b              LDR      r0,|L1.188|
000010  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000012  b908              CBNZ     r0,|L1.24|
000014  f7fffffe          BL       _DoInit
                  |L1.24|
000018  bf00              NOP      
;;;1327     SEGGER_RTT_LOCK();
00001a  f3ef8111          MRS      r1,BASEPRI
00001e  4608              MOV      r0,r1
000020  2120              MOVS     r1,#0x20
000022  f3818811          MSR      BASEPRI,r1
000026  bf00              NOP      
000028  bf00              NOP      
;;;1328     BufferIndex = 0;
00002a  2400              MOVS     r4,#0
;;;1329     do {
00002c  bf00              NOP      
                  |L1.46|
;;;1330       if (_SEGGER_RTT.aDown[BufferIndex].pBuffer == NULL) {
00002e  eb040244          ADD      r2,r4,r4,LSL #1
000032  4922              LDR      r1,|L1.188|
000034  3160              ADDS     r1,r1,#0x60
000036  eb0101c2          ADD      r1,r1,r2,LSL #3
00003a  6849              LDR      r1,[r1,#4]
00003c  b901              CBNZ     r1,|L1.64|
;;;1331         break;
00003e  e004              B        |L1.74|
                  |L1.64|
;;;1332       }
;;;1333       BufferIndex++;
000040  1c64              ADDS     r4,r4,#1
;;;1334     } while (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers);
000042  491e              LDR      r1,|L1.188|
000044  6949              LDR      r1,[r1,#0x14]  ; _SEGGER_RTT
000046  42a1              CMP      r1,r4
000048  dcf1              BGT      |L1.46|
                  |L1.74|
00004a  bf00              NOP                            ;1331
;;;1335     if (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers) {
00004c  491b              LDR      r1,|L1.188|
00004e  6949              LDR      r1,[r1,#0x14]  ; _SEGGER_RTT
000050  42a1              CMP      r1,r4
000052  dd29              BLE      |L1.168|
;;;1336       _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
000054  eb040244          ADD      r2,r4,r4,LSL #1
000058  4918              LDR      r1,|L1.188|
00005a  3160              ADDS     r1,r1,#0x60
00005c  f8415032          STR      r5,[r1,r2,LSL #3]
;;;1337       _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
000060  eb040244          ADD      r2,r4,r4,LSL #1
000064  eb0101c2          ADD      r1,r1,r2,LSL #3
000068  604e              STR      r6,[r1,#4]
;;;1338       _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
00006a  eb040244          ADD      r2,r4,r4,LSL #1
00006e  4913              LDR      r1,|L1.188|
000070  3160              ADDS     r1,r1,#0x60
000072  eb0101c2          ADD      r1,r1,r2,LSL #3
000076  608f              STR      r7,[r1,#8]
;;;1339       _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
000078  2200              MOVS     r2,#0
00007a  eb040344          ADD      r3,r4,r4,LSL #1
00007e  490f              LDR      r1,|L1.188|
000080  3160              ADDS     r1,r1,#0x60
000082  eb0101c3          ADD      r1,r1,r3,LSL #3
000086  610a              STR      r2,[r1,#0x10]
;;;1340       _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
000088  eb040344          ADD      r3,r4,r4,LSL #1
00008c  490b              LDR      r1,|L1.188|
00008e  3160              ADDS     r1,r1,#0x60
000090  eb0101c3          ADD      r1,r1,r3,LSL #3
000094  60ca              STR      r2,[r1,#0xc]
;;;1341       _SEGGER_RTT.aDown[BufferIndex].Flags        = Flags;
000096  eb040244          ADD      r2,r4,r4,LSL #1
00009a  4908              LDR      r1,|L1.188|
00009c  3160              ADDS     r1,r1,#0x60
00009e  eb0101c2          ADD      r1,r1,r2,LSL #3
0000a2  f8c18014          STR      r8,[r1,#0x14]
0000a6  e001              B        |L1.172|
                  |L1.168|
;;;1342     } else {
;;;1343       BufferIndex = -1;
0000a8  f04f34ff          MOV      r4,#0xffffffff
                  |L1.172|
;;;1344     }
;;;1345     SEGGER_RTT_UNLOCK();
0000ac  b2c1              UXTB     r1,r0
0000ae  f3818811          MSR      BASEPRI,r1
0000b2  bf00              NOP      
0000b4  bf00              NOP      
;;;1346     return BufferIndex;
0000b6  4620              MOV      r0,r4
;;;1347   }
0000b8  e8bd81f0          POP      {r4-r8,pc}
;;;1348   
                          ENDP

                  |L1.188|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_AllocUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_AllocUpBuffer PROC
;;;1367   */
;;;1368   int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1369     int BufferIndex;
;;;1370   
;;;1371     INIT();
00000c  bf00              NOP      
00000e  482b              LDR      r0,|L2.188|
000010  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000012  b908              CBNZ     r0,|L2.24|
000014  f7fffffe          BL       _DoInit
                  |L2.24|
000018  bf00              NOP      
;;;1372     SEGGER_RTT_LOCK();
00001a  f3ef8111          MRS      r1,BASEPRI
00001e  4608              MOV      r0,r1
000020  2120              MOVS     r1,#0x20
000022  f3818811          MSR      BASEPRI,r1
000026  bf00              NOP      
000028  bf00              NOP      
;;;1373     BufferIndex = 0;
00002a  2400              MOVS     r4,#0
;;;1374     do {
00002c  bf00              NOP      
                  |L2.46|
;;;1375       if (_SEGGER_RTT.aUp[BufferIndex].pBuffer == NULL) {
00002e  eb040244          ADD      r2,r4,r4,LSL #1
000032  4922              LDR      r1,|L2.188|
000034  3118              ADDS     r1,r1,#0x18
000036  eb0101c2          ADD      r1,r1,r2,LSL #3
00003a  6849              LDR      r1,[r1,#4]
00003c  b901              CBNZ     r1,|L2.64|
;;;1376         break;
00003e  e004              B        |L2.74|
                  |L2.64|
;;;1377       }
;;;1378       BufferIndex++;
000040  1c64              ADDS     r4,r4,#1
;;;1379     } while (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers);
000042  491e              LDR      r1,|L2.188|
000044  6909              LDR      r1,[r1,#0x10]  ; _SEGGER_RTT
000046  42a1              CMP      r1,r4
000048  dcf1              BGT      |L2.46|
                  |L2.74|
00004a  bf00              NOP                            ;1376
;;;1380     if (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers) {
00004c  491b              LDR      r1,|L2.188|
00004e  6909              LDR      r1,[r1,#0x10]  ; _SEGGER_RTT
000050  42a1              CMP      r1,r4
000052  dd29              BLE      |L2.168|
;;;1381       _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
000054  eb040244          ADD      r2,r4,r4,LSL #1
000058  4918              LDR      r1,|L2.188|
00005a  3118              ADDS     r1,r1,#0x18
00005c  f8415032          STR      r5,[r1,r2,LSL #3]
;;;1382       _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
000060  eb040244          ADD      r2,r4,r4,LSL #1
000064  eb0101c2          ADD      r1,r1,r2,LSL #3
000068  604e              STR      r6,[r1,#4]
;;;1383       _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
00006a  eb040244          ADD      r2,r4,r4,LSL #1
00006e  4913              LDR      r1,|L2.188|
000070  3118              ADDS     r1,r1,#0x18
000072  eb0101c2          ADD      r1,r1,r2,LSL #3
000076  608f              STR      r7,[r1,#8]
;;;1384       _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
000078  2200              MOVS     r2,#0
00007a  eb040344          ADD      r3,r4,r4,LSL #1
00007e  490f              LDR      r1,|L2.188|
000080  3118              ADDS     r1,r1,#0x18
000082  eb0101c3          ADD      r1,r1,r3,LSL #3
000086  610a              STR      r2,[r1,#0x10]
;;;1385       _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
000088  eb040344          ADD      r3,r4,r4,LSL #1
00008c  490b              LDR      r1,|L2.188|
00008e  3118              ADDS     r1,r1,#0x18
000090  eb0101c3          ADD      r1,r1,r3,LSL #3
000094  60ca              STR      r2,[r1,#0xc]
;;;1386       _SEGGER_RTT.aUp[BufferIndex].Flags        = Flags;
000096  eb040244          ADD      r2,r4,r4,LSL #1
00009a  4908              LDR      r1,|L2.188|
00009c  3118              ADDS     r1,r1,#0x18
00009e  eb0101c2          ADD      r1,r1,r2,LSL #3
0000a2  f8c18014          STR      r8,[r1,#0x14]
0000a6  e001              B        |L2.172|
                  |L2.168|
;;;1387     } else {
;;;1388       BufferIndex = -1;
0000a8  f04f34ff          MOV      r4,#0xffffffff
                  |L2.172|
;;;1389     }
;;;1390     SEGGER_RTT_UNLOCK();
0000ac  b2c1              UXTB     r1,r0
0000ae  f3818811          MSR      BASEPRI,r1
0000b2  bf00              NOP      
0000b4  bf00              NOP      
;;;1391     return BufferIndex;
0000b6  4620              MOV      r0,r4
;;;1392   }
0000b8  e8bd81f0          POP      {r4-r8,pc}
;;;1393   
                          ENDP

                  |L2.188|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigDownBuffer PROC
;;;1465   */
;;;1466   int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;1467     int r;
;;;1468   
;;;1469     INIT();
000010  bf00              NOP      
000012  4824              LDR      r0,|L3.164|
000014  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000016  b908              CBNZ     r0,|L3.28|
000018  f7fffffe          BL       _DoInit
                  |L3.28|
00001c  bf00              NOP      
;;;1470     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
00001e  4821              LDR      r0,|L3.164|
000020  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000022  42a0              CMP      r0,r4
000024  d939              BLS      |L3.154|
;;;1471       SEGGER_RTT_LOCK();
000026  f3ef8111          MRS      r1,BASEPRI
00002a  4608              MOV      r0,r1
00002c  2120              MOVS     r1,#0x20
00002e  f3818811          MSR      BASEPRI,r1
000032  bf00              NOP      
000034  bf00              NOP      
;;;1472       if (BufferIndex > 0u) {
000036  b30c              CBZ      r4,|L3.124|
;;;1473         _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
000038  eb040244          ADD      r2,r4,r4,LSL #1
00003c  4919              LDR      r1,|L3.164|
00003e  3160              ADDS     r1,r1,#0x60
000040  f8416032          STR      r6,[r1,r2,LSL #3]
;;;1474         _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
000044  eb040244          ADD      r2,r4,r4,LSL #1
000048  eb0101c2          ADD      r1,r1,r2,LSL #3
00004c  604f              STR      r7,[r1,#4]
;;;1475         _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
00004e  eb040244          ADD      r2,r4,r4,LSL #1
000052  4914              LDR      r1,|L3.164|
000054  3160              ADDS     r1,r1,#0x60
000056  eb0101c2          ADD      r1,r1,r2,LSL #3
00005a  f8c18008          STR      r8,[r1,#8]
;;;1476         _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
00005e  2200              MOVS     r2,#0
000060  eb040344          ADD      r3,r4,r4,LSL #1
000064  490f              LDR      r1,|L3.164|
000066  3160              ADDS     r1,r1,#0x60
000068  eb0101c3          ADD      r1,r1,r3,LSL #3
00006c  610a              STR      r2,[r1,#0x10]
;;;1477         _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
00006e  eb040344          ADD      r3,r4,r4,LSL #1
000072  490c              LDR      r1,|L3.164|
000074  3160              ADDS     r1,r1,#0x60
000076  eb0101c3          ADD      r1,r1,r3,LSL #3
00007a  60ca              STR      r2,[r1,#0xc]
                  |L3.124|
;;;1478       }
;;;1479       _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
00007c  eb040244          ADD      r2,r4,r4,LSL #1
000080  4908              LDR      r1,|L3.164|
000082  3160              ADDS     r1,r1,#0x60
000084  eb0101c2          ADD      r1,r1,r2,LSL #3
000088  f8c19014          STR      r9,[r1,#0x14]
;;;1480       SEGGER_RTT_UNLOCK();
00008c  b2c1              UXTB     r1,r0
00008e  f3818811          MSR      BASEPRI,r1
000092  bf00              NOP      
000094  bf00              NOP      
;;;1481       r =  0;
000096  2500              MOVS     r5,#0
000098  e001              B        |L3.158|
                  |L3.154|
;;;1482     } else {
;;;1483       r = -1;
00009a  f04f35ff          MOV      r5,#0xffffffff
                  |L3.158|
;;;1484     }
;;;1485     return r;
00009e  4628              MOV      r0,r5
;;;1486   }
0000a0  e8bd87f0          POP      {r4-r10,pc}
;;;1487   
                          ENDP

                  |L3.164|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigUpBuffer PROC
;;;1418   */
;;;1419   int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;1420     int r;
;;;1421   
;;;1422     INIT();
000010  bf00              NOP      
000012  4824              LDR      r0,|L4.164|
000014  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000016  b908              CBNZ     r0,|L4.28|
000018  f7fffffe          BL       _DoInit
                  |L4.28|
00001c  bf00              NOP      
;;;1423     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
00001e  4821              LDR      r0,|L4.164|
000020  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000022  42a0              CMP      r0,r4
000024  d939              BLS      |L4.154|
;;;1424       SEGGER_RTT_LOCK();
000026  f3ef8111          MRS      r1,BASEPRI
00002a  4608              MOV      r0,r1
00002c  2120              MOVS     r1,#0x20
00002e  f3818811          MSR      BASEPRI,r1
000032  bf00              NOP      
000034  bf00              NOP      
;;;1425       if (BufferIndex > 0u) {
000036  b30c              CBZ      r4,|L4.124|
;;;1426         _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
000038  eb040244          ADD      r2,r4,r4,LSL #1
00003c  4919              LDR      r1,|L4.164|
00003e  3118              ADDS     r1,r1,#0x18
000040  f8416032          STR      r6,[r1,r2,LSL #3]
;;;1427         _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
000044  eb040244          ADD      r2,r4,r4,LSL #1
000048  eb0101c2          ADD      r1,r1,r2,LSL #3
00004c  604f              STR      r7,[r1,#4]
;;;1428         _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
00004e  eb040244          ADD      r2,r4,r4,LSL #1
000052  4914              LDR      r1,|L4.164|
000054  3118              ADDS     r1,r1,#0x18
000056  eb0101c2          ADD      r1,r1,r2,LSL #3
00005a  f8c18008          STR      r8,[r1,#8]
;;;1429         _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
00005e  2200              MOVS     r2,#0
000060  eb040344          ADD      r3,r4,r4,LSL #1
000064  490f              LDR      r1,|L4.164|
000066  3118              ADDS     r1,r1,#0x18
000068  eb0101c3          ADD      r1,r1,r3,LSL #3
00006c  610a              STR      r2,[r1,#0x10]
;;;1430         _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
00006e  eb040344          ADD      r3,r4,r4,LSL #1
000072  490c              LDR      r1,|L4.164|
000074  3118              ADDS     r1,r1,#0x18
000076  eb0101c3          ADD      r1,r1,r3,LSL #3
00007a  60ca              STR      r2,[r1,#0xc]
                  |L4.124|
;;;1431       }
;;;1432       _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
00007c  eb040244          ADD      r2,r4,r4,LSL #1
000080  4908              LDR      r1,|L4.164|
000082  3118              ADDS     r1,r1,#0x18
000084  eb0101c2          ADD      r1,r1,r2,LSL #3
000088  f8c19014          STR      r9,[r1,#0x14]
;;;1433       SEGGER_RTT_UNLOCK();
00008c  b2c1              UXTB     r1,r0
00008e  f3818811          MSR      BASEPRI,r1
000092  bf00              NOP      
000094  bf00              NOP      
;;;1434       r =  0;
000096  2500              MOVS     r5,#0
000098  e001              B        |L4.158|
                  |L4.154|
;;;1435     } else {
;;;1436       r = -1;
00009a  f04f35ff          MOV      r5,#0xffffffff
                  |L4.158|
;;;1437     }
;;;1438     return r;
00009e  4628              MOV      r0,r5
;;;1439   }
0000a0  e8bd87f0          POP      {r4-r10,pc}
;;;1440   
                          ENDP

                  |L4.164|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_GetKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_GetKey PROC
;;;1196   */
;;;1197   int SEGGER_RTT_GetKey(void) {
000000  b538              PUSH     {r3-r5,lr}
;;;1198     char c;
;;;1199     int r;
;;;1200   
;;;1201     r = (int)SEGGER_RTT_Read(0u, &c, 1u);
000002  2201              MOVS     r2,#1
000004  4669              MOV      r1,sp
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       SEGGER_RTT_Read
00000c  4604              MOV      r4,r0
;;;1202     if (r == 1) {
00000e  2c01              CMP      r4,#1
000010  d102              BNE      |L5.24|
;;;1203       r = (int)(unsigned char)c;
000012  f89d4000          LDRB     r4,[sp,#0]
000016  e001              B        |L5.28|
                  |L5.24|
;;;1204     } else {
;;;1205       r = -1;
000018  f04f34ff          MOV      r4,#0xffffffff
                  |L5.28|
;;;1206     }
;;;1207     return r;
00001c  4620              MOV      r0,r4
;;;1208   }
00001e  bd38              POP      {r3-r5,pc}
;;;1209   
                          ENDP


                          AREA ||i.SEGGER_RTT_HasData||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasData PROC
;;;1273   */
;;;1274   unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;1275     SEGGER_RTT_BUFFER_DOWN* pRing;
;;;1276     unsigned                v;
;;;1277   
;;;1278     pRing = &_SEGGER_RTT.aDown[BufferIndex];
000004  eb010441          ADD      r4,r1,r1,LSL #1
000008  4803              LDR      r0,|L6.24|
00000a  eb0002c4          ADD      r2,r0,r4,LSL #3
;;;1279     v = pRing->WrOff;
00000e  68d3              LDR      r3,[r2,#0xc]
;;;1280     return v - pRing->RdOff;
000010  6910              LDR      r0,[r2,#0x10]
000012  1a18              SUBS     r0,r3,r0
;;;1281   }
000014  bd10              POP      {r4,pc}
;;;1282   
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      _SEGGER_RTT+0x60

                          AREA ||i.SEGGER_RTT_HasDataUp||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasDataUp PROC
;;;1294   */
;;;1295   unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;1296     SEGGER_RTT_BUFFER_UP* pRing;
;;;1297     unsigned                v;
;;;1298   
;;;1299     pRing = &_SEGGER_RTT.aUp[BufferIndex];
000004  eb010441          ADD      r4,r1,r1,LSL #1
000008  4803              LDR      r0,|L7.24|
00000a  eb0002c4          ADD      r2,r0,r4,LSL #3
;;;1300     v = pRing->RdOff;
00000e  6913              LDR      r3,[r2,#0x10]
;;;1301     return pRing->WrOff - v;
000010  68d0              LDR      r0,[r2,#0xc]
000012  1ac0              SUBS     r0,r0,r3
;;;1302   }
000014  bd10              POP      {r4,pc}
;;;1303   
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_HasKey||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasKey PROC
;;;1247   */
;;;1248   int SEGGER_RTT_HasKey(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;1249     unsigned RdOff;
;;;1250     int r;
;;;1251   
;;;1252     INIT();
000002  bf00              NOP      
000004  4807              LDR      r0,|L8.36|
000006  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000008  b908              CBNZ     r0,|L8.14|
00000a  f7fffffe          BL       _DoInit
                  |L8.14|
00000e  bf00              NOP      
;;;1253     RdOff = _SEGGER_RTT.aDown[0].RdOff;
000010  4804              LDR      r0,|L8.36|
000012  6f05              LDR      r5,[r0,#0x70]
;;;1254     if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
000014  6ec0              LDR      r0,[r0,#0x6c]
000016  42a8              CMP      r0,r5
000018  d001              BEQ      |L8.30|
;;;1255       r = 1;
00001a  2401              MOVS     r4,#1
00001c  e000              B        |L8.32|
                  |L8.30|
;;;1256     } else {
;;;1257       r = 0;
00001e  2400              MOVS     r4,#0
                  |L8.32|
;;;1258     }
;;;1259     return r;
000020  4620              MOV      r0,r4
;;;1260   }
000022  bd70              POP      {r4-r6,pc}
;;;1261   
                          ENDP

                  |L8.36|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_Init||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Init PROC
;;;1620   */
;;;1621   void SEGGER_RTT_Init (void) {
000000  b510              PUSH     {r4,lr}
;;;1622     _DoInit();
000002  f7fffffe          BL       _DoInit
;;;1623   }
000006  bd10              POP      {r4,pc}
;;;1624   
                          ENDP


                          AREA ||i.SEGGER_RTT_PutChar||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_PutChar PROC
;;;1135   
;;;1136   unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;1137     SEGGER_RTT_BUFFER_UP* pRing;
;;;1138     unsigned              WrOff;
;;;1139     unsigned              Status;
;;;1140     //
;;;1141     // Prepare
;;;1142     //
;;;1143     INIT();
000008  bf00              NOP      
00000a  481a              LDR      r0,|L10.116|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L10.20|
000010  f7fffffe          BL       _DoInit
                  |L10.20|
000014  bf00              NOP      
;;;1144     SEGGER_RTT_LOCK();
000016  f3ef8111          MRS      r1,BASEPRI
00001a  4608              MOV      r0,r1
00001c  2120              MOVS     r1,#0x20
00001e  f3818811          MSR      BASEPRI,r1
000022  bf00              NOP      
000024  bf00              NOP      
;;;1145     //
;;;1146     // Get "to-host" ring buffer.
;;;1147     //
;;;1148     pRing = &_SEGGER_RTT.aUp[BufferIndex];
000026  eb070247          ADD      r2,r7,r7,LSL #1
00002a  4912              LDR      r1,|L10.116|
00002c  3118              ADDS     r1,r1,#0x18
00002e  eb0104c2          ADD      r4,r1,r2,LSL #3
;;;1149     //
;;;1150     // Get write position and handle wrap-around if necessary
;;;1151     //
;;;1152     WrOff = pRing->WrOff + 1;
000032  68e1              LDR      r1,[r4,#0xc]
000034  1c4d              ADDS     r5,r1,#1
;;;1153     if (WrOff == pRing->SizeOfBuffer) {
000036  68a1              LDR      r1,[r4,#8]
000038  42a9              CMP      r1,r5
00003a  d100              BNE      |L10.62|
;;;1154       WrOff = 0;
00003c  2500              MOVS     r5,#0
                  |L10.62|
;;;1155     }
;;;1156     //
;;;1157     // Wait for free space if mode is set to blocking
;;;1158     //
;;;1159     if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
00003e  6961              LDR      r1,[r4,#0x14]
000040  2902              CMP      r1,#2
000042  d103              BNE      |L10.76|
;;;1160       while (WrOff == pRing->RdOff) {
000044  bf00              NOP      
                  |L10.70|
000046  6921              LDR      r1,[r4,#0x10]
000048  42a9              CMP      r1,r5
00004a  d0fc              BEQ      |L10.70|
                  |L10.76|
;;;1161         ;
;;;1162       }
;;;1163     }
;;;1164     //
;;;1165     // Output byte if free space is available
;;;1166     //
;;;1167     if (WrOff != pRing->RdOff) {
00004c  6921              LDR      r1,[r4,#0x10]
00004e  42a9              CMP      r1,r5
000050  d006              BEQ      |L10.96|
;;;1168       pRing->pBuffer[pRing->WrOff] = c;
000052  68e2              LDR      r2,[r4,#0xc]
000054  6861              LDR      r1,[r4,#4]
000056  f8018002          STRB     r8,[r1,r2]
;;;1169       pRing->WrOff = WrOff;
00005a  60e5              STR      r5,[r4,#0xc]
;;;1170       Status = 1;
00005c  2601              MOVS     r6,#1
00005e  e000              B        |L10.98|
                  |L10.96|
;;;1171     } else {
;;;1172       Status = 0;
000060  2600              MOVS     r6,#0
                  |L10.98|
;;;1173     }
;;;1174     //
;;;1175     // Finish up.
;;;1176     //
;;;1177     SEGGER_RTT_UNLOCK();
000062  b2c1              UXTB     r1,r0
000064  f3818811          MSR      BASEPRI,r1
000068  bf00              NOP      
00006a  bf00              NOP      
;;;1178     //
;;;1179     return Status;
00006c  4630              MOV      r0,r6
;;;1180   }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;1181   
                          ENDP

000072  0000              DCW      0x0000
                  |L10.116|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_PutCharSkip||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_PutCharSkip PROC
;;;1079   
;;;1080   unsigned SEGGER_RTT_PutCharSkip(unsigned BufferIndex, char c) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;1081     SEGGER_RTT_BUFFER_UP* pRing;
;;;1082     unsigned              WrOff;
;;;1083     unsigned              Status;
;;;1084     //
;;;1085     // Prepare
;;;1086     //
;;;1087     INIT();
000008  bf00              NOP      
00000a  4816              LDR      r0,|L11.100|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L11.20|
000010  f7fffffe          BL       _DoInit
                  |L11.20|
000014  bf00              NOP      
;;;1088     SEGGER_RTT_LOCK();
000016  f3ef8111          MRS      r1,BASEPRI
00001a  4608              MOV      r0,r1
00001c  2120              MOVS     r1,#0x20
00001e  f3818811          MSR      BASEPRI,r1
000022  bf00              NOP      
000024  bf00              NOP      
;;;1089     //
;;;1090     // Get "to-host" ring buffer.
;;;1091     //
;;;1092     pRing = &_SEGGER_RTT.aUp[BufferIndex];
000026  eb070247          ADD      r2,r7,r7,LSL #1
00002a  490e              LDR      r1,|L11.100|
00002c  3118              ADDS     r1,r1,#0x18
00002e  eb0104c2          ADD      r4,r1,r2,LSL #3
;;;1093     //
;;;1094     // Get write position and handle wrap-around if necessary
;;;1095     //
;;;1096     WrOff = pRing->WrOff + 1;
000032  68e1              LDR      r1,[r4,#0xc]
000034  1c4d              ADDS     r5,r1,#1
;;;1097     if (WrOff == pRing->SizeOfBuffer) {
000036  68a1              LDR      r1,[r4,#8]
000038  42a9              CMP      r1,r5
00003a  d100              BNE      |L11.62|
;;;1098       WrOff = 0;
00003c  2500              MOVS     r5,#0
                  |L11.62|
;;;1099     }
;;;1100     //
;;;1101     // Output byte if free space is available
;;;1102     //
;;;1103     if (WrOff != pRing->RdOff) {
00003e  6921              LDR      r1,[r4,#0x10]
000040  42a9              CMP      r1,r5
000042  d006              BEQ      |L11.82|
;;;1104       pRing->pBuffer[pRing->WrOff] = c;
000044  68e2              LDR      r2,[r4,#0xc]
000046  6861              LDR      r1,[r4,#4]
000048  f8018002          STRB     r8,[r1,r2]
;;;1105       pRing->WrOff = WrOff;
00004c  60e5              STR      r5,[r4,#0xc]
;;;1106       Status = 1;
00004e  2601              MOVS     r6,#1
000050  e000              B        |L11.84|
                  |L11.82|
;;;1107     } else {
;;;1108       Status = 0;
000052  2600              MOVS     r6,#0
                  |L11.84|
;;;1109     }
;;;1110     //
;;;1111     // Finish up.
;;;1112     //
;;;1113     SEGGER_RTT_UNLOCK();
000054  b2c1              UXTB     r1,r0
000056  f3818811          MSR      BASEPRI,r1
00005a  bf00              NOP      
00005c  bf00              NOP      
;;;1114     //
;;;1115     return Status;
00005e  4630              MOV      r0,r6
;;;1116   }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;1117   
                          ENDP

                  |L11.100|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_PutCharSkipNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_PutCharSkipNoLock PROC
;;;1032   
;;;1033   unsigned SEGGER_RTT_PutCharSkipNoLock(unsigned BufferIndex, char c) {
000000  b570              PUSH     {r4-r6,lr}
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1034     SEGGER_RTT_BUFFER_UP* pRing;
;;;1035     unsigned              WrOff;
;;;1036     unsigned              Status;
;;;1037     //
;;;1038     // Get "to-host" ring buffer.
;;;1039     //
;;;1040     pRing = &_SEGGER_RTT.aUp[BufferIndex];
000006  eb030643          ADD      r6,r3,r3,LSL #1
00000a  4d0a              LDR      r5,|L12.52|
00000c  eb0501c6          ADD      r1,r5,r6,LSL #3
;;;1041     //
;;;1042     // Get write position and handle wrap-around if necessary
;;;1043     //
;;;1044     WrOff = pRing->WrOff + 1;
000010  68cd              LDR      r5,[r1,#0xc]
000012  1c6a              ADDS     r2,r5,#1
;;;1045     if (WrOff == pRing->SizeOfBuffer) {
000014  688d              LDR      r5,[r1,#8]
000016  4295              CMP      r5,r2
000018  d100              BNE      |L12.28|
;;;1046       WrOff = 0;
00001a  2200              MOVS     r2,#0
                  |L12.28|
;;;1047     }
;;;1048     //
;;;1049     // Output byte if free space is available
;;;1050     //
;;;1051     if (WrOff != pRing->RdOff) {
00001c  690d              LDR      r5,[r1,#0x10]
00001e  4295              CMP      r5,r2
000020  d005              BEQ      |L12.46|
;;;1052       pRing->pBuffer[pRing->WrOff] = c;
000022  68ce              LDR      r6,[r1,#0xc]
000024  684d              LDR      r5,[r1,#4]
000026  55ac              STRB     r4,[r5,r6]
;;;1053       pRing->WrOff = WrOff;
000028  60ca              STR      r2,[r1,#0xc]
;;;1054       Status = 1;
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L12.48|
                  |L12.46|
;;;1055     } else {
;;;1056       Status = 0;
00002e  2000              MOVS     r0,#0
                  |L12.48|
;;;1057     }
;;;1058     //
;;;1059     return Status;
;;;1060   }
000030  bd70              POP      {r4-r6,pc}
;;;1061   
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_Read||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Read PROC
;;;615    */
;;;616    unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;617      unsigned NumBytesRead;
;;;618      //
;;;619      SEGGER_RTT_LOCK();
00000a  f3ef8011          MRS      r0,BASEPRI
00000e  4680              MOV      r8,r0
000010  2020              MOVS     r0,#0x20
000012  f3808811          MSR      BASEPRI,r0
000016  bf00              NOP      
000018  bf00              NOP      
;;;620      //
;;;621      // Call the non-locking read function
;;;622      //
;;;623      NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SEGGER_RTT_ReadNoLock
000024  4607              MOV      r7,r0
;;;624      //
;;;625      // Finish up.
;;;626      //
;;;627      SEGGER_RTT_UNLOCK();
000026  f00800ff          AND      r0,r8,#0xff
00002a  f3808811          MSR      BASEPRI,r0
00002e  bf00              NOP      
000030  bf00              NOP      
;;;628      //
;;;629      return NumBytesRead;
000032  4638              MOV      r0,r7
;;;630    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;631    
                          ENDP


                          AREA ||i.SEGGER_RTT_ReadNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ReadNoLock PROC
;;;525    */
;;;526    unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  4683              MOV      r11,r0
000006  4617              MOV      r7,r2
;;;527      unsigned                NumBytesRem;
;;;528      unsigned                NumBytesRead;
;;;529      unsigned                RdOff;
;;;530      unsigned                WrOff;
;;;531      unsigned char*          pBuffer;
;;;532      SEGGER_RTT_BUFFER_DOWN* pRing;
;;;533    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;534      const char*             pSrc;
;;;535    #endif
;;;536      //
;;;537      INIT();
000008  bf00              NOP      
00000a  4822              LDR      r0,|L14.148|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L14.20|
000010  f7fffffe          BL       _DoInit
                  |L14.20|
000014  bf00              NOP      
;;;538      pRing = &_SEGGER_RTT.aDown[BufferIndex];
000016  eb0b014b          ADD      r1,r11,r11,LSL #1
00001a  481e              LDR      r0,|L14.148|
00001c  3060              ADDS     r0,r0,#0x60
00001e  eb0006c1          ADD      r6,r0,r1,LSL #3
;;;539      pBuffer = (unsigned char*)pData;
000022  f8dd9004          LDR      r9,[sp,#4]
;;;540      RdOff = pRing->RdOff;
000026  6935              LDR      r5,[r6,#0x10]
;;;541      WrOff = pRing->WrOff;
000028  f8d6a00c          LDR      r10,[r6,#0xc]
;;;542      NumBytesRead = 0u;
00002c  f04f0800          MOV      r8,#0
;;;543      //
;;;544      // Read from current read position to wrap-around of buffer, first
;;;545      //
;;;546      if (RdOff > WrOff) {
000030  4555              CMP      r5,r10
000032  d915              BLS      |L14.96|
;;;547        NumBytesRem = pRing->SizeOfBuffer - RdOff;
000034  68b0              LDR      r0,[r6,#8]
000036  1b44              SUBS     r4,r0,r5
;;;548        NumBytesRem = MIN(NumBytesRem, BufferSize);
000038  42bc              CMP      r4,r7
00003a  d201              BCS      |L14.64|
00003c  4620              MOV      r0,r4
00003e  e000              B        |L14.66|
                  |L14.64|
000040  4638              MOV      r0,r7
                  |L14.66|
000042  4604              MOV      r4,r0
;;;549    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;550        pSrc = pRing->pBuffer + RdOff;
;;;551        NumBytesRead += NumBytesRem;
;;;552        BufferSize   -= NumBytesRem;
;;;553        RdOff        += NumBytesRem;
;;;554        while (NumBytesRem--) {
;;;555          *pBuffer++ = *pSrc++;
;;;556        };
;;;557    #else
;;;558        SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000044  6870              LDR      r0,[r6,#4]
000046  1941              ADDS     r1,r0,r5
000048  4622              MOV      r2,r4
00004a  4648              MOV      r0,r9
00004c  f7fffffe          BL       __aeabi_memcpy
;;;559        NumBytesRead += NumBytesRem;
000050  44a0              ADD      r8,r8,r4
;;;560        pBuffer      += NumBytesRem;
000052  44a1              ADD      r9,r9,r4
;;;561        BufferSize   -= NumBytesRem;
000054  1b3f              SUBS     r7,r7,r4
;;;562        RdOff        += NumBytesRem;
000056  4425              ADD      r5,r5,r4
;;;563    #endif
;;;564        //
;;;565        // Handle wrap-around of buffer
;;;566        //
;;;567        if (RdOff == pRing->SizeOfBuffer) {
000058  68b0              LDR      r0,[r6,#8]
00005a  42a8              CMP      r0,r5
00005c  d100              BNE      |L14.96|
;;;568          RdOff = 0u;
00005e  2500              MOVS     r5,#0
                  |L14.96|
;;;569        }
;;;570      }
;;;571      //
;;;572      // Read remaining items of buffer
;;;573      //
;;;574      NumBytesRem = WrOff - RdOff;
000060  ebaa0405          SUB      r4,r10,r5
;;;575      NumBytesRem = MIN(NumBytesRem, BufferSize);
000064  42bc              CMP      r4,r7
000066  d201              BCS      |L14.108|
000068  4620              MOV      r0,r4
00006a  e000              B        |L14.110|
                  |L14.108|
00006c  4638              MOV      r0,r7
                  |L14.110|
00006e  4604              MOV      r4,r0
;;;576      if (NumBytesRem > 0u) {
000070  b14c              CBZ      r4,|L14.134|
;;;577    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;578        pSrc = pRing->pBuffer + RdOff;
;;;579        NumBytesRead += NumBytesRem;
;;;580        BufferSize   -= NumBytesRem;
;;;581        RdOff        += NumBytesRem;
;;;582        while (NumBytesRem--) {
;;;583          *pBuffer++ = *pSrc++;
;;;584        };
;;;585    #else
;;;586        SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000072  6870              LDR      r0,[r6,#4]
000074  1941              ADDS     r1,r0,r5
000076  4622              MOV      r2,r4
000078  4648              MOV      r0,r9
00007a  f7fffffe          BL       __aeabi_memcpy
;;;587        NumBytesRead += NumBytesRem;
00007e  44a0              ADD      r8,r8,r4
;;;588        pBuffer      += NumBytesRem;
000080  44a1              ADD      r9,r9,r4
;;;589        BufferSize   -= NumBytesRem;
000082  1b3f              SUBS     r7,r7,r4
;;;590        RdOff        += NumBytesRem;
000084  4425              ADD      r5,r5,r4
                  |L14.134|
;;;591    #endif
;;;592      }
;;;593      if (NumBytesRead) {
000086  f1b80f00          CMP      r8,#0
00008a  d000              BEQ      |L14.142|
;;;594        pRing->RdOff = RdOff;
00008c  6135              STR      r5,[r6,#0x10]
                  |L14.142|
;;;595      }
;;;596      //
;;;597      return NumBytesRead;
00008e  4640              MOV      r0,r8
;;;598    }
000090  e8bd8ffe          POP      {r1-r11,pc}
;;;599    
                          ENDP

                  |L14.148|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetFlagsDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetFlagsDownBuffer PROC
;;;1596   */
;;;1597   int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1598     int r;
;;;1599   
;;;1600     INIT();
000006  bf00              NOP      
000008  4811              LDR      r0,|L15.80|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L15.18|
00000e  f7fffffe          BL       _DoInit
                  |L15.18|
000012  bf00              NOP      
;;;1601     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
000014  480e              LDR      r0,|L15.80|
000016  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d915              BLS      |L15.72|
;;;1602       SEGGER_RTT_LOCK();
00001c  f3ef8111          MRS      r1,BASEPRI
000020  4608              MOV      r0,r1
000022  2120              MOVS     r1,#0x20
000024  f3818811          MSR      BASEPRI,r1
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1603       _SEGGER_RTT.aDown[BufferIndex].Flags = Flags;
00002c  eb040244          ADD      r2,r4,r4,LSL #1
000030  4907              LDR      r1,|L15.80|
000032  3160              ADDS     r1,r1,#0x60
000034  eb0101c2          ADD      r1,r1,r2,LSL #3
000038  614e              STR      r6,[r1,#0x14]
;;;1604       SEGGER_RTT_UNLOCK();
00003a  b2c1              UXTB     r1,r0
00003c  f3818811          MSR      BASEPRI,r1
000040  bf00              NOP      
000042  bf00              NOP      
;;;1605       r =  0;
000044  2500              MOVS     r5,#0
000046  e001              B        |L15.76|
                  |L15.72|
;;;1606     } else {
;;;1607       r = -1;
000048  f04f35ff          MOV      r5,#0xffffffff
                  |L15.76|
;;;1608     }
;;;1609     return r;
00004c  4628              MOV      r0,r5
;;;1610   }
00004e  bd70              POP      {r4-r6,pc}
;;;1611   
                          ENDP

                  |L15.80|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetFlagsUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetFlagsUpBuffer PROC
;;;1565   */
;;;1566   int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1567     int r;
;;;1568   
;;;1569     INIT();
000006  bf00              NOP      
000008  4811              LDR      r0,|L16.80|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L16.18|
00000e  f7fffffe          BL       _DoInit
                  |L16.18|
000012  bf00              NOP      
;;;1570     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
000014  480e              LDR      r0,|L16.80|
000016  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d915              BLS      |L16.72|
;;;1571       SEGGER_RTT_LOCK();
00001c  f3ef8111          MRS      r1,BASEPRI
000020  4608              MOV      r0,r1
000022  2120              MOVS     r1,#0x20
000024  f3818811          MSR      BASEPRI,r1
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1572       _SEGGER_RTT.aUp[BufferIndex].Flags = Flags;
00002c  eb040244          ADD      r2,r4,r4,LSL #1
000030  4907              LDR      r1,|L16.80|
000032  3118              ADDS     r1,r1,#0x18
000034  eb0101c2          ADD      r1,r1,r2,LSL #3
000038  614e              STR      r6,[r1,#0x14]
;;;1573       SEGGER_RTT_UNLOCK();
00003a  b2c1              UXTB     r1,r0
00003c  f3818811          MSR      BASEPRI,r1
000040  bf00              NOP      
000042  bf00              NOP      
;;;1574       r =  0;
000044  2500              MOVS     r5,#0
000046  e001              B        |L16.76|
                  |L16.72|
;;;1575     } else {
;;;1576       r = -1;
000048  f04f35ff          MOV      r5,#0xffffffff
                  |L16.76|
;;;1577     }
;;;1578     return r;
00004c  4628              MOV      r0,r5
;;;1579   }
00004e  bd70              POP      {r4-r6,pc}
;;;1580   
                          ENDP

                  |L16.80|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameDownBuffer PROC
;;;1534   */
;;;1535   int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1536     int r;
;;;1537   
;;;1538     INIT();
000006  bf00              NOP      
000008  4811              LDR      r0,|L17.80|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L17.18|
00000e  f7fffffe          BL       _DoInit
                  |L17.18|
000012  bf00              NOP      
;;;1539     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
000014  480e              LDR      r0,|L17.80|
000016  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d914              BLS      |L17.70|
;;;1540       SEGGER_RTT_LOCK();
00001c  f3ef8111          MRS      r1,BASEPRI
000020  4608              MOV      r0,r1
000022  2120              MOVS     r1,#0x20
000024  f3818811          MSR      BASEPRI,r1
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1541       _SEGGER_RTT.aDown[BufferIndex].sName = sName;
00002c  eb040244          ADD      r2,r4,r4,LSL #1
000030  4907              LDR      r1,|L17.80|
000032  3160              ADDS     r1,r1,#0x60
000034  f8416032          STR      r6,[r1,r2,LSL #3]
;;;1542       SEGGER_RTT_UNLOCK();
000038  b2c1              UXTB     r1,r0
00003a  f3818811          MSR      BASEPRI,r1
00003e  bf00              NOP      
000040  bf00              NOP      
;;;1543       r =  0;
000042  2500              MOVS     r5,#0
000044  e001              B        |L17.74|
                  |L17.70|
;;;1544     } else {
;;;1545       r = -1;
000046  f04f35ff          MOV      r5,#0xffffffff
                  |L17.74|
;;;1546     }
;;;1547     return r;
00004a  4628              MOV      r0,r5
;;;1548   }
00004c  bd70              POP      {r4-r6,pc}
;;;1549   
                          ENDP

00004e  0000              DCW      0x0000
                  |L17.80|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameUpBuffer PROC
;;;1503   */
;;;1504   int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1505     int r;
;;;1506   
;;;1507     INIT();
000006  bf00              NOP      
000008  4811              LDR      r0,|L18.80|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L18.18|
00000e  f7fffffe          BL       _DoInit
                  |L18.18|
000012  bf00              NOP      
;;;1508     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
000014  480e              LDR      r0,|L18.80|
000016  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d914              BLS      |L18.70|
;;;1509       SEGGER_RTT_LOCK();
00001c  f3ef8111          MRS      r1,BASEPRI
000020  4608              MOV      r0,r1
000022  2120              MOVS     r1,#0x20
000024  f3818811          MSR      BASEPRI,r1
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1510       _SEGGER_RTT.aUp[BufferIndex].sName = sName;
00002c  eb040244          ADD      r2,r4,r4,LSL #1
000030  4907              LDR      r1,|L18.80|
000032  3118              ADDS     r1,r1,#0x18
000034  f8416032          STR      r6,[r1,r2,LSL #3]
;;;1511       SEGGER_RTT_UNLOCK();
000038  b2c1              UXTB     r1,r0
00003a  f3818811          MSR      BASEPRI,r1
00003e  bf00              NOP      
000040  bf00              NOP      
;;;1512       r =  0;
000042  2500              MOVS     r5,#0
000044  e001              B        |L18.74|
                  |L18.70|
;;;1513     } else {
;;;1514       r = -1;
000046  f04f35ff          MOV      r5,#0xffffffff
                  |L18.74|
;;;1515     }
;;;1516     return r;
00004a  4628              MOV      r0,r5
;;;1517   }
00004c  bd70              POP      {r4-r6,pc}
;;;1518   
                          ENDP

00004e  0000              DCW      0x0000
                  |L18.80|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetTerminal||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetTerminal PROC
;;;1638   */
;;;1639   int SEGGER_RTT_SetTerminal (char TerminalId) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
;;;1640     unsigned char         ac[2];
;;;1641     SEGGER_RTT_BUFFER_UP* pRing;
;;;1642     unsigned Avail;
;;;1643     int r;
;;;1644     //
;;;1645     INIT();
000006  bf00              NOP      
000008  4821              LDR      r0,|L19.144|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L19.18|
00000e  f7fffffe          BL       _DoInit
                  |L19.18|
000012  bf00              NOP      
;;;1646     //
;;;1647     r = 0;
000014  2700              MOVS     r7,#0
;;;1648     ac[0] = 0xFFu;
000016  20ff              MOVS     r0,#0xff
000018  f88d0000          STRB     r0,[sp,#0]
;;;1649     if ((unsigned char)TerminalId < (unsigned char)sizeof(_aTerminalId)) { // We only support a certain number of channels
00001c  2c10              CMP      r4,#0x10
00001e  da31              BGE      |L19.132|
;;;1650       ac[1] = _aTerminalId[(unsigned char)TerminalId];
000020  481c              LDR      r0,|L19.148|
000022  5d00              LDRB     r0,[r0,r4]
000024  f88d0001          STRB     r0,[sp,#1]
;;;1651       pRing = &_SEGGER_RTT.aUp[0];    // Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
000028  4d19              LDR      r5,|L19.144|
00002a  3518              ADDS     r5,r5,#0x18
;;;1652       SEGGER_RTT_LOCK();    // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
00002c  f3ef8011          MRS      r0,BASEPRI
000030  4680              MOV      r8,r0
000032  2020              MOVS     r0,#0x20
000034  f3808811          MSR      BASEPRI,r0
000038  bf00              NOP      
00003a  bf00              NOP      
;;;1653       if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
00003c  7d28              LDRB     r0,[r5,#0x14]
00003e  f0000003          AND      r0,r0,#3
000042  2802              CMP      r0,#2
000044  d107              BNE      |L19.86|
;;;1654         _ActiveTerminal = TerminalId;
000046  4814              LDR      r0,|L19.152|
000048  7004              STRB     r4,[r0,#0]
;;;1655         _WriteBlocking(pRing, (const char*)ac, 2u);
00004a  2202              MOVS     r2,#2
00004c  4669              MOV      r1,sp
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       _WriteBlocking
000054  e00f              B        |L19.118|
                  |L19.86|
;;;1656       } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
;;;1657         Avail = _GetAvailWriteSpace(pRing);
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       _GetAvailWriteSpace
00005c  4606              MOV      r6,r0
;;;1658         if (Avail >= 2) {
00005e  2e02              CMP      r6,#2
000060  d307              BCC      |L19.114|
;;;1659           _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
000062  480d              LDR      r0,|L19.152|
000064  7004              STRB     r4,[r0,#0]
;;;1660           _WriteNoCheck(pRing, (const char*)ac, 2u);
000066  2202              MOVS     r2,#2
000068  4669              MOV      r1,sp
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       _WriteNoCheck
000070  e001              B        |L19.118|
                  |L19.114|
;;;1661         } else {
;;;1662           r = -1;
000072  f04f37ff          MOV      r7,#0xffffffff
                  |L19.118|
;;;1663         }
;;;1664       }
;;;1665       SEGGER_RTT_UNLOCK();
000076  f00800ff          AND      r0,r8,#0xff
00007a  f3808811          MSR      BASEPRI,r0
00007e  bf00              NOP      
000080  bf00              NOP      
000082  e001              B        |L19.136|
                  |L19.132|
;;;1666     } else {
;;;1667       r = -1;
000084  f04f37ff          MOV      r7,#0xffffffff
                  |L19.136|
;;;1668     }
;;;1669     return r;
000088  4638              MOV      r0,r7
;;;1670   }
00008a  e8bd83f8          POP      {r3-r9,pc}
;;;1671   
                          ENDP

00008e  0000              DCW      0x0000
                  |L19.144|
                          DCD      _SEGGER_RTT
                  |L19.148|
                          DCD      _aTerminalId
                  |L19.152|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_TerminalOut||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_TerminalOut PROC
;;;1688   */
;;;1689   int SEGGER_RTT_TerminalOut (char TerminalId, const char* s) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4689              MOV      r9,r1
;;;1690     int                   Status;
;;;1691     unsigned              FragLen;
;;;1692     unsigned              Avail;
;;;1693     SEGGER_RTT_BUFFER_UP* pRing;
;;;1694     //
;;;1695     INIT();
000008  bf00              NOP      
00000a  483b              LDR      r0,|L20.248|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L20.20|
000010  f7fffffe          BL       _DoInit
                  |L20.20|
000014  bf00              NOP      
;;;1696     //
;;;1697     // Validate terminal ID.
;;;1698     //
;;;1699     if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
000016  2f10              CMP      r7,#0x10
000018  da68              BGE      |L20.236|
;;;1700       //
;;;1701       // Get "to-host" ring buffer.
;;;1702       //
;;;1703       pRing = &_SEGGER_RTT.aUp[0];
00001a  f8df80dc          LDR      r8,|L20.248|
00001e  f1080818          ADD      r8,r8,#0x18
;;;1704       //
;;;1705       // Need to be able to change terminal, write data, change back.
;;;1706       // Compute the fixed and variable sizes.
;;;1707       //
;;;1708       FragLen = STRLEN(s);
000022  4648              MOV      r0,r9
000024  f7fffffe          BL       strlen
000028  4606              MOV      r6,r0
;;;1709       //
;;;1710       // How we output depends upon the mode...
;;;1711       //
;;;1712       SEGGER_RTT_LOCK();
00002a  f3ef8011          MRS      r0,BASEPRI
00002e  4682              MOV      r10,r0
000030  2020              MOVS     r0,#0x20
000032  f3808811          MSR      BASEPRI,r0
000036  bf00              NOP      
000038  bf00              NOP      
;;;1713       Avail = _GetAvailWriteSpace(pRing);
00003a  4640              MOV      r0,r8
00003c  f7fffffe          BL       _GetAvailWriteSpace
000040  4605              MOV      r5,r0
;;;1714       switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
000042  f8980014          LDRB     r0,[r8,#0x14]
000046  f0000003          AND      r0,r0,#3
00004a  b120              CBZ      r0,|L20.86|
00004c  2801              CMP      r0,#1
00004e  d017              BEQ      |L20.128|
000050  2802              CMP      r0,#2
000052  d140              BNE      |L20.214|
000054  e02f              B        |L20.182|
                  |L20.86|
;;;1715       case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1716         //
;;;1717         // If we are in skip mode and there is no space for the whole
;;;1718         // of this output, don't bother switching terminals at all.
;;;1719         //
;;;1720         if (Avail < (FragLen + 4u)) {
000056  1d30              ADDS     r0,r6,#4
000058  4285              CMP      r5,r0
00005a  d201              BCS      |L20.96|
;;;1721           Status = 0;
00005c  2400              MOVS     r4,#0
00005e  e00e              B        |L20.126|
                  |L20.96|
;;;1722         } else {
;;;1723           _PostTerminalSwitch(pRing, TerminalId);
000060  4639              MOV      r1,r7
000062  4640              MOV      r0,r8
000064  f7fffffe          BL       _PostTerminalSwitch
;;;1724           Status = (int)_WriteBlocking(pRing, s, FragLen);
000068  4632              MOV      r2,r6
00006a  4649              MOV      r1,r9
00006c  4640              MOV      r0,r8
00006e  f7fffffe          BL       _WriteBlocking
000072  4604              MOV      r4,r0
;;;1725           _PostTerminalSwitch(pRing, _ActiveTerminal);
000074  4821              LDR      r0,|L20.252|
000076  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
000078  4640              MOV      r0,r8
00007a  f7fffffe          BL       _PostTerminalSwitch
                  |L20.126|
;;;1726         }
;;;1727         break;
00007e  e02d              B        |L20.220|
                  |L20.128|
;;;1728       case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1729         //
;;;1730         // If we are in trim mode and there is not enough space for everything,
;;;1731         // trim the output but always include the terminal switch.  If no room
;;;1732         // for terminal switch, skip that totally.
;;;1733         //
;;;1734         if (Avail < 4u) {
000080  2d04              CMP      r5,#4
000082  d202              BCS      |L20.138|
;;;1735           Status = -1;
000084  f04f34ff          MOV      r4,#0xffffffff
000088  e014              B        |L20.180|
                  |L20.138|
;;;1736         } else {
;;;1737           _PostTerminalSwitch(pRing, TerminalId);
00008a  4639              MOV      r1,r7
00008c  4640              MOV      r0,r8
00008e  f7fffffe          BL       _PostTerminalSwitch
;;;1738           Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
000092  1f28              SUBS     r0,r5,#4
000094  42b0              CMP      r0,r6
000096  d901              BLS      |L20.156|
000098  4630              MOV      r0,r6
00009a  e000              B        |L20.158|
                  |L20.156|
00009c  1f28              SUBS     r0,r5,#4
                  |L20.158|
00009e  4602              MOV      r2,r0
0000a0  4649              MOV      r1,r9
0000a2  4640              MOV      r0,r8
0000a4  f7fffffe          BL       _WriteBlocking
0000a8  4604              MOV      r4,r0
;;;1739           _PostTerminalSwitch(pRing, _ActiveTerminal);
0000aa  4814              LDR      r0,|L20.252|
0000ac  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000ae  4640              MOV      r0,r8
0000b0  f7fffffe          BL       _PostTerminalSwitch
                  |L20.180|
;;;1740         }
;;;1741         break;
0000b4  e012              B        |L20.220|
                  |L20.182|
;;;1742       case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1743         //
;;;1744         // If we are in blocking mode, output everything.
;;;1745         //
;;;1746         _PostTerminalSwitch(pRing, TerminalId);
0000b6  4639              MOV      r1,r7
0000b8  4640              MOV      r0,r8
0000ba  f7fffffe          BL       _PostTerminalSwitch
;;;1747         Status = (int)_WriteBlocking(pRing, s, FragLen);
0000be  4632              MOV      r2,r6
0000c0  4649              MOV      r1,r9
0000c2  4640              MOV      r0,r8
0000c4  f7fffffe          BL       _WriteBlocking
0000c8  4604              MOV      r4,r0
;;;1748         _PostTerminalSwitch(pRing, _ActiveTerminal);
0000ca  480c              LDR      r0,|L20.252|
0000cc  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000ce  4640              MOV      r0,r8
0000d0  f7fffffe          BL       _PostTerminalSwitch
;;;1749         break;
0000d4  e002              B        |L20.220|
                  |L20.214|
;;;1750       default:
;;;1751         Status = -1;
0000d6  f04f34ff          MOV      r4,#0xffffffff
;;;1752         break;
0000da  bf00              NOP      
                  |L20.220|
0000dc  bf00              NOP                            ;1727
;;;1753       }
;;;1754       //
;;;1755       // Finish up.
;;;1756       //
;;;1757       SEGGER_RTT_UNLOCK();
0000de  f00a00ff          AND      r0,r10,#0xff
0000e2  f3808811          MSR      BASEPRI,r0
0000e6  bf00              NOP      
0000e8  bf00              NOP      
0000ea  e001              B        |L20.240|
                  |L20.236|
;;;1758     } else {
;;;1759       Status = -1;
0000ec  f04f34ff          MOV      r4,#0xffffffff
                  |L20.240|
;;;1760     }
;;;1761     return Status;
0000f0  4620              MOV      r0,r4
;;;1762   }
0000f2  e8bd87f0          POP      {r4-r10,pc}
;;;1763   
                          ENDP

0000f6  0000              DCW      0x0000
                  |L20.248|
                          DCD      _SEGGER_RTT
                  |L20.252|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_WaitKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WaitKey PROC
;;;1224   */
;;;1225   int SEGGER_RTT_WaitKey(void) {
000000  b510              PUSH     {r4,lr}
;;;1226     int r;
;;;1227   
;;;1228     do {
000002  bf00              NOP      
                  |L21.4|
;;;1229       r = SEGGER_RTT_GetKey();
000004  f7fffffe          BL       SEGGER_RTT_GetKey
;;;1230     } while (r < 0);
000008  2800              CMP      r0,#0
00000a  dbfb              BLT      |L21.4|
;;;1231     return r;
;;;1232   }
00000c  bd10              POP      {r4,pc}
;;;1233   
                          ENDP


                          AREA ||i.SEGGER_RTT_Write||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Write PROC
;;;965    */
;;;966    unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;967      unsigned Status;
;;;968      //
;;;969      INIT();
00000a  bf00              NOP      
00000c  480d              LDR      r0,|L22.68|
00000e  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000010  b908              CBNZ     r0,|L22.22|
000012  f7fffffe          BL       _DoInit
                  |L22.22|
000016  bf00              NOP      
;;;970      SEGGER_RTT_LOCK();
000018  f3ef8011          MRS      r0,BASEPRI
00001c  4607              MOV      r7,r0
00001e  2020              MOVS     r0,#0x20
000020  f3808811          MSR      BASEPRI,r0
000024  bf00              NOP      
000026  bf00              NOP      
;;;971      //
;;;972      // Call the non-locking write function
;;;973      //
;;;974      Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
000028  4632              MOV      r2,r6
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SEGGER_RTT_WriteNoLock
000032  4680              MOV      r8,r0
;;;975      //
;;;976      // Finish up.
;;;977      //
;;;978      SEGGER_RTT_UNLOCK();
000034  b2f8              UXTB     r0,r7
000036  f3808811          MSR      BASEPRI,r0
00003a  bf00              NOP      
00003c  bf00              NOP      
;;;979      //
;;;980      return Status;
00003e  4640              MOV      r0,r8
;;;981    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;982    
                          ENDP

                  |L22.68|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_WriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteNoLock PROC
;;;894    */
;;;895    unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;896      unsigned              Status;
;;;897      unsigned              Avail;
;;;898      const char*           pData;
;;;899      SEGGER_RTT_BUFFER_UP* pRing;
;;;900    
;;;901      pData = (const char *)pBuffer;
00000a  46c2              MOV      r10,r8
;;;902      //
;;;903      // Get "to-host" ring buffer.
;;;904      //
;;;905      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  eb070147          ADD      r1,r7,r7,LSL #1
000010  481b              LDR      r0,|L23.128|
000012  eb0009c1          ADD      r9,r0,r1,LSL #3
;;;906      //
;;;907      // How we output depends upon the mode...
;;;908      //
;;;909      switch (pRing->Flags) {
000016  f8d90014          LDR      r0,[r9,#0x14]
00001a  b120              CBZ      r0,|L23.38|
00001c  2801              CMP      r0,#1
00001e  d011              BEQ      |L23.68|
000020  2802              CMP      r0,#2
000022  d126              BNE      |L23.114|
000024  e01e              B        |L23.100|
                  |L23.38|
;;;910      case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;911        //
;;;912        // If we are in skip mode and there is no space for the whole
;;;913        // of this output, don't bother.
;;;914        //
;;;915        Avail = _GetAvailWriteSpace(pRing);
000026  4648              MOV      r0,r9
000028  f7fffffe          BL       _GetAvailWriteSpace
00002c  4605              MOV      r5,r0
;;;916        if (Avail < NumBytes) {
00002e  42b5              CMP      r5,r6
000030  d201              BCS      |L23.54|
;;;917          Status = 0u;
000032  2400              MOVS     r4,#0
000034  e005              B        |L23.66|
                  |L23.54|
;;;918        } else {
;;;919          Status = NumBytes;
000036  4634              MOV      r4,r6
;;;920          _WriteNoCheck(pRing, pData, NumBytes);
000038  4632              MOV      r2,r6
00003a  4651              MOV      r1,r10
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       _WriteNoCheck
                  |L23.66|
;;;921        }
;;;922        break;
000042  e018              B        |L23.118|
                  |L23.68|
;;;923      case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;924        //
;;;925        // If we are in trim mode, trim to what we can output without blocking.
;;;926        //
;;;927        Avail = _GetAvailWriteSpace(pRing);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       _GetAvailWriteSpace
00004a  4605              MOV      r5,r0
;;;928        Status = Avail < NumBytes ? Avail : NumBytes;
00004c  42b5              CMP      r5,r6
00004e  d201              BCS      |L23.84|
000050  4628              MOV      r0,r5
000052  e000              B        |L23.86|
                  |L23.84|
000054  4630              MOV      r0,r6
                  |L23.86|
000056  4604              MOV      r4,r0
;;;929        _WriteNoCheck(pRing, pData, Status);
000058  4622              MOV      r2,r4
00005a  4651              MOV      r1,r10
00005c  4648              MOV      r0,r9
00005e  f7fffffe          BL       _WriteNoCheck
;;;930        break;
000062  e008              B        |L23.118|
                  |L23.100|
;;;931      case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;932        //
;;;933        // If we are in blocking mode, output everything.
;;;934        //
;;;935        Status = _WriteBlocking(pRing, pData, NumBytes);
000064  4632              MOV      r2,r6
000066  4651              MOV      r1,r10
000068  4648              MOV      r0,r9
00006a  f7fffffe          BL       _WriteBlocking
00006e  4604              MOV      r4,r0
;;;936        break;
000070  e001              B        |L23.118|
                  |L23.114|
;;;937      default:
;;;938        Status = 0u;
000072  2400              MOVS     r4,#0
;;;939        break;
000074  bf00              NOP      
                  |L23.118|
000076  bf00              NOP                            ;922
;;;940      }
;;;941      //
;;;942      // Finish up.
;;;943      //
;;;944      return Status;
000078  4620              MOV      r0,r4
;;;945    }
00007a  e8bd87f0          POP      {r4-r10,pc}
;;;946    
                          ENDP

00007e  0000              DCW      0x0000
                  |L23.128|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteSkipNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteSkipNoLock PROC
;;;750    */
;;;751    unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4682              MOV      r10,r0
000006  468b              MOV      r11,r1
000008  4616              MOV      r6,r2
;;;752      const char*           pData;
;;;753      SEGGER_RTT_BUFFER_UP* pRing;
;;;754      unsigned              Avail;
;;;755      unsigned              RdOff;
;;;756      unsigned              WrOff;
;;;757      unsigned              Rem;
;;;758    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;759      char*                 pDst;
;;;760    #endif
;;;761    
;;;762      pData = (const char *)pBuffer;
00000a  f8cdb000          STR      r11,[sp,#0]
;;;763      //
;;;764      // Get "to-host" ring buffer and copy some elements into local variables.
;;;765      //
;;;766      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000e  eb0a014a          ADD      r1,r10,r10,LSL #1
000012  4826              LDR      r0,|L24.172|
000014  eb0004c1          ADD      r4,r0,r1,LSL #3
;;;767      RdOff = pRing->RdOff;
000018  f8d49010          LDR      r9,[r4,#0x10]
;;;768      WrOff = pRing->WrOff;
00001c  68e5              LDR      r5,[r4,#0xc]
;;;769      //
;;;770      // Handle the most common cases fastest.
;;;771      // Which is:
;;;772      //    RdOff <= WrOff -> Space until wrap around is free.
;;;773      //  AND
;;;774      //    WrOff + NumBytes < SizeOfBuffer -> No Wrap around necessary.
;;;775      //
;;;776      //  OR
;;;777      //
;;;778      //    RdOff > WrOff -> Space until RdOff - 1 is free.
;;;779      //  AND
;;;780      //    WrOff + NumBytes < RdOff -> Data fits into buffer
;;;781      //
;;;782      if (RdOff <= WrOff) {
00001e  45a9              CMP      r9,r5
000020  d833              BHI      |L24.138|
;;;783        //
;;;784        // Get space until WrOff will be at wrap around.
;;;785        //
;;;786        Avail = pRing->SizeOfBuffer - 1u - WrOff ;
000022  68a0              LDR      r0,[r4,#8]
000024  1e40              SUBS     r0,r0,#1
000026  1b47              SUBS     r7,r0,r5
;;;787        if (Avail >= NumBytes) {
000028  42b7              CMP      r7,r6
00002a  d30a              BCC      |L24.66|
;;;788    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;789          pDst = pRing->pBuffer + WrOff;
;;;790          WrOff += NumBytes;
;;;791          while (NumBytes--) {
;;;792            *pDst++ = *pData++;
;;;793          };
;;;794          pRing->WrOff = WrOff;
;;;795    #else
;;;796          SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
00002c  6861              LDR      r1,[r4,#4]
00002e  1948              ADDS     r0,r1,r5
000030  4632              MOV      r2,r6
000032  9900              LDR      r1,[sp,#0]
000034  f7fffffe          BL       __aeabi_memcpy
;;;797          pRing->WrOff = WrOff + NumBytes;
000038  19a8              ADDS     r0,r5,r6
00003a  60e0              STR      r0,[r4,#0xc]
;;;798    #endif
;;;799          return 1;
00003c  2001              MOVS     r0,#1
                  |L24.62|
;;;800        }
;;;801        //
;;;802        // If data did not fit into space until wrap around calculate complete space in buffer.
;;;803        //
;;;804        Avail += RdOff;
;;;805        //
;;;806        // If there is still no space for the whole of this output, don't bother.
;;;807        //
;;;808        if (Avail >= NumBytes) {
;;;809          //
;;;810          //  OK, we have enough space in buffer. Copy in one or 2 chunks
;;;811          //
;;;812          Rem = pRing->SizeOfBuffer - WrOff;      // Space until end of buffer
;;;813          if (Rem > NumBytes) {
;;;814    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;815            pDst = pRing->pBuffer + WrOff;
;;;816            WrOff += NumBytes;
;;;817            while (NumBytes--) {
;;;818              *pDst++ = *pData++;
;;;819            };
;;;820            pRing->WrOff = WrOff;
;;;821    #else
;;;822            SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
;;;823            pRing->WrOff = WrOff + NumBytes;
;;;824    #endif
;;;825          } else {
;;;826            //
;;;827            // We reach the end of the buffer, so need to wrap around
;;;828            //
;;;829    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;830            pDst = pRing->pBuffer + WrOff;
;;;831            NumBytes -= Rem;
;;;832            WrOff = NumBytes;
;;;833            do {
;;;834              *pDst++ = *pData++;
;;;835            } while (--Rem);
;;;836            pDst = pRing->pBuffer;
;;;837            while (NumBytes--) {
;;;838              *pDst++ = *pData++;
;;;839            };
;;;840            pRing->WrOff = WrOff;
;;;841    #else
;;;842            SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, Rem);
;;;843            SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytes - Rem);
;;;844            pRing->WrOff = NumBytes - Rem;
;;;845    #endif
;;;846          }
;;;847          return 1;
;;;848        }
;;;849      } else {
;;;850        Avail = RdOff - WrOff - 1u;
;;;851        if (Avail >= NumBytes) {
;;;852    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;853          pDst = pRing->pBuffer + WrOff;
;;;854          WrOff += NumBytes;
;;;855          while (NumBytes--) {
;;;856            *pDst++ = *pData++;
;;;857          };
;;;858          pRing->WrOff = WrOff;
;;;859    #else
;;;860          SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
;;;861          pRing->WrOff = WrOff + NumBytes;
;;;862    #endif
;;;863          return 1;
;;;864        }
;;;865      }
;;;866      //
;;;867      // If we reach this point no data has been written
;;;868      //
;;;869      return 0;
;;;870    }
00003e  e8bd8ff8          POP      {r3-r11,pc}
                  |L24.66|
000042  444f              ADD      r7,r7,r9              ;804
000044  42b7              CMP      r7,r6                 ;808
000046  d32f              BCC      |L24.168|
000048  68a0              LDR      r0,[r4,#8]            ;812
00004a  eba00805          SUB      r8,r0,r5              ;812
00004e  45b0              CMP      r8,r6                 ;813
000050  d908              BLS      |L24.100|
000052  6861              LDR      r1,[r4,#4]            ;822
000054  1948              ADDS     r0,r1,r5              ;822
000056  4632              MOV      r2,r6                 ;822
000058  9900              LDR      r1,[sp,#0]            ;822
00005a  f7fffffe          BL       __aeabi_memcpy
00005e  19a8              ADDS     r0,r5,r6              ;823
000060  60e0              STR      r0,[r4,#0xc]          ;823
000062  e010              B        |L24.134|
                  |L24.100|
000064  6861              LDR      r1,[r4,#4]            ;842
000066  1948              ADDS     r0,r1,r5              ;842
000068  4642              MOV      r2,r8                 ;842
00006a  9900              LDR      r1,[sp,#0]            ;842
00006c  f7fffffe          BL       __aeabi_memcpy
000070  eba60208          SUB      r2,r6,r8              ;843
000074  9b00              LDR      r3,[sp,#0]            ;843
000076  eb030108          ADD      r1,r3,r8              ;843
00007a  6860              LDR      r0,[r4,#4]            ;843
00007c  f7fffffe          BL       __aeabi_memcpy
000080  eba60008          SUB      r0,r6,r8              ;844
000084  60e0              STR      r0,[r4,#0xc]          ;844
                  |L24.134|
000086  2001              MOVS     r0,#1                 ;847
000088  e7d9              B        |L24.62|
                  |L24.138|
00008a  eba90005          SUB      r0,r9,r5              ;850
00008e  1e47              SUBS     r7,r0,#1              ;850
000090  42b7              CMP      r7,r6                 ;851
000092  d309              BCC      |L24.168|
000094  6861              LDR      r1,[r4,#4]            ;860
000096  1948              ADDS     r0,r1,r5              ;860
000098  4632              MOV      r2,r6                 ;860
00009a  9900              LDR      r1,[sp,#0]            ;860
00009c  f7fffffe          BL       __aeabi_memcpy
0000a0  19a8              ADDS     r0,r5,r6              ;861
0000a2  60e0              STR      r0,[r4,#0xc]          ;861
0000a4  2001              MOVS     r0,#1                 ;863
0000a6  e7ca              B        |L24.62|
                  |L24.168|
0000a8  2000              MOVS     r0,#0                 ;869
0000aa  e7c8              B        |L24.62|
;;;871    
                          ENDP

                  |L24.172|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteString||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WriteString PROC
;;;1002   */
;;;1003   unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1004     unsigned Len;
;;;1005   
;;;1006     Len = STRLEN(s);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       strlen
00000c  4606              MOV      r6,r0
;;;1007     return SEGGER_RTT_Write(BufferIndex, s, Len);
00000e  4632              MOV      r2,r6
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SEGGER_RTT_Write
;;;1008   }
000018  bd70              POP      {r4-r6,pc}
;;;1009   
                          ENDP


                          AREA ||i.SEGGER_RTT_WriteWithOverwriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteWithOverwriteNoLock PROC
;;;654    */
;;;655    void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;656      const char*           pData;
;;;657      SEGGER_RTT_BUFFER_UP* pRing;
;;;658      unsigned              Avail;
;;;659    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;660      char*                 pDst;
;;;661    #endif
;;;662    
;;;663      pData = (const char *)pBuffer;
00000a  46c1              MOV      r9,r8
;;;664      //
;;;665      // Get "to-host" ring buffer and copy some elements into local variables.
;;;666      //
;;;667      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  eb070147          ADD      r1,r7,r7,LSL #1
000010  4825              LDR      r0,|L26.168|
000012  eb0004c1          ADD      r4,r0,r1,LSL #3
;;;668      //
;;;669      // Check if we will overwrite data and need to adjust the RdOff.
;;;670      //
;;;671      if (pRing->WrOff == pRing->RdOff) {
000016  e9d40103          LDRD     r0,r1,[r4,#0xc]
00001a  4288              CMP      r0,r1
00001c  d102              BNE      |L26.36|
;;;672        Avail = pRing->SizeOfBuffer - 1u;
00001e  68a0              LDR      r0,[r4,#8]
000020  1e45              SUBS     r5,r0,#1
000022  e00e              B        |L26.66|
                  |L26.36|
;;;673      } else if ( pRing->WrOff < pRing->RdOff) {
000024  e9d40103          LDRD     r0,r1,[r4,#0xc]
000028  4288              CMP      r0,r1
00002a  d204              BCS      |L26.54|
;;;674        Avail = pRing->RdOff - pRing->WrOff - 1u;
00002c  6920              LDR      r0,[r4,#0x10]
00002e  68e1              LDR      r1,[r4,#0xc]
000030  1a40              SUBS     r0,r0,r1
000032  1e45              SUBS     r5,r0,#1
000034  e005              B        |L26.66|
                  |L26.54|
;;;675      } else {
;;;676        Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
000036  6920              LDR      r0,[r4,#0x10]
000038  68e1              LDR      r1,[r4,#0xc]
00003a  1a40              SUBS     r0,r0,r1
00003c  1e40              SUBS     r0,r0,#1
00003e  68a1              LDR      r1,[r4,#8]
000040  1845              ADDS     r5,r0,r1
                  |L26.66|
;;;677      }
;;;678      if (NumBytes > Avail) {
000042  42ae              CMP      r6,r5
000044  d90c              BLS      |L26.96|
;;;679        pRing->RdOff += (NumBytes - Avail);
000046  6920              LDR      r0,[r4,#0x10]
000048  1b71              SUBS     r1,r6,r5
00004a  4408              ADD      r0,r0,r1
00004c  6120              STR      r0,[r4,#0x10]
;;;680        while (pRing->RdOff >= pRing->SizeOfBuffer) {
00004e  e003              B        |L26.88|
                  |L26.80|
;;;681          pRing->RdOff -= pRing->SizeOfBuffer;
000050  6920              LDR      r0,[r4,#0x10]
000052  68a1              LDR      r1,[r4,#8]
000054  1a40              SUBS     r0,r0,r1
000056  6120              STR      r0,[r4,#0x10]
                  |L26.88|
000058  6920              LDR      r0,[r4,#0x10]         ;680
00005a  68a1              LDR      r1,[r4,#8]            ;680
00005c  4288              CMP      r0,r1                 ;680
00005e  d2f7              BCS      |L26.80|
                  |L26.96|
;;;682        }
;;;683      }
;;;684      //
;;;685      // Write all data, no need to check the RdOff, but possibly handle multiple wrap-arounds
;;;686      //
;;;687      Avail = pRing->SizeOfBuffer - pRing->WrOff;
000060  e9d40102          LDRD     r0,r1,[r4,#8]
000064  1a45              SUBS     r5,r0,r1
;;;688      do {
000066  bf00              NOP      
                  |L26.104|
;;;689        if (Avail > NumBytes) {
000068  42b5              CMP      r5,r6
00006a  d90a              BLS      |L26.130|
;;;690          //
;;;691          // Last round
;;;692          //
;;;693    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;694          pDst = pRing->pBuffer + pRing->WrOff;
;;;695          Avail = NumBytes;
;;;696          while (NumBytes--) {
;;;697            *pDst++ = *pData++;
;;;698          };
;;;699          pRing->WrOff += Avail;
;;;700    #else
;;;701          SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, NumBytes);
00006c  68e2              LDR      r2,[r4,#0xc]
00006e  6861              LDR      r1,[r4,#4]
000070  1888              ADDS     r0,r1,r2
000072  4632              MOV      r2,r6
000074  4649              MOV      r1,r9
000076  f7fffffe          BL       __aeabi_memcpy
;;;702          pRing->WrOff += NumBytes;
00007a  68e0              LDR      r0,[r4,#0xc]
00007c  4430              ADD      r0,r0,r6
00007e  60e0              STR      r0,[r4,#0xc]
;;;703    #endif
;;;704          break;
000080  e00e              B        |L26.160|
                  |L26.130|
;;;705        } else {
;;;706          //
;;;707          //  Wrap-around necessary, write until wrap-around and reset WrOff
;;;708          //
;;;709    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;710          pDst = pRing->pBuffer + pRing->WrOff;
;;;711          NumBytes -= Avail;
;;;712          while (Avail--) {
;;;713            *pDst++ = *pData++;
;;;714          };
;;;715          pRing->WrOff = 0;
;;;716    #else
;;;717          SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, Avail);
000082  68e2              LDR      r2,[r4,#0xc]
000084  6861              LDR      r1,[r4,#4]
000086  1888              ADDS     r0,r1,r2
000088  462a              MOV      r2,r5
00008a  4649              MOV      r1,r9
00008c  f7fffffe          BL       __aeabi_memcpy
;;;718          pData += Avail;
000090  44a9              ADD      r9,r9,r5
;;;719          pRing->WrOff = 0;
000092  2000              MOVS     r0,#0
000094  60e0              STR      r0,[r4,#0xc]
;;;720          NumBytes -= Avail;
000096  1b76              SUBS     r6,r6,r5
;;;721    #endif
;;;722          Avail = (pRing->SizeOfBuffer - 1);
000098  68a0              LDR      r0,[r4,#8]
00009a  1e45              SUBS     r5,r0,#1
;;;723        }
;;;724      } while (NumBytes);
00009c  2e00              CMP      r6,#0
00009e  d1e3              BNE      |L26.104|
                  |L26.160|
0000a0  bf00              NOP                            ;704
;;;725    }
0000a2  e8bd87f0          POP      {r4-r10,pc}
;;;726    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L26.168|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i._DoInit||, CODE, READONLY, ALIGN=2

                  _DoInit PROC
;;;279                    } while (0)
;;;280    static void _DoInit(void) {
000000  b510              PUSH     {r4,lr}
;;;281      SEGGER_RTT_CB* p;
;;;282      //
;;;283      // Initialize control block
;;;284      //
;;;285      p = &_SEGGER_RTT;
000002  4c12              LDR      r4,|L27.76|
;;;286      p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
000004  2003              MOVS     r0,#3
000006  6120              STR      r0,[r4,#0x10]
;;;287      p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
000008  6160              STR      r0,[r4,#0x14]
;;;288      //
;;;289      // Initialize up buffer 0
;;;290      //
;;;291      p->aUp[0].sName         = "Terminal";
00000a  a011              ADR      r0,|L27.80|
00000c  61a0              STR      r0,[r4,#0x18]
;;;292      p->aUp[0].pBuffer       = _acUpBuffer;
00000e  4913              LDR      r1,|L27.92|
000010  61e1              STR      r1,[r4,#0x1c]
;;;293      p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
000012  f44f6180          MOV      r1,#0x400
000016  6221              STR      r1,[r4,#0x20]
;;;294      p->aUp[0].RdOff         = 0u;
000018  2100              MOVS     r1,#0
00001a  62a1              STR      r1,[r4,#0x28]
;;;295      p->aUp[0].WrOff         = 0u;
00001c  6261              STR      r1,[r4,#0x24]
;;;296      p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
00001e  62e1              STR      r1,[r4,#0x2c]
;;;297      //
;;;298      // Initialize down buffer 0
;;;299      //
;;;300      p->aDown[0].sName         = "Terminal";
000020  a00b              ADR      r0,|L27.80|
000022  6620              STR      r0,[r4,#0x60]
;;;301      p->aDown[0].pBuffer       = _acDownBuffer;
000024  490e              LDR      r1,|L27.96|
000026  6661              STR      r1,[r4,#0x64]
;;;302      p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
000028  2110              MOVS     r1,#0x10
00002a  66a1              STR      r1,[r4,#0x68]
;;;303      p->aDown[0].RdOff         = 0u;
00002c  2100              MOVS     r1,#0
00002e  6721              STR      r1,[r4,#0x70]
;;;304      p->aDown[0].WrOff         = 0u;
000030  66e1              STR      r1,[r4,#0x6c]
;;;305      p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
000032  6761              STR      r1,[r4,#0x74]
;;;306      //
;;;307      // Finish initialization of the control block.
;;;308      // Copy Id string in three steps to make sure "SEGGER RTT" is not found
;;;309      // in initializer memory (usually flash) by J-Link
;;;310      //
;;;311      strcpy(&p->acID[7], "RTT");
000034  a10b              ADR      r1,|L27.100|
000036  1de0              ADDS     r0,r4,#7
000038  f7fffffe          BL       strcpy
;;;312      strcpy(&p->acID[0], "SEGGER");
00003c  a10a              ADR      r1,|L27.104|
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       strcpy
;;;313      p->acID[6] = ' ';
000044  2020              MOVS     r0,#0x20
000046  71a0              STRB     r0,[r4,#6]
;;;314    }
000048  bd10              POP      {r4,pc}
;;;315    
                          ENDP

00004a  0000              DCW      0x0000
                  |L27.76|
                          DCD      _SEGGER_RTT
                  |L27.80|
000050  5465726d          DCB      "Terminal",0
000054  696e616c
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L27.92|
                          DCD      _acUpBuffer
                  |L27.96|
                          DCD      _acDownBuffer
                  |L27.100|
000064  52545400          DCB      "RTT",0
                  |L27.104|
000068  53454747          DCB      "SEGGER",0
00006c  455200  
00006f  00                DCB      0

                          AREA ||i._GetAvailWriteSpace||, CODE, READONLY, ALIGN=1

                  _GetAvailWriteSpace PROC
;;;484    */
;;;485    static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;486      unsigned RdOff;
;;;487      unsigned WrOff;
;;;488      unsigned r;
;;;489      //
;;;490      // Avoid warnings regarding volatile access order.  It's not a problem
;;;491      // in this case, but dampen compiler enthusiasm.
;;;492      //
;;;493      RdOff = pRing->RdOff;
000004  690a              LDR      r2,[r1,#0x10]
;;;494      WrOff = pRing->WrOff;
000006  68cb              LDR      r3,[r1,#0xc]
;;;495      if (RdOff <= WrOff) {
000008  429a              CMP      r2,r3
00000a  d804              BHI      |L28.22|
;;;496        r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
00000c  688c              LDR      r4,[r1,#8]
00000e  1e64              SUBS     r4,r4,#1
000010  1ae4              SUBS     r4,r4,r3
000012  18a0              ADDS     r0,r4,r2
000014  e001              B        |L28.26|
                  |L28.22|
;;;497      } else {
;;;498        r = RdOff - WrOff - 1u;
000016  1ad4              SUBS     r4,r2,r3
000018  1e60              SUBS     r0,r4,#1
                  |L28.26|
;;;499      }
;;;500      return r;
;;;501    }
00001a  bd10              POP      {r4,pc}
;;;502    
                          ENDP


                          AREA ||i._PostTerminalSwitch||, CODE, READONLY, ALIGN=2

                  _PostTerminalSwitch PROC
;;;462    */
;;;463    static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
000000  b538              PUSH     {r3-r5,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;464      unsigned char ac[2];
;;;465    
;;;466      ac[0] = 0xFFu;
000006  20ff              MOVS     r0,#0xff
000008  f88d0000          STRB     r0,[sp,#0]
;;;467      ac[1] = _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
00000c  4804              LDR      r0,|L29.32|
00000e  5d00              LDRB     r0,[r0,r4]
000010  f88d0001          STRB     r0,[sp,#1]
;;;468      _WriteBlocking(pRing, (const char*)ac, 2u);
000014  2202              MOVS     r2,#2
000016  4669              MOV      r1,sp
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       _WriteBlocking
;;;469    }
00001e  bd38              POP      {r3-r5,pc}
;;;470    
                          ENDP

                  |L29.32|
                          DCD      _aTerminalId

                          AREA ||i._WriteBlocking||, CODE, READONLY, ALIGN=1

                  _WriteBlocking PROC
;;;334    */
;;;335    static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;336      unsigned NumBytesToWrite;
;;;337      unsigned NumBytesWritten;
;;;338      unsigned RdOff;
;;;339      unsigned WrOff;
;;;340    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;341      char*    pDst;
;;;342    #endif
;;;343      //
;;;344      // Write data to buffer and handle wrap-around if necessary
;;;345      //
;;;346      NumBytesWritten = 0u;
00000a  f04f0a00          MOV      r10,#0
;;;347      WrOff = pRing->WrOff;
00000e  68e5              LDR      r5,[r4,#0xc]
;;;348      do {
000010  bf00              NOP      
                  |L30.18|
;;;349        RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
000012  f8d48010          LDR      r8,[r4,#0x10]
;;;350        if (RdOff > WrOff) {
000016  45a8              CMP      r8,r5
000018  d903              BLS      |L30.34|
;;;351          NumBytesToWrite = RdOff - WrOff - 1u;
00001a  eba80005          SUB      r0,r8,r5
00001e  1e46              SUBS     r6,r0,#1
000020  e004              B        |L30.44|
                  |L30.34|
;;;352        } else {
;;;353          NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
000022  eba50008          SUB      r0,r5,r8
000026  1c40              ADDS     r0,r0,#1
000028  68a1              LDR      r1,[r4,#8]
00002a  1a0e              SUBS     r6,r1,r0
                  |L30.44|
;;;354        }
;;;355        NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
00002c  68a0              LDR      r0,[r4,#8]
00002e  1b40              SUBS     r0,r0,r5
000030  42b0              CMP      r0,r6
000032  d901              BLS      |L30.56|
000034  4630              MOV      r0,r6
000036  e001              B        |L30.60|
                  |L30.56|
000038  68a0              LDR      r0,[r4,#8]
00003a  1b40              SUBS     r0,r0,r5
                  |L30.60|
00003c  4606              MOV      r6,r0
;;;356        NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
00003e  42be              CMP      r6,r7
000040  d201              BCS      |L30.70|
000042  4630              MOV      r0,r6
000044  e000              B        |L30.72|
                  |L30.70|
000046  4638              MOV      r0,r7
                  |L30.72|
000048  4606              MOV      r6,r0
;;;357    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;358        pDst = pRing->pBuffer + WrOff;
;;;359        NumBytesWritten += NumBytesToWrite;
;;;360        NumBytes        -= NumBytesToWrite;
;;;361        WrOff           += NumBytesToWrite;
;;;362        while (NumBytesToWrite--) {
;;;363          *pDst++ = *pBuffer++;
;;;364        };
;;;365    #else
;;;366        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
00004a  6861              LDR      r1,[r4,#4]
00004c  1948              ADDS     r0,r1,r5
00004e  4632              MOV      r2,r6
000050  4649              MOV      r1,r9
000052  f7fffffe          BL       __aeabi_memcpy
;;;367        NumBytesWritten += NumBytesToWrite;
000056  44b2              ADD      r10,r10,r6
;;;368        pBuffer         += NumBytesToWrite;
000058  44b1              ADD      r9,r9,r6
;;;369        NumBytes        -= NumBytesToWrite;
00005a  1bbf              SUBS     r7,r7,r6
;;;370        WrOff           += NumBytesToWrite;
00005c  4435              ADD      r5,r5,r6
;;;371    #endif
;;;372        if (WrOff == pRing->SizeOfBuffer) {
00005e  68a0              LDR      r0,[r4,#8]
000060  42a8              CMP      r0,r5
000062  d100              BNE      |L30.102|
;;;373          WrOff = 0u;
000064  2500              MOVS     r5,#0
                  |L30.102|
;;;374        }
;;;375        pRing->WrOff = WrOff;
000066  60e5              STR      r5,[r4,#0xc]
;;;376      } while (NumBytes);
000068  2f00              CMP      r7,#0
00006a  d1d2              BNE      |L30.18|
;;;377      //
;;;378      return NumBytesWritten;
00006c  4650              MOV      r0,r10
;;;379    }
00006e  e8bd87f0          POP      {r4-r10,pc}
;;;380    
                          ENDP


                          AREA ||i._WriteNoCheck||, CODE, READONLY, ALIGN=1

                  _WriteNoCheck PROC
;;;398    */
;;;399    static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;400      unsigned NumBytesAtOnce;
;;;401      unsigned WrOff;
;;;402      unsigned Rem;
;;;403    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;404      char*    pDst;
;;;405    #endif
;;;406    
;;;407      WrOff = pRing->WrOff;
00000a  68e6              LDR      r6,[r4,#0xc]
;;;408      Rem = pRing->SizeOfBuffer - WrOff;
00000c  68a0              LDR      r0,[r4,#8]
00000e  1b87              SUBS     r7,r0,r6
;;;409      if (Rem > NumBytes) {
000010  42af              CMP      r7,r5
000012  d908              BLS      |L31.38|
;;;410        //
;;;411        // All data fits before wrap around
;;;412        //
;;;413    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;414        pDst = pRing->pBuffer + WrOff;
;;;415        WrOff += NumBytes;
;;;416        while (NumBytes--) {
;;;417          *pDst++ = *pData++;
;;;418        };
;;;419        pRing->WrOff = WrOff;
;;;420    #else
;;;421        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
000014  6861              LDR      r1,[r4,#4]
000016  1988              ADDS     r0,r1,r6
000018  462a              MOV      r2,r5
00001a  4649              MOV      r1,r9
00001c  f7fffffe          BL       __aeabi_memcpy
;;;422        pRing->WrOff = WrOff + NumBytes;
000020  1970              ADDS     r0,r6,r5
000022  60e0              STR      r0,[r4,#0xc]
000024  e010              B        |L31.72|
                  |L31.38|
;;;423    #endif
;;;424      } else {
;;;425        //
;;;426        // We reach the end of the buffer, so need to wrap around
;;;427        //
;;;428    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;429        pDst = pRing->pBuffer + WrOff;
;;;430        NumBytesAtOnce = Rem;
;;;431        while (NumBytesAtOnce--) {
;;;432          *pDst++ = *pData++;
;;;433        };
;;;434        pDst = pRing->pBuffer;
;;;435        NumBytesAtOnce = NumBytes - Rem;
;;;436        while (NumBytesAtOnce--) {
;;;437          *pDst++ = *pData++;
;;;438        };
;;;439        pRing->WrOff = NumBytes - Rem;
;;;440    #else
;;;441        NumBytesAtOnce = Rem;
000026  46b8              MOV      r8,r7
;;;442        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
000028  6861              LDR      r1,[r4,#4]
00002a  1988              ADDS     r0,r1,r6
00002c  4642              MOV      r2,r8
00002e  4649              MOV      r1,r9
000030  f7fffffe          BL       __aeabi_memcpy
;;;443        NumBytesAtOnce = NumBytes - Rem;
000034  eba50807          SUB      r8,r5,r7
;;;444        SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
000038  eb090107          ADD      r1,r9,r7
00003c  4642              MOV      r2,r8
00003e  6860              LDR      r0,[r4,#4]
000040  f7fffffe          BL       __aeabi_memcpy
;;;445        pRing->WrOff = NumBytesAtOnce;
000044  f8c4800c          STR      r8,[r4,#0xc]
                  |L31.72|
;;;446    #endif
;;;447      }
;;;448    }
000048  e8bd87f0          POP      {r4-r10,pc}
;;;449    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _SEGGER_RTT
                          %        168
                  _acUpBuffer
                          %        1024
                  _acDownBuffer
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  _aTerminalId
000000  30313233          DCB      0x30,0x31,0x32,0x33
000004  34353637          DCB      0x34,0x35,0x36,0x37
000008  38394142          DCB      0x38,0x39,0x41,0x42
00000c  43444546          DCB      0x43,0x44,0x45,0x46
                  _ActiveTerminal
000010  00                DCB      0x00
