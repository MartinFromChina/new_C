L 1 "..\..\..\module\component\const_loop_scheduler\TemplateTask\template_task.c"
N#include "template_task.h"
L 1 "..\..\..\module\component\const_loop_scheduler\TemplateTask\template_task.h" 1
N/****************************************************************************************************
Nthe T_task_marco use line number as state flag to implement state-jump. if you want to be more efficient, use ProtoThread
Nin the task body:
Nthere must be a T_marco at the beginning of each code line 
Nonly one T_marco in the same code line
N********************************************************************************************************/
N
N#ifndef __TEMPLATE_TASK_H
N#define __TEMPLATE_TASK_H
N
N#ifdef __cplusplus
S	extern "C" {
N#else 
N    #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
X    #if 1L && 199901L >= 199901L
N 
N    #else
S    #warning [caution !!! not support C99 ]
N    #endif
N#endif
N
N#include "../x_task_common.h"
L 1 "..\..\..\module\component\const_loop_scheduler\TemplateTask\../x_task_common.h" 1
N#ifndef __X_TASK_COMMON_H
N#define __X_TASK_COMMON_H
N
N#ifdef __cplusplus
S	extern "C" {
S
N#else 
N    #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
X    #if 1L && 199901L >= 199901L
N 
N    #else
S    #warning [caution !!! not support C99 ]
N    #endif
N#endif
N
N#include "../../common/x_cross_platform.h"
L 1 "..\..\..\module\component\const_loop_scheduler\TemplateTask\../../../common/x_cross_platform.h" 1
N#ifndef __X_CROSS_PLATFORM_H
N#define __X_CROSS_PLATFORM_H
N
N#include <stdint.h>
L 1 "D:\Program Files\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 5 "..\..\..\module\component\const_loop_scheduler\TemplateTask\../../../common/x_cross_platform.h" 2
N#include <wchar.h>
L 1 "D:\Program Files\ARM\ARMCC\Bin\..\include\wchar.h" 1
N/* wchar.h: C99 header */
N/* Copyright 2002 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __wchar_h
N#define __wchar_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __WCHAR_DECLS
N  #define __WCHAR_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        #define __CLIBNS ::std::
S        namespace std {
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N    #if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X    #if 0L || !0L || !0L
N     /* always defined in C++ and non-strict C for consistency of debug info */
N      #if __sizeof_ptr == 8
X      #if 4 == 8
S        typedef unsigned long size_t;   /* see <stddef.h> */
N      #else
N        typedef unsigned int size_t;   /* see <stddef.h> */
N      #endif
N      #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X      #if !0L && 0L
S        #define __size_t 1
N      #endif
N    #endif
N
N    #ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N      #if !defined(__STRICT_ANSI__) || !defined(__wchar_t)
X      #if !0L || !0L
N       /* always defined in non-strict C for consistency of debug info */
N        #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X        #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S          typedef unsigned int wchar_t; /* see <stddef.h> */
N        #else
N          typedef unsigned short wchar_t; /* see <stddef.h> */
N        #endif
N        #ifdef __STRICT_ANSI__
S          #define __wchar_t 1
N        #endif
N      #endif
N    #endif
N
N    #if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__wint_t)
X    #if 0L || !0L || !0L
N     /* always defined in C++ and non-strict C for consistency of debug info */
N      typedef int wint_t;   /* see also <wctype.h> */
N      #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X      #if !0L && 0L
S        #define __wint_t 1
N      #endif
N    #endif
N
N        /* limits of wchar_t */
N        /* NB we have to undef and redef because they're defined in both
N         * stdint.h and wchar.h */
N    #undef WCHAR_MIN
N    #undef WCHAR_MAX
N
N    #if defined(__WCHAR32)  || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L  || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      #define WCHAR_MIN   0
S      #define WCHAR_MAX   0xffffffffU
N    #else
N      #define WCHAR_MIN   0
N      #define WCHAR_MAX   65535
N    #endif
N
N    #undef NULL
N    #define NULL 0                   /* see <stddef.h> */
N
N    /* ANSI forbids va_list to be defined here */
N    /* keep in step with <stdarg.h> and <stdio.h> */
N    #if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X    #if !0L && (0L || !0L || !0L)
N    /* always defined in C++ and non-strict C for consistency of debug info */
N      #ifdef __clang__
S        typedef __builtin_va_list __va_list;
N      #else
N        typedef struct __va_list __va_list;
N      #endif
N      #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X      #if !0L && 0L
S        #define __va_list_defined 1
N      #endif
N    #endif
N
N  #ifndef __ARM_WCHAR_NO_IO
N    #undef WEOF
N    #define WEOF ((__CLIBNS wint_t)-1)
N
N    /* ANSI forbids FILE to be defined here */
N    #if !defined(__STRICT_ANSI__)
X    #if !0L
N    /* always defined in non-strict C/C++ for consistency of debug info */
N      typedef struct __FILE FILE;
N    #else
S      struct __FILE;
N    #endif
N  #endif /* __ARM_WCHAR_NO_IO */
N
N    /*
N     * If the compiler supports signalling nans as per N965 then it
N     * will define __SUPPORT_SNAN__, in which case a user may define
N     * _WANT_SNAN in order to obtain compliant versions of the
N     * fwprintf, fwscanf, and wcstod families of functions.
N     */
N    #if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X    #if 0L && 0L
S    #pragma import(__use_snan)
N    #endif
N
N
N    /*
N     * mbstate_t must be able to contain all the data from an
N     * incomplete MB character, plus shift states. CJK-specific
N     * encodings seem to tend to have at most three bytes per
N     * character, and a single-figure number of shift states, so 32
N     * bits is sufficient for any of these. UTF-8 encoding a full
N     * 32-bit value is the hardest thing to deal with, and in that
N     * situation the worst case is having to store 25 bits of
N     * character (1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx) plus
N     * a few bits saying what sort of state is being stored. This is
N     * still easy enough to fit into 32 bits, so I think a single
N     * 32-bit integer is enough in here.
N     */
N    typedef struct __mbstate_t {
N        unsigned int __state, __state2;
N    } mbstate_t;
N
N    /*
N     * `struct tm' must be declared in this header as an incomplete
N     * type.
N     */
N    struct tm;
N            
N    extern _ARMABI size_t wcsftime(wchar_t * __restrict /*s*/, size_t /*maxsize*/,
X    extern __declspec(__nothrow) size_t wcsftime(wchar_t * __restrict  , size_t  ,
N                       const wchar_t * __restrict /*format*/, const struct tm * __restrict /*timeptr*/) __attribute__((__nonnull__(1,3,4)));
N
N  #ifndef __ARM_WCHAR_NO_IO
N    /*
N     * Formatted wide-character I/O functions
N     */
N#pragma __printf_args
N    int swprintf(wchar_t * __restrict /*s*/, size_t /*n*/,
N                 const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N#pragma __printf_args
N    int vswprintf(wchar_t * __restrict /*s*/, size_t /*n*/,
N                  const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#pragma __scanf_args
N    int swscanf(const wchar_t * __restrict /*s*/,
N                const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N#pragma __scanf_args
N    int vswscanf(const wchar_t * __restrict /*s*/,
N                 const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N
N
N#pragma __printf_args
N    int fwprintf(struct __FILE * __restrict /*stream*/,
N                 const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N#pragma __printf_args
N    int vfwprintf(struct __FILE * __restrict /*stream*/,
N                  const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N#pragma __scanf_args
N    int fwscanf(struct __FILE * __restrict /*stream*/,
N                const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N#pragma __scanf_args
N    int vfwscanf(struct __FILE * __restrict /*stream*/,
N                 const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N
N
N#pragma __printf_args
N    int wprintf(const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
N#pragma __printf_args
N    int vwprintf(const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
N#pragma __scanf_args
N    int wscanf(const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
N#pragma __scanf_args
N    int vwscanf(const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
N
N    /* 
N     * Unformatted wide-character I/O functions
N     */
N    wint_t fgetwc(struct __FILE * /*stream*/) __attribute__((__nonnull__(1)));
N    wchar_t *fgetws(wchar_t * __restrict /*s*/, int /*n*/, struct __FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N    wint_t fputwc(wchar_t /*c*/, struct __FILE * /*stream*/) __attribute__((__nonnull__(2)));
N    int fputws(const wchar_t * __restrict /*s*/, struct __FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
N    int fwide(struct __FILE * /*stream*/, int /*mode*/) __attribute__((__nonnull__(1)));
N    wint_t getwc(struct __FILE * /*stream*/) __attribute__((__nonnull__(1)));
N    wint_t getwchar(void);
N    wint_t putwc(wchar_t /*c*/, struct __FILE * /*stream*/) __attribute__((__nonnull__(2)));
N    wint_t putwchar(wchar_t /*c*/);
N    wint_t ungetwc(wint_t /*c*/, struct __FILE * /*stream*/) __attribute__((__nonnull__(2)));
N  #endif /* __ARM_WCHAR_NO_IO */
N
N    wint_t btowc(int /*c*/);
N    wint_t wctob(int /*c*/);
N    int mbsinit(const mbstate_t * /*ps*/);
N    size_t mbrlen(const char * __restrict /*s*/, size_t /*n*/,
N                  mbstate_t * __restrict /*ps*/);
N    size_t mbrtowc(wchar_t * __restrict /*pwc*/,
N                   const char * __restrict /*s*/,
N                   size_t /*n*/, mbstate_t * __restrict /*ps*/);
N    size_t wcrtomb(char * __restrict /*s*/, wchar_t /*wc*/,
N                   mbstate_t * __restrict /*ps*/);
N    size_t mbsrtowcs(wchar_t * __restrict /*dst*/,
N                     const char ** __restrict /*src*/,
N                     size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N    size_t wcsrtombs(char * __restrict /*dst*/,
N                     const wchar_t ** __restrict /*src*/,
N                     size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N    size_t _mbsnrtowcs(wchar_t * __restrict /*dst*/,
N                       const char ** __restrict /*src*/,
N                       size_t /*nmb*/,
N                       size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N    size_t _wcsnrtombs(char * __restrict /*dst*/,
N                       const wchar_t ** __restrict /*src*/,
N                       size_t /*nwc*/,
N                       size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N#if !defined(__STRICT_ANSI__)
X#if !0L
N    size_t mbsnrtowcs(wchar_t * __restrict /*dst*/,
N                      const char ** __restrict /*src*/,
N                      size_t /*nmb*/,
N                      size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N    size_t wcsnrtombs(char * __restrict /*dst*/,
N                      const wchar_t ** __restrict /*src*/,
N                      size_t /*nwc*/,
N                      size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N#endif
N
N    /*
N     * Wide-character string-to-number conversions. Parallel to strto*.
N     */
N    double wcstod(const wchar_t * /*nptr*/, wchar_t ** /*endptr*/) __attribute__((__nonnull__(1)));
N    float wcstof(const wchar_t * /*nptr*/, wchar_t ** /*endptr*/) __attribute__((__nonnull__(1)));
N    long double wcstold(const wchar_t * /*nptr*/, wchar_t ** /*endptr*/) __attribute__((__nonnull__(1)));
N    long int wcstol(const wchar_t * /*nptr*/, wchar_t **/*endptr*/,
N                    int /*base*/) __attribute__((__nonnull__(1)));
N    unsigned long int wcstoul(const wchar_t * /*nptr*/,
N                              wchar_t ** /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N    long long int wcstoll(const wchar_t * __restrict /*nptr*/,
N                          wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    unsigned long long int wcstoull(const wchar_t * __restrict /*nptr*/,
N                                    wchar_t ** __restrict /*endptr*/,
N                                    int /*base*/) __attribute__((__nonnull__(1)));
N#endif
N
N    /*
N     * General wide-character string utilities.
N     */
N    wchar_t *wcscpy(wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcsncpy(wchar_t * __restrict /*s1*/,
N                     const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wmemcpy(wchar_t * __restrict /*s1*/,
N                     const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wmemmove(wchar_t * __restrict /*s1*/,
N                      const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcscat(wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcsncat(wchar_t * __restrict /*s1*/,
N                     const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    int wcscmp(const wchar_t * __restrict /*s1*/,
N               const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    int wcsncmp(const wchar_t * __restrict /*s1*/,
N                const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    int wcscasecmp(const wchar_t * __restrict /*s1*/,
N                   const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    int wcsncasecmp(const wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    int wcscoll(const wchar_t * __restrict /*s1*/,
N                const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    size_t wcsxfrm(wchar_t * __restrict /*s1*/,
N                   const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N    int wmemcmp(const wchar_t * __restrict /*s1*/,
N                const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    size_t wcscspn(const wchar_t * __restrict /*s1*/,
N                   const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    size_t wcsspn(const wchar_t * __restrict /*s1*/,
N                  const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcstok(wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/,
N                    wchar_t ** __restrict /*ptr*/) __attribute__((__nonnull__(2,3)));
N    size_t wcslen(const wchar_t * __restrict /*s*/) __attribute__((__nonnull__(1)));
N    wchar_t *wmemset(wchar_t * __restrict /*s*/, wchar_t /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 0L && !0L
S    /*
S     * C++'s overloading allows us to provide versions of these
S     * functions which search a const string and return a const
S     * pointer into it, and separate versions which search a
S     * non-const string and return a non-const pointer.
S     */
S    const wchar_t *wcschr(const wchar_t * __restrict /*s*/, wchar_t /*c*/) __attribute__((__nonnull__(1)));
S    const wchar_t *wcspbrk(const wchar_t * __restrict /*s1*/,
S                           const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
S    const wchar_t *wcsrchr(const wchar_t * __restrict /*s*/, wchar_t /*c*/) __attribute__((__nonnull__(1)));
S    const wchar_t *wcsstr(const wchar_t * __restrict /*s1*/,
S                          const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
S    const wchar_t *wmemchr(const wchar_t * __restrict /*s*/, wchar_t /*c*/,
S                           size_t /*n*/) __attribute__((__nonnull__(1)));
S#ifndef __WCHAR_DISABLED
S    extern "C++" wchar_t *wcschr(wchar_t * __restrict __s, wchar_t __c) __attribute__((__nonnull__(1)));
S    extern "C++" inline wchar_t *wcschr(wchar_t * __restrict __s, wchar_t __c)
S      { return const_cast<wchar_t *>(wcschr(const_cast<const wchar_t *>(__s), __c)); }
S    extern "C++" wchar_t *wcspbrk(wchar_t * __restrict __s1, const wchar_t * __restrict __s2) __attribute__((__nonnull__(1,2)));
S    extern "C++" inline wchar_t *wcspbrk(wchar_t * __restrict __s1, const wchar_t * __restrict __s2)
S      { return const_cast<wchar_t *>(wcspbrk(const_cast<const wchar_t *>(__s1), __s2)); }
S    extern "C++" wchar_t *wcsrchr(wchar_t * __restrict __s, wchar_t __c) __attribute__((__nonnull__(1)));
S    extern "C++" inline wchar_t *wcsrchr(wchar_t * __restrict __s, wchar_t __c)
S      { return const_cast<wchar_t *>(wcsrchr(const_cast<const wchar_t *>(__s), __c)); }
S    extern "C++" wchar_t *wcsstr(wchar_t * __restrict __s1,
S                          const wchar_t * __restrict __s2) __attribute__((__nonnull__(1,2)));
S    extern "C++" inline wchar_t *wcsstr(wchar_t * __restrict __s1,
S                          const wchar_t * __restrict __s2)
S      { return const_cast<wchar_t *>(wcsstr(const_cast<const wchar_t *>(__s1), __s2)); }
S    extern "C++" wchar_t *wmemchr(wchar_t * __restrict __s, wchar_t __c,
S                                  size_t __n) __attribute__((__nonnull__(1)));
S    extern "C++" inline wchar_t *wmemchr(wchar_t * __restrict __s, wchar_t __c,
S                                  size_t __n)
S    { return const_cast<wchar_t *>(wmemchr(const_cast<const wchar_t *>(__s), __c, __n)); }
S#endif
N#else
N    /*
N     * C's approximation to the above is to have all of these
N     * functions search a const string and return a non-const
N     * pointer. This is the only way to prevent compile errors in
N     * all sensible uses of the functions, but unfortunately
N     * renders them unable to spot a lot of the possible error
N     * cases.
N     */
N#if defined(__cplusplus) && defined(__ARMCOMPILER_LIBCXX)
X#if 0L && 0L
S  }  /* extern "C" */
S  }  /* namespace std */
S  extern "C" {
N#endif
N    wchar_t *wcschr(const wchar_t * __restrict /*s*/, wchar_t /*c*/) __attribute__((__nonnull__(1)));
N    wchar_t *wcspbrk(const wchar_t * __restrict /*s1*/,
N                     const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcsrchr(const wchar_t * __restrict /*s*/, wchar_t /*c*/) __attribute__((__nonnull__(1)));
N    wchar_t *wcsstr(const wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wmemchr(const wchar_t * __restrict /*s*/, wchar_t /*c*/,
N                     __CLIBNS size_t /*n*/) __attribute__((__nonnull__(1)));
X                      size_t  ) __attribute__((__nonnull__(1)));
N#if defined(__cplusplus) && defined(__ARMCOMPILER_LIBCXX)
X#if 0L && 0L
S  }  /* extern "C" */
S  namespace std {
S  extern "C" {
N#endif
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __WCHAR_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __WCHAR_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::wint_t;
S      using ::std::mbstate_t;
S      using ::std::tm;
S      using ::std::wcsftime;
S    #ifndef __ARM_WCHAR_NO_IO
S      using ::std::swprintf;
S      using ::std::vswprintf;
S      using ::std::swscanf;
S      using ::std::vswscanf;
S      using ::std::fwprintf;
S      using ::std::vfwprintf;
S      using ::std::fwscanf;
S      using ::std::vfwscanf;
S      using ::std::wprintf;
S      using ::std::vwprintf;
S      using ::std::wscanf;
S      using ::std::vwscanf;
S      using ::std::fgetwc;
S      using ::std::fgetws;
S      using ::std::fputwc;
S      using ::std::fputws;
S      using ::std::fwide;
S      using ::std::getwc;
S      using ::std::getwchar;
S      using ::std::putwc;
S      using ::std::putwchar;
S      using ::std::ungetwc;
S      using ::std::btowc;
S    #endif /* __ARM_WCHAR_NO_IO */
S      using ::std::wctob;
S      using ::std::mbsinit;
S      using ::std::mbrlen;
S      using ::std::mbrtowc;
S      using ::std::wcrtomb;
S      using ::std::mbsrtowcs;
S      using ::std::wcsrtombs;
S      using ::std::_mbsnrtowcs;
S      using ::std::_wcsnrtombs;
S#if !defined(__STRICT_ANSI__)
S      using ::std::mbsnrtowcs;
S      using ::std::wcsnrtombs;
S#endif
S      using ::std::wcstod;
S      using ::std::wcstof;
S      using ::std::wcstold;
S      using ::std::wcstol;
S      using ::std::wcstoul;
S#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::wcstoll;
S      using ::std::wcstoull;
S#endif /* !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus) */
S      using ::std::wcscpy;
S      using ::std::wcsncpy;
S      using ::std::wmemcpy;
S      using ::std::wmemmove;
S      using ::std::wcscat;
S      using ::std::wcsncat;
S      using ::std::wcscmp;
S      using ::std::wcsncmp;
S      using ::std::wcscasecmp;
S      using ::std::wcsncasecmp;
S      using ::std::wcscoll;
S      using ::std::wcsxfrm;
S      using ::std::wmemcmp;
S#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
S      using ::std::wcschr;
S      using ::std::wcspbrk;
S      using ::std::wcsrchr;
S      using ::std::wcsstr;
S      using ::std::wmemchr;
S#endif /* defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX) */
S      using ::std::wcscspn;
S      using ::std::wcsspn;
S      using ::std::wcstok;
S      using ::std::wcslen;
S      using ::std::wmemset;
S#if !defined(__STRICT_ANSI__) && !defined(__ARM_WCHAR_NO_IO)
S      using ::std::FILE;
S#endif
S    #endif /* __WCHAR_NO_EXPORTS */
N  #endif /* __cplusplus */
N#endif /* ndef __wchar_h */
N
N/* end of wchar.h */
N
L 6 "..\..\..\module\component\const_loop_scheduler\TemplateTask\../../../common/x_cross_platform.h" 2
N
N#define X_Void      void
Ntypedef int8_t      X_Int8;
Ntypedef uint8_t     X_UInt8;
Ntypedef int16_t     X_Int16;
Ntypedef uint16_t    X_UInt16;
Ntypedef int32_t     X_Int32;
Ntypedef uint32_t    X_UInt32;
Ntypedef int64_t     X_Int64;
Ntypedef uint64_t    X_UInt64;
Ntypedef float       X_Float32;
Ntypedef double      X_Float64;
Ntypedef char        X_Char;
Ntypedef wchar_t     X_WChar;
N
Ntypedef unsigned int    X_UInt;
Ntypedef int             X_Int;
Ntypedef X_Int64         X_IntLongest;
Ntypedef X_UInt64        X_UIntLongest;
N
N#define X_Null              ((X_Void*)0)
N
Ntypedef int                 X_Boolean;
N#define X_True              (0 == 0)
N#define X_False             (0 != 0)
N
N#define MapperAssertion     ((sizeof(X_Int8) == 1) && (sizeof(X_UInt8) == 1) && (sizeof(X_Int16) == 2) && (sizeof(X_UInt16) == 2) && (sizeof(X_Int32) == 4) && (sizeof(X_UInt32) == 4) && (sizeof(X_Float32) == 4) && (sizeof(X_Float64) == 8))
N
N#ifndef __FUNCTION__
N    #define __FUNCTION__  "not support "
N#endif
N
N#ifndef __func__  
N    #define __func__    "not support "
N#endif
N
N/*
N这两个宏都可以用于获取当前函数名称，但它们在使用方式和适用范围上有所不同。 
N 
N __FUNCTION__  宏会在编译时被替换为当前函数的名称字符串，可以在任何函数中使用，包括全局作用域。但是它不是标准宏，不被所有编译器都支持。 
N 
N __func__  宏是C99标准的一部分，支持更广泛，并且也会在编译时被替换为当前函数的名称字符串。它只能在函数内使用，因此对于全局作用域或类作用域中的函数， __FUNCTION__  可能是更好的选择。 
N 
N因此，如果你的编译器支持  __FUNCTION__ ，并且你不需要跨编译器移植代码，则  __FUNCTION__  可以是更通用的选择。如果需要与不同类型的编译器和标准兼容，则应使用  __func__ 。
N*/
N
N#endif
L 16 "..\..\..\module\component\const_loop_scheduler\TemplateTask\../x_task_common.h" 2
N#include "../../common/CommonMarco.h"
L 1 "..\..\..\module\component\const_loop_scheduler\TemplateTask\../../../common/CommonMarco.h" 1
N#ifndef __COMMONMARCO_H
N#define __COMMONMARCO_H
N
N#define CONCAT_2(p1, p2)      CONCAT_2_(p1, p2)
N/** Auxiliary macro used by @ref CONCAT_2 */
N#define CONCAT_2_(p1, p2)     p1##p2
N
N#define CONCAT_3_(__A, __B, __C)    __A##__B##__C
N#define CONCAT_3(__A, __B, __C)      CONCAT_3_(__A, __B, __C)
N
N#define UNUSED_VARIABLE(X)  ((void)(X))
N#define UNUSED_PARAMETER(X) UNUSED_VARIABLE(X)
N#define UNUSED_RETURN_VALUE(X) UNUSED_VARIABLE(X)
N#endif
L 17 "..\..\..\module\component\const_loop_scheduler\TemplateTask\../x_task_common.h" 2
N
N/**********************************************************************************************************************/
N#define BOOL_BLOCK               X_True
N#define BOOL_NO_BLOCK            X_False  
N#define MAX_X_TASK_NUMBER      (0xffff)
N/**********************************************************************************************************************/
N#ifndef X_TASK_LOG_DEBUG_METHOD
S    #include <stdio.h>
S    #define  X_TASK_LOG_DEBUG_METHOD printf
N#endif
N
N#ifndef X_TASK_LOG_DEBUG
N    #define  X_TASK_LOG_DEBUG 1
N#endif
N
N#ifndef USE_X_TASK_LOG
N    #define  USE_X_TASK_LOG 1
N#endif
N
N#if (USE_X_TASK_LOG != 0)
X#if (1 != 0)
N    #define X_TASK_LOG(flag,message)   do{ 																\
N                                            if((flag) != 0)	\
N                                            {	X_TASK_LOG_DEBUG_METHOD	message ;	   	}			\
N                                        }while(0)
X    #define X_TASK_LOG(flag,message)   do{ 																                                            if((flag) != 0)	                                            {	X_TASK_LOG_DEBUG_METHOD	message ;	   	}			                                        }while(0)
N
N#else
S    #define X_TASK_LOG(flag,message)  do{ }while(0)
N#endif
N
N#ifndef TASK_TAG_INDEX
N    #define TASK_TAG_INDEX  0
N#endif
N/**********************************************************************************************************************/
Ntypedef X_Void (*x_task_func)(uint32_t x_task_param_ms,uint16_t task_id,uint8_t *p_isInitDone);
Xtypedef void (*x_task_func)(uint32_t x_task_param_ms,uint16_t task_id,uint8_t *p_isInitDone);
Ntypedef X_Void (*x_one_step)(uint32_t ms);
Xtypedef void (*x_one_step)(uint32_t ms);
N
N#define X_TASK_NULL_INIT_FUNC      ((x_one_step)0)
N/**********************************************************************************************************************/
Ntypedef enum
N{
N	xte_ok = 0,
N	xte_pointer_null,
N	xte_beyond_scope,
N	xte_init_failed,
N	xte_unknow_error,
N    xte_frozen,
N}e_x_task_error_code;
N
N/**********************************************************************************************************************/
N
N#define X_TASK_INVALID_LINE_NUM        0
N#define X_TASK_GOTO_THE_END_LINE_NUM        0xFFFFFFFF
N#define X_TASK_INVALID_DEEPTH          0xFFFF
NX_Void X_Task_ByteBufClear(uint8_t *p_buf,uint16_t length);
Xvoid X_Task_ByteBufClear(uint8_t *p_buf,uint16_t length);
NX_Void X_Task_32bitsBufClear(uint32_t *p_buf,uint16_t length);
Xvoid X_Task_32bitsBufClear(uint32_t *p_buf,uint16_t length);
N
NX_Void X_Task_if_line_push(uint16_t loop_deepth,uint16_t if_deepth,uint8_t *p_line_flag_buf);
Xvoid X_Task_if_line_push(uint16_t loop_deepth,uint16_t if_deepth,uint8_t *p_line_flag_buf);
NX_Void X_Task_if_line_pop_All(uint16_t loop_deepth,uint16_t max_if_deepth,uint8_t *p_line_flag_buf,uint32_t *P_line_buf);
Xvoid X_Task_if_line_pop_All(uint16_t loop_deepth,uint16_t max_if_deepth,uint8_t *p_line_flag_buf,uint32_t *P_line_buf);
NX_Void X_Task_loop_line_pop_all(uint16_t loop_deepth,uint16_t max_loop_deepth,uint32_t *P_end_line_buf,uint32_t *P_line_buf);
Xvoid X_Task_loop_line_pop_all(uint16_t loop_deepth,uint16_t max_loop_deepth,uint32_t *P_end_line_buf,uint32_t *P_line_buf);
N
N#ifdef __cplusplus
S		}
N#endif
N
N#endif
N
L 22 "..\..\..\module\component\const_loop_scheduler\TemplateTask\template_task.h" 2
N
N#define __T_BASE_INIT_EXPAND_0(__t_data_struct)   X_TASK_LOG(1,(" !!! task template instacne num can not be 0  \r\n"))
N#define __T_BASE_INIT_EXPAND_1(__t_data_struct)    &(((__t_data_struct)[0]).base)
N#define __T_BASE_INIT_EXPAND_2(__t_data_struct)    __T_BASE_INIT_EXPAND_1(__t_data_struct),&((__t_data_struct)[1]).base
N#define __T_BASE_INIT_EXPAND_3(__t_data_struct)    __T_BASE_INIT_EXPAND_2(__t_data_struct),&((__t_data_struct)[2]).base
N#define __T_BASE_INIT_EXPAND_4(__t_data_struct)    __T_BASE_INIT_EXPAND_3(__t_data_struct),&((__t_data_struct)[3]).base
N#define __T_BASE_INIT_EXPAND_5(__t_data_struct)    __T_BASE_INIT_EXPAND_4(__t_data_struct),&((__t_data_struct)[4]).base
N#define __T_BASE_INIT_EXPAND_6(__t_data_struct)    __T_BASE_INIT_EXPAND_5(__t_data_struct),&((__t_data_struct)[5]).base
N#define __T_BASE_INIT_EXPAND_7(__t_data_struct)    __T_BASE_INIT_EXPAND_6(__t_data_struct),&((__t_data_struct)[6]).base
N#define __T_BASE_INIT_EXPAND_8(__t_data_struct)    __T_BASE_INIT_EXPAND_7(__t_data_struct),&((__t_data_struct)[7]).base
N#define __T_BASE_INIT_EXPAND_9(__t_data_struct)    __T_BASE_INIT_EXPAND_8(__t_data_struct),&((__t_data_struct)[8]).base
N#define __T_BASE_INIT_EXPAND_10(__t_data_struct)    __T_BASE_INIT_EXPAND_9(__t_data_struct),&((__t_data_struct)[9]).base
N
N#define __T_BASE_INIT_EXPAND_11(__t_data_struct)    __T_BASE_INIT_EXPAND_10(__t_data_struct),&((__t_data_struct)[10]).base
N#define __T_BASE_INIT_EXPAND_12(__t_data_struct)    __T_BASE_INIT_EXPAND_11(__t_data_struct),&((__t_data_struct)[11]).base
N#define __T_BASE_INIT_EXPAND_13(__t_data_struct)    __T_BASE_INIT_EXPAND_12(__t_data_struct),&((__t_data_struct)[12]).base
N#define __T_BASE_INIT_EXPAND_14(__t_data_struct)    __T_BASE_INIT_EXPAND_13(__t_data_struct),&((__t_data_struct)[13]).base
N#define __T_BASE_INIT_EXPAND_15(__t_data_struct)    __T_BASE_INIT_EXPAND_14(__t_data_struct),&((__t_data_struct)[14]).base
N#define __T_BASE_INIT_EXPAND_16(__t_data_struct)    __T_BASE_INIT_EXPAND_15(__t_data_struct),&((__t_data_struct)[15]).base
N#define __T_BASE_INIT_EXPAND_17(__t_data_struct)    __T_BASE_INIT_EXPAND_16(__t_data_struct),&((__t_data_struct)[16]).base
N#define __T_BASE_INIT_EXPAND_18(__t_data_struct)    __T_BASE_INIT_EXPAND_17(__t_data_struct),&((__t_data_struct)[17]).base
N#define __T_BASE_INIT_EXPAND_19(__t_data_struct)    __T_BASE_INIT_EXPAND_18(__t_data_struct),&((__t_data_struct)[18]).base
N#define __T_BASE_INIT_EXPAND_20(__t_data_struct)    __T_BASE_INIT_EXPAND_19(__t_data_struct),&((__t_data_struct)[19]).base
N
N#define __T_BASE_INIT_EXPAND_21(__t_data_struct)    __T_BASE_INIT_EXPAND_20(__t_data_struct),&((__t_data_struct)[20]).base
N#define __T_BASE_INIT_EXPAND_22(__t_data_struct)    __T_BASE_INIT_EXPAND_21(__t_data_struct),&((__t_data_struct)[21]).base
N#define __T_BASE_INIT_EXPAND_23(__t_data_struct)    __T_BASE_INIT_EXPAND_22(__t_data_struct),&((__t_data_struct)[22]).base
N#define __T_BASE_INIT_EXPAND_24(__t_data_struct)    __T_BASE_INIT_EXPAND_23(__t_data_struct),&((__t_data_struct)[23]).base
N#define __T_BASE_INIT_EXPAND_25(__t_data_struct)    __T_BASE_INIT_EXPAND_24(__t_data_struct),&((__t_data_struct)[24]).base
N#define __T_BASE_INIT_EXPAND_26(__t_data_struct)    __T_BASE_INIT_EXPAND_25(__t_data_struct),&((__t_data_struct)[25]).base
N#define __T_BASE_INIT_EXPAND_27(__t_data_struct)    __T_BASE_INIT_EXPAND_26(__t_data_struct),&((__t_data_struct)[26]).base
N#define __T_BASE_INIT_EXPAND_28(__t_data_struct)    __T_BASE_INIT_EXPAND_27(__t_data_struct),&((__t_data_struct)[27]).base
N#define __T_BASE_INIT_EXPAND_29(__t_data_struct)    __T_BASE_INIT_EXPAND_28(__t_data_struct),&((__t_data_struct)[28]).base
N#define __T_BASE_INIT_EXPAND_30(__t_data_struct)    __T_BASE_INIT_EXPAND_29(__t_data_struct),&((__t_data_struct)[29]).base
N
N#define __T_BASE_INIT_EXPAND_31(__t_data_struct)    __T_BASE_INIT_EXPAND_30(__t_data_struct),&((__t_data_struct)[30]).base
N#define __T_BASE_INIT_EXPAND_32(__t_data_struct)    __T_BASE_INIT_EXPAND_31(__t_data_struct),&((__t_data_struct)[31]).base
N#define __T_BASE_INIT_EXPAND_33(__t_data_struct)    __T_BASE_INIT_EXPAND_32(__t_data_struct),&((__t_data_struct)[32]).base
N#define __T_BASE_INIT_EXPAND_34(__t_data_struct)    __T_BASE_INIT_EXPAND_33(__t_data_struct),&((__t_data_struct)[33]).base
N#define __T_BASE_INIT_EXPAND_35(__t_data_struct)    __T_BASE_INIT_EXPAND_34(__t_data_struct),&((__t_data_struct)[34]).base
N#define __T_BASE_INIT_EXPAND_36(__t_data_struct)    __T_BASE_INIT_EXPAND_35(__t_data_struct),&((__t_data_struct)[35]).base
N#define __T_BASE_INIT_EXPAND_37(__t_data_struct)    __T_BASE_INIT_EXPAND_36(__t_data_struct),&((__t_data_struct)[36]).base
N#define __T_BASE_INIT_EXPAND_38(__t_data_struct)    __T_BASE_INIT_EXPAND_37(__t_data_struct),&((__t_data_struct)[37]).base
N#define __T_BASE_INIT_EXPAND_39(__t_data_struct)    __T_BASE_INIT_EXPAND_38(__t_data_struct),&((__t_data_struct)[38]).base
N#define __T_BASE_INIT_EXPAND_40(__t_data_struct)    __T_BASE_INIT_EXPAND_39(__t_data_struct),&((__t_data_struct)[39]).base
N
N#define __T_BASE_INIT_EXPAND_41(__t_data_struct)    __T_BASE_INIT_EXPAND_40(__t_data_struct),&((__t_data_struct)[40]).base
N#define __T_BASE_INIT_EXPAND_42(__t_data_struct)    __T_BASE_INIT_EXPAND_41(__t_data_struct),&((__t_data_struct)[41]).base
N#define __T_BASE_INIT_EXPAND_43(__t_data_struct)    __T_BASE_INIT_EXPAND_42(__t_data_struct),&((__t_data_struct)[42]).base
N#define __T_BASE_INIT_EXPAND_44(__t_data_struct)    __T_BASE_INIT_EXPAND_43(__t_data_struct),&((__t_data_struct)[43]).base
N#define __T_BASE_INIT_EXPAND_45(__t_data_struct)    __T_BASE_INIT_EXPAND_44(__t_data_struct),&((__t_data_struct)[44]).base
N#define __T_BASE_INIT_EXPAND_46(__t_data_struct)    __T_BASE_INIT_EXPAND_45(__t_data_struct),&((__t_data_struct)[45]).base
N#define __T_BASE_INIT_EXPAND_47(__t_data_struct)    __T_BASE_INIT_EXPAND_46(__t_data_struct),&((__t_data_struct)[46]).base
N#define __T_BASE_INIT_EXPAND_48(__t_data_struct)    __T_BASE_INIT_EXPAND_47(__t_data_struct),&((__t_data_struct)[47]).base
N#define __T_BASE_INIT_EXPAND_49(__t_data_struct)    __T_BASE_INIT_EXPAND_48(__t_data_struct),&((__t_data_struct)[48]).base
N#define __T_BASE_INIT_EXPAND_50(__t_data_struct)    __T_BASE_INIT_EXPAND_49(__t_data_struct),&((__t_data_struct)[49]).base
N
N#define __T_BASE_INIT_EXPAND_51(__t_data_struct)    __T_BASE_INIT_EXPAND_50(__t_data_struct),&((__t_data_struct)[50]).base
N#define __T_BASE_INIT_EXPAND_52(__t_data_struct)    __T_BASE_INIT_EXPAND_51(__t_data_struct),&((__t_data_struct)[51]).base
N#define __T_BASE_INIT_EXPAND_53(__t_data_struct)    __T_BASE_INIT_EXPAND_52(__t_data_struct),&((__t_data_struct)[52]).base
N#define __T_BASE_INIT_EXPAND_54(__t_data_struct)    __T_BASE_INIT_EXPAND_53(__t_data_struct),&((__t_data_struct)[53]).base
N#define __T_BASE_INIT_EXPAND_55(__t_data_struct)    __T_BASE_INIT_EXPAND_54(__t_data_struct),&((__t_data_struct)[54]).base
N#define __T_BASE_INIT_EXPAND_56(__t_data_struct)    __T_BASE_INIT_EXPAND_55(__t_data_struct),&((__t_data_struct)[55]).base
N#define __T_BASE_INIT_EXPAND_57(__t_data_struct)    __T_BASE_INIT_EXPAND_56(__t_data_struct),&((__t_data_struct)[56]).base
N#define __T_BASE_INIT_EXPAND_58(__t_data_struct)    __T_BASE_INIT_EXPAND_57(__t_data_struct),&((__t_data_struct)[57]).base
N#define __T_BASE_INIT_EXPAND_59(__t_data_struct)    __T_BASE_INIT_EXPAND_58(__t_data_struct),&((__t_data_struct)[58]).base
N#define __T_BASE_INIT_EXPAND_60(__t_data_struct)    __T_BASE_INIT_EXPAND_59(__t_data_struct),&((__t_data_struct)[59]).base
N
N#define __T_BASE_INIT_EXPAND_61(__t_data_struct)    __T_BASE_INIT_EXPAND_60(__t_data_struct),&((__t_data_struct)[60]).base
N#define __T_BASE_INIT_EXPAND_62(__t_data_struct)    __T_BASE_INIT_EXPAND_61(__t_data_struct),&((__t_data_struct)[61]).base
N#define __T_BASE_INIT_EXPAND_63(__t_data_struct)    __T_BASE_INIT_EXPAND_62(__t_data_struct),&((__t_data_struct)[62]).base
N#define __T_BASE_INIT_EXPAND_64(__t_data_struct)    __T_BASE_INIT_EXPAND_63(__t_data_struct),&((__t_data_struct)[63]).base
N#define __T_BASE_INIT_EXPAND_65(__t_data_struct)    __T_BASE_INIT_EXPAND_64(__t_data_struct),&((__t_data_struct)[64]).base
N#define __T_BASE_INIT_EXPAND_66(__t_data_struct)    __T_BASE_INIT_EXPAND_65(__t_data_struct),&((__t_data_struct)[65]).base
N#define __T_BASE_INIT_EXPAND_67(__t_data_struct)    __T_BASE_INIT_EXPAND_66(__t_data_struct),&((__t_data_struct)[66]).base
N#define __T_BASE_INIT_EXPAND_68(__t_data_struct)    __T_BASE_INIT_EXPAND_67(__t_data_struct),&((__t_data_struct)[67]).base
N#define __T_BASE_INIT_EXPAND_69(__t_data_struct)    __T_BASE_INIT_EXPAND_68(__t_data_struct),&((__t_data_struct)[68]).base
N#define __T_BASE_INIT_EXPAND_70(__t_data_struct)    __T_BASE_INIT_EXPAND_69(__t_data_struct),&((__t_data_struct)[69]).base
N
N#define __T_BASE_INIT_EXPAND_71(__t_data_struct)    __T_BASE_INIT_EXPAND_70(__t_data_struct),&((__t_data_struct)[70]).base
N#define __T_BASE_INIT_EXPAND_72(__t_data_struct)    __T_BASE_INIT_EXPAND_71(__t_data_struct),&((__t_data_struct)[71]).base
N#define __T_BASE_INIT_EXPAND_73(__t_data_struct)    __T_BASE_INIT_EXPAND_72(__t_data_struct),&((__t_data_struct)[72]).base
N#define __T_BASE_INIT_EXPAND_74(__t_data_struct)    __T_BASE_INIT_EXPAND_73(__t_data_struct),&((__t_data_struct)[73]).base
N#define __T_BASE_INIT_EXPAND_75(__t_data_struct)    __T_BASE_INIT_EXPAND_74(__t_data_struct),&((__t_data_struct)[74]).base
N#define __T_BASE_INIT_EXPAND_76(__t_data_struct)    __T_BASE_INIT_EXPAND_75(__t_data_struct),&((__t_data_struct)[75]).base
N#define __T_BASE_INIT_EXPAND_77(__t_data_struct)    __T_BASE_INIT_EXPAND_76(__t_data_struct),&((__t_data_struct)[76]).base
N#define __T_BASE_INIT_EXPAND_78(__t_data_struct)    __T_BASE_INIT_EXPAND_77(__t_data_struct),&((__t_data_struct)[77]).base
N#define __T_BASE_INIT_EXPAND_79(__t_data_struct)    __T_BASE_INIT_EXPAND_78(__t_data_struct),&((__t_data_struct)[78]).base
N#define __T_BASE_INIT_EXPAND_80(__t_data_struct)    __T_BASE_INIT_EXPAND_79(__t_data_struct),&((__t_data_struct)[79]).base
N
N#define __T_BASE_INIT_EXPAND_81(__t_data_struct)    __T_BASE_INIT_EXPAND_80(__t_data_struct),&((__t_data_struct)[80]).base
N#define __T_BASE_INIT_EXPAND_82(__t_data_struct)    __T_BASE_INIT_EXPAND_81(__t_data_struct),&((__t_data_struct)[81]).base
N#define __T_BASE_INIT_EXPAND_83(__t_data_struct)    __T_BASE_INIT_EXPAND_82(__t_data_struct),&((__t_data_struct)[82]).base
N#define __T_BASE_INIT_EXPAND_84(__t_data_struct)    __T_BASE_INIT_EXPAND_83(__t_data_struct),&((__t_data_struct)[83]).base
N#define __T_BASE_INIT_EXPAND_85(__t_data_struct)    __T_BASE_INIT_EXPAND_84(__t_data_struct),&((__t_data_struct)[84]).base
N#define __T_BASE_INIT_EXPAND_86(__t_data_struct)    __T_BASE_INIT_EXPAND_85(__t_data_struct),&((__t_data_struct)[85]).base
N#define __T_BASE_INIT_EXPAND_87(__t_data_struct)    __T_BASE_INIT_EXPAND_86(__t_data_struct),&((__t_data_struct)[86]).base
N#define __T_BASE_INIT_EXPAND_88(__t_data_struct)    __T_BASE_INIT_EXPAND_87(__t_data_struct),&((__t_data_struct)[87]).base
N#define __T_BASE_INIT_EXPAND_89(__t_data_struct)    __T_BASE_INIT_EXPAND_88(__t_data_struct),&((__t_data_struct)[88]).base
N#define __T_BASE_INIT_EXPAND_90(__t_data_struct)    __T_BASE_INIT_EXPAND_89(__t_data_struct),&((__t_data_struct)[89]).base
N
N#define __T_BASE_INIT_EXPAND_91(__t_data_struct)    __T_BASE_INIT_EXPAND_90(__t_data_struct),&((__t_data_struct)[90]).base
N#define __T_BASE_INIT_EXPAND_92(__t_data_struct)    __T_BASE_INIT_EXPAND_91(__t_data_struct),&((__t_data_struct)[91]).base
N#define __T_BASE_INIT_EXPAND_93(__t_data_struct)    __T_BASE_INIT_EXPAND_92(__t_data_struct),&((__t_data_struct)[92]).base
N#define __T_BASE_INIT_EXPAND_94(__t_data_struct)    __T_BASE_INIT_EXPAND_93(__t_data_struct),&((__t_data_struct)[93]).base
N#define __T_BASE_INIT_EXPAND_95(__t_data_struct)    __T_BASE_INIT_EXPAND_94(__t_data_struct),&((__t_data_struct)[94]).base
N#define __T_BASE_INIT_EXPAND_96(__t_data_struct)    __T_BASE_INIT_EXPAND_95(__t_data_struct),&((__t_data_struct)[95]).base
N#define __T_BASE_INIT_EXPAND_97(__t_data_struct)    __T_BASE_INIT_EXPAND_96(__t_data_struct),&((__t_data_struct)[96]).base
N#define __T_BASE_INIT_EXPAND_98(__t_data_struct)    __T_BASE_INIT_EXPAND_97(__t_data_struct),&((__t_data_struct)[97]).base
N#define __T_BASE_INIT_EXPAND_99(__t_data_struct)    __T_BASE_INIT_EXPAND_98(__t_data_struct),&((__t_data_struct)[98]).base
N#define __T_BASE_INIT_EXPAND_100(__t_data_struct)    __T_BASE_INIT_EXPAND_99(__t_data_struct),&((__t_data_struct)[99]).base
N
N#define __T_BASE_BUFF_SIZE(__t_data_struct) 		 (sizeof(__t_data_struct)/sizeof(__t_data_struct[0]))
N#define T_BASE_BUFF_SIZE(__t_data_struct)  			__T_BASE_BUFF_SIZE(__t_data_struct)          
N
N#define  __T_BASE_INIT_EXPAND(__t_data_struct,__n)     CONCAT_2(__T_BASE_INIT_EXPAND_,__n)(__t_data_struct)
N#define T_BASE_INIT_EXPAND(__t_data_struct,__n)        { __T_BASE_INIT_EXPAND(__t_data_struct,__n) }
N
N
N#define __T_TASK_NUM_INSTANCE_IMPL(   _0,_00,_000, 	_1, _2, _3, _4, _5, _6, _7, _8, _9, _10,   \
N 													_11, _12, _13, _14, _15, _16, _17, _18, _19, _20,   \
N 													_21, _22, _23, _24, _25, _26, _27, _28, _29, _30,   \
N 													_31, _32, _33, _34, _35, _36, _37, _38, _39, _40,   \
N 													_41, _42, _43, _44, _45, _46, _47, _48, _49, _50,   \
N 													_51, _52, _53, _54, _55, _56, _57, _58, _59, _60,   \
N 													_61, _62, _63, _64, _65, _66, _67, _68, _69, _70,   \
N 													_71, _72, _73, _74, _75, _76, _77, _78, _79, _80,   \
N 													_81, _82, _83, _84, _85, _86, _87, _88, _89, _90,   \
N 													_91, _92, _93, _94, _95, _96, _97, _98, _99, _100,  \
N													__N,...)      __N
X#define __T_TASK_NUM_INSTANCE_IMPL(   _0,_00,_000, 	_1, _2, _3, _4, _5, _6, _7, _8, _9, _10,    													_11, _12, _13, _14, _15, _16, _17, _18, _19, _20,    													_21, _22, _23, _24, _25, _26, _27, _28, _29, _30,    													_31, _32, _33, _34, _35, _36, _37, _38, _39, _40,    													_41, _42, _43, _44, _45, _46, _47, _48, _49, _50,    													_51, _52, _53, _54, _55, _56, _57, _58, _59, _60,    													_61, _62, _63, _64, _65, _66, _67, _68, _69, _70,    													_71, _72, _73, _74, _75, _76, _77, _78, _79, _80,    													_81, _82, _83, _84, _85, _86, _87, _88, _89, _90,    													_91, _92, _93, _94, _95, _96, _97, _98, _99, _100,  													__N,...)      __N
N
N
N
N#define __T_TASK_NUM_INSTANCE(...)                                                \
N            __T_TASK_NUM_INSTANCE_IMPL( 0,00,000,##__VA_ARGS__, 100,               \
N 																99, 98, 97, 96, 95, 94, 93, 92, 91, 90,  \
N 																89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 	\
N 																79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 	\
N 																69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 		\
N 																59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 		\
N 																49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 			\
N 																39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 		\
N 																29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 		\
N 																19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 		\
N 																9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 					\
N									)
X#define __T_TASK_NUM_INSTANCE(...)                                                            __T_TASK_NUM_INSTANCE_IMPL( 0,00,000,##__VA_ARGS__, 100,                																99, 98, 97, 96, 95, 94, 93, 92, 91, 90,   																89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 	 																79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 	 																69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 		 																59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 		 																49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 			 																39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 		 																29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 		 																19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 		 																9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 														)
N
N
N
N									  
N
N#define MAX_TEMPLATE_INSTANCE_NUM                    100 
N#define MAX_TEMPLATE_NAME_LENGTH                     15
N#define MAX_TEMPLATE_INSTANCE_NAME_LENGTH            15
N#define MAX_T_TASK_IF_NEST_DEEPTH                    8
N#define MAX_T_TASK_LOOP_NEST_DEEPTH                  8
N
N
Ntypedef struct
N{
N	/*~~~~~~~~~~~~~~~~T task value ~~~~~~~~~~~~~~~~~~~~~~*/
N	uint32_t ms_backup;  // = 0                            
N 	uint32_t cur_line_num; // = 0 ;                              
N 	
N 	uint8_t if_condition_buf[MAX_T_TASK_IF_NEST_DEEPTH + 1];      
X 	uint8_t if_condition_buf[8 + 1];      
N 	uint32_t if_line_num_buf[MAX_T_TASK_IF_NEST_DEEPTH + 1];       
X 	uint32_t if_line_num_buf[8 + 1];       
N 	uint8_t loop_condition_buf[MAX_T_TASK_LOOP_NEST_DEEPTH + 1];      
X 	uint8_t loop_condition_buf[8 + 1];      
N 	uint32_t loop_line_num_buf[MAX_T_TASK_LOOP_NEST_DEEPTH + 1];      
X 	uint32_t loop_line_num_buf[8 + 1];      
N 	uint32_t loop_end_line_num_buf[MAX_T_TASK_LOOP_NEST_DEEPTH + 1];                           
X 	uint32_t loop_end_line_num_buf[8 + 1];                           
N 	uint8_t if_line_flag_array[MAX_T_TASK_LOOP_NEST_DEEPTH + 2][MAX_T_TASK_IF_NEST_DEEPTH + 1]; 
X 	uint8_t if_line_flag_array[8 + 2][8 + 1]; 
N 	uint8_t isErrorOccur ; // ) = 0;                              
N	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
N}s_T_taskCommonParam;
N
Ntypedef X_Void (*t_task_func)(uint32_t t_task_ms,uint8_t *p_isInitDone,s_T_taskCommonParam * p_base,
Xtypedef void (*t_task_func)(uint32_t t_task_ms,uint8_t *p_isInitDone,s_T_taskCommonParam * p_base,
N                                uint16_t instance_id,uint8_t const * p_name);
Ntypedef X_Void (*t_one_step)(uint32_t t_task_ms,
Xtypedef void (*t_one_step)(uint32_t t_task_ms,
N                                uint16_t instance_id,uint8_t const * p_name,
N                                X_Void *p_this);
X                                void *p_this);
N
Ntypedef struct 
N{
N    uint8_t      template_name[MAX_TEMPLATE_NAME_LENGTH];
X    uint8_t      template_name[15];
N	uint16_t     instance_num;           // total instance number 
N	uint16_t     instance_with_name_num;
N    uint8_t      const * p_instance_name_buf;
N////////////////	uint16_t     nest_if_deepth_limit;
N////////////////	uint16_t     nest_loop_deepth_limit;
N	uint8_t      * p_is_init_ok;
N	uint8_t      * p_init_flag_buf;
N	uint8_t      * p_freeze_flag_buf;
N	t_task_func    			p_template_task_func;
N	s_T_taskCommonParam 	 *const * p_param_buf;
N}s_T_Tasks_Manager;
N
N/**********************************************************************************************************************/
N
N/**********************************************************************************************************************/
Ne_x_task_error_code t_task_init(const s_T_Tasks_Manager *p_manager);                               
Ne_x_task_error_code t_task_scheduler(const s_T_Tasks_Manager *p_manager,uint32_t ms);
N
Ne_x_task_error_code freeze_t_task(const s_T_Tasks_Manager *p_manager,uint16_t instance_id);
Ne_x_task_error_code unfreeze_t_task(const s_T_Tasks_Manager *p_manager,uint16_t instance_id);
Ne_x_task_error_code restart_t_task(const s_T_Tasks_Manager *p_manager,uint16_t instance_id);
N/**********************************************************************************************************************/
N/**********************************************************************************************************************/
N#define T_do(todo_sentence)     do{ 													\
N                                    cur_line_num_temp = __LINE__ ;    \
N                                    if (p_base -> cur_line_num <  cur_line_num_temp){  \
N                                        p_base -> cur_line_num = cur_line_num_temp;  \
N                                        todo_sentence;                                   \
N                                    }                                               \
N                                  }while(0)
X#define T_do(todo_sentence)     do{ 													                                    cur_line_num_temp = __LINE__ ;                                        if (p_base -> cur_line_num <  cur_line_num_temp){                                          p_base -> cur_line_num = cur_line_num_temp;                                          todo_sentence;                                                                       }                                                                                 }while(0)
N/**********************************************************************************************************************/
N#define T_delay(x_wait_ms)  do{                         \
N                                cur_line_num_temp = __LINE__ ;    \
N                                if (p_base ->cur_line_num <  cur_line_num_temp){  \
N                                        p_base ->cur_line_num = cur_line_num_temp;  \
N                                        p_base ->ms_backup = t_task_ms;     \
N                                        return;                             \
N                                }                                                                            \
N                                else if(p_base ->cur_line_num ==  cur_line_num_temp){          \
N                                    if(((x_wait_ms) != 0) && ((t_task_ms - p_base ->ms_backup) < (x_wait_ms))) {return;}   \
N                                }                                                                            \
N                              }while(0)
X#define T_delay(x_wait_ms)  do{                                                         cur_line_num_temp = __LINE__ ;                                    if (p_base ->cur_line_num <  cur_line_num_temp){                                          p_base ->cur_line_num = cur_line_num_temp;                                          p_base ->ms_backup = t_task_ms;                                             return;                                                             }                                                                                                            else if(p_base ->cur_line_num ==  cur_line_num_temp){                                              if(((x_wait_ms) != 0) && ((t_task_ms - p_base ->ms_backup) < (x_wait_ms))) {return;}                                   }                                                                                                          }while(0)
N
N#define T_wait_until(condition_break_sentence)    do{                         \
N                                                        cur_line_num_temp = __LINE__ ;                     \
N                                                        if (p_base ->cur_line_num < cur_line_num_temp){       \
N                                                                p_base ->cur_line_num = cur_line_num_temp;  \
N                                                                return;                                                    \
N                                                        }                                                                            \
N                                                        else if(p_base -> cur_line_num ==  cur_line_num_temp){          \
N                                                            if(!(condition_break_sentence)) {return;} }               \
N                                                    }while(0)
X#define T_wait_until(condition_break_sentence)    do{                                                                                 cur_line_num_temp = __LINE__ ;                                                                             if (p_base ->cur_line_num < cur_line_num_temp){                                                                       p_base ->cur_line_num = cur_line_num_temp;                                                                  return;                                                                                                            }                                                                                                                                    else if(p_base -> cur_line_num ==  cur_line_num_temp){                                                                      if(!(condition_break_sentence)) {return;} }                                                                   }while(0)
N
N#define T_time_limited_wait(x_limit_ms,condition_break_sentence)  do{                         \
N                                                        cur_line_num_temp = __LINE__ ;                        \
N                                                        if (p_base ->cur_line_num <  cur_line_num_temp){          \
N                                                                p_base -> cur_line_num = cur_line_num_temp;  \
N                                                                p_base ->ms_backup = t_task_ms;    \
N                                                                return;                                                    \
N                                                        }                                                                            \
N                                                        else if(p_base ->cur_line_num ==  cur_line_num_temp){          \
N                                                                if(((x_limit_ms) != 0) && ((t_task_ms - p_base ->ms_backup) < (x_limit_ms))) {  \
N                                                                    if(!(condition_break_sentence)) {return;}                         \
N                                                                }   \
N                                                            }               \
N                                                    }while(0)
X#define T_time_limited_wait(x_limit_ms,condition_break_sentence)  do{                                                                                 cur_line_num_temp = __LINE__ ;                                                                                if (p_base ->cur_line_num <  cur_line_num_temp){                                                                          p_base -> cur_line_num = cur_line_num_temp;                                                                  p_base ->ms_backup = t_task_ms;                                                                    return;                                                                                                            }                                                                                                                                    else if(p_base ->cur_line_num ==  cur_line_num_temp){                                                                          if(((x_limit_ms) != 0) && ((t_task_ms - p_base ->ms_backup) < (x_limit_ms))) {                                                                      if(!(condition_break_sentence)) {return;}                                                                                         }                                                               }                                                                   }while(0)
N
N#define T_time_limited_wait_with_result(x_limit_ms,condition_break_sentence,wait_result_bool_variable)  do{                         \
N                                                        cur_line_num_temp = __LINE__ ;                     \
N                                                        if (p_base ->cur_line_num <  cur_line_num_temp){  \
N                                                                p_base ->cur_line_num = cur_line_num_temp;  \
N                                                                p_base ->ms_backup = t_task_ms;    \
N                                                                wait_result_bool_variable = X_False;      \
N                                                                return;                                                    \
N                                                        }                                                                            \
N                                                        else if(p_base ->cur_line_num ==  cur_line_num_temp){          \
N                                                                if(((x_limit_ms) != 0) && ((t_task_ms - p_base ->ms_backup) < (x_limit_ms))) {  \
N                                                                    if(!(condition_break_sentence)) {return;}                         \
N                                                                    wait_result_bool_variable = X_True;     \
N                                                                }   \
N                                                            }               \
N                                                    }while(0)
X#define T_time_limited_wait_with_result(x_limit_ms,condition_break_sentence,wait_result_bool_variable)  do{                                                                                 cur_line_num_temp = __LINE__ ;                                                                             if (p_base ->cur_line_num <  cur_line_num_temp){                                                                  p_base ->cur_line_num = cur_line_num_temp;                                                                  p_base ->ms_backup = t_task_ms;                                                                    wait_result_bool_variable = X_False;                                                                      return;                                                                                                            }                                                                                                                                    else if(p_base ->cur_line_num ==  cur_line_num_temp){                                                                          if(((x_limit_ms) != 0) && ((t_task_ms - p_base ->ms_backup) < (x_limit_ms))) {                                                                      if(!(condition_break_sentence)) {return;}                                                                                             wait_result_bool_variable = X_True;                                                                     }                                                               }                                                                   }while(0)
N/**********************************************************************************************************************/ 
N
N/**********************************************************************************************************************/
N#define T_return  do{                                                       \
N                        if(p_base ->isErrorOccur == 0) {                             \
N                            p_base ->cur_line_num = 0;                                       \
N                            X_Task_ByteBufClear(p_base ->if_condition_buf,MAX_T_TASK_IF_NEST_DEEPTH + 1);           \
N                                X_Task_32bitsBufClear(p_base ->if_line_num_buf,MAX_T_TASK_IF_NEST_DEEPTH + 1);           \
N                                X_Task_ByteBufClear(p_base ->loop_condition_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);           \
N                                X_Task_32bitsBufClear(p_base ->loop_line_num_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);           \
N                                X_Task_32bitsBufClear(p_base ->loop_end_line_num_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);           \
N                                X_Task_ByteBufClear(&p_base ->if_line_flag_array[0][0],(MAX_T_TASK_LOOP_NEST_DEEPTH + 2) *(MAX_T_TASK_IF_NEST_DEEPTH + 1) );      \
N                        }                                                           \
N                        else {                                                                     \
N                        X_TASK_LOG(1,(" ---- template task %s : instance %d : fatal error occur , task stop !!!\r\n",(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id));                   \
N                        p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;        \
N                        }                                           \
N                        return ;                                     \
N                    }while(0)
X#define T_return  do{                                                                               if(p_base ->isErrorOccur == 0) {                                                         p_base ->cur_line_num = 0;                                                                   X_Task_ByteBufClear(p_base ->if_condition_buf,MAX_T_TASK_IF_NEST_DEEPTH + 1);                                           X_Task_32bitsBufClear(p_base ->if_line_num_buf,MAX_T_TASK_IF_NEST_DEEPTH + 1);                                           X_Task_ByteBufClear(p_base ->loop_condition_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);                                           X_Task_32bitsBufClear(p_base ->loop_line_num_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);                                           X_Task_32bitsBufClear(p_base ->loop_end_line_num_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);                                           X_Task_ByteBufClear(&p_base ->if_line_flag_array[0][0],(MAX_T_TASK_LOOP_NEST_DEEPTH + 2) *(MAX_T_TASK_IF_NEST_DEEPTH + 1) );                              }                                                                                   else {                                                                                             X_TASK_LOG(1,(" ---- template task %s : instance %d : fatal error occur , task stop !!!\r\n",(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id));                                           p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;                                }                                                                   return ;                                                         }while(0)
N      
N/**********************************************************************************************************************/
N#define T_if(conditon)   do{     \
N                                cur_line_num_temp = __LINE__ ;    \
N                                nest_cnt ++;                                                \
N                                if((nest_cnt - 1) > MAX_T_TASK_IF_NEST_DEEPTH)  {  \
N                                    X_TASK_LOG(1,(" ---- template task %s : instance %d : if nest deepth(%d) beyond scope(%d) ; line %d \r\n"                   \
N                                    ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,(nest_cnt - 1),MAX_T_TASK_IF_NEST_DEEPTH,cur_line_num_temp));  \
N                                    p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1; \
N                                    return ; \
N                                }    \
N                                X_Task_if_line_push(loop_nest_cnt,nest_cnt - 1,&p_base ->if_line_flag_array[loop_nest_cnt][0]) ;       \
N                                if (p_base ->if_line_num_buf[nest_cnt - 1] <  cur_line_num_temp){  									\
N                                    p_base ->if_line_num_buf[nest_cnt - 1] = cur_line_num_temp;                              \
N                                    p_base ->if_condition_buf[nest_cnt - 1] = (conditon) ? 0xFF : 0;   \
N                                }                        \
N                                else if(p_base ->if_line_num_buf[nest_cnt - 1] == cur_line_num_temp) {                     \
N                                    if((p_base ->if_condition_buf[nest_cnt - 1] & 0x0F) != 0) {     \
N                                    p_base ->if_condition_buf[nest_cnt - 1] = 0xFF;                     \
N                                    }       \
N                                    else {                \
N                                    p_base ->if_condition_buf[nest_cnt - 1] = 0;}                    \
N                                }                                                                  \
N                                else{                                                                   \
N                                    p_base ->if_condition_buf[nest_cnt - 1] &= 0x0F;                    \
N                                }                          \
N                            }while(0);   \
N                            if(p_base ->if_condition_buf[nest_cnt - 1] & 0xF0)
X#define T_if(conditon)   do{                                     cur_line_num_temp = __LINE__ ;                                    nest_cnt ++;                                                                                if((nest_cnt - 1) > MAX_T_TASK_IF_NEST_DEEPTH)  {                                      X_TASK_LOG(1,(" ---- template task %s : instance %d : if nest deepth(%d) beyond scope(%d) ; line %d \r\n"                                                       ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,(nest_cnt - 1),MAX_T_TASK_IF_NEST_DEEPTH,cur_line_num_temp));                                      p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1;                                     return ;                                 }                                    X_Task_if_line_push(loop_nest_cnt,nest_cnt - 1,&p_base ->if_line_flag_array[loop_nest_cnt][0]) ;                                       if (p_base ->if_line_num_buf[nest_cnt - 1] <  cur_line_num_temp){  									                                    p_base ->if_line_num_buf[nest_cnt - 1] = cur_line_num_temp;                                                                  p_base ->if_condition_buf[nest_cnt - 1] = (conditon) ? 0xFF : 0;                                   }                                                        else if(p_base ->if_line_num_buf[nest_cnt - 1] == cur_line_num_temp) {                                                         if((p_base ->if_condition_buf[nest_cnt - 1] & 0x0F) != 0) {                                         p_base ->if_condition_buf[nest_cnt - 1] = 0xFF;                                                         }                                           else {                                                    p_base ->if_condition_buf[nest_cnt - 1] = 0;}                                                    }                                                                                                  else{                                                                                                       p_base ->if_condition_buf[nest_cnt - 1] &= 0x0F;                                                    }                                                      }while(0);                               if(p_base ->if_condition_buf[nest_cnt - 1] & 0xF0)
N
N#define T_else_if(conditon)    do{     \
N                                    cur_line_num_temp = __LINE__ ;    \
N                                    if((nest_cnt - 1) > MAX_T_TASK_IF_NEST_DEEPTH )  {  \
N                                        X_TASK_LOG(1,(" ---- template task %s : instance %d : else if nest deepth(%d) beyond scope(%d) ; line %d \r\n"                   \
N                                        ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,nest_cnt - 1,MAX_T_TASK_IF_NEST_DEEPTH,cur_line_num_temp));  \
N                                        p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1; \
N                                        return ;                  \
N                                    }    \
N                                    if (p_base ->if_line_num_buf[nest_cnt - 1] <  cur_line_num_temp){  \
N                                        p_base ->if_line_num_buf[nest_cnt - 1] = cur_line_num_temp;  \
N                                        if((p_base ->if_condition_buf[nest_cnt - 1] & 0x0F) == 0) {     \
N                                        	p_base ->if_condition_buf[nest_cnt - 1] = (conditon) ? 0xFF : 0;   \
N                                        }                              \
N                                        else {                         \
N                                        	p_base ->if_condition_buf[nest_cnt - 1] = 0x0F;       \
N                                        	p_base ->if_line_num_buf[nest_cnt - 1] ++;                \
N                                        }                                                                           \
N                                    }                        \
N                                    else if(p_base ->if_line_num_buf[nest_cnt - 1] == cur_line_num_temp) {                     \
N                                        if((p_base ->if_condition_buf[nest_cnt - 1] & 0x0F) != 0) {     \
N                                        	p_base ->if_condition_buf[nest_cnt - 1] = 0xFF;                     \
N                                        }       \
N                                        else {                \
N                                        	p_base ->if_condition_buf[nest_cnt - 1] = 0;}                    \
N                                    }                                                                  \
N                                    else{                                                                  \
N                                        p_base ->if_condition_buf[nest_cnt - 1] &= 0x0F;                    \
N                                    }                          \
N                                }while(0);   \
N                                if(p_base ->if_condition_buf[nest_cnt - 1] & 0xF0)
X#define T_else_if(conditon)    do{                                         cur_line_num_temp = __LINE__ ;                                        if((nest_cnt - 1) > MAX_T_TASK_IF_NEST_DEEPTH )  {                                          X_TASK_LOG(1,(" ---- template task %s : instance %d : else if nest deepth(%d) beyond scope(%d) ; line %d \r\n"                                                           ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,nest_cnt - 1,MAX_T_TASK_IF_NEST_DEEPTH,cur_line_num_temp));                                          p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1;                                         return ;                                                      }                                        if (p_base ->if_line_num_buf[nest_cnt - 1] <  cur_line_num_temp){                                          p_base ->if_line_num_buf[nest_cnt - 1] = cur_line_num_temp;                                          if((p_base ->if_condition_buf[nest_cnt - 1] & 0x0F) == 0) {                                             	p_base ->if_condition_buf[nest_cnt - 1] = (conditon) ? 0xFF : 0;                                           }                                                                      else {                                                                 	p_base ->if_condition_buf[nest_cnt - 1] = 0x0F;                                               	p_base ->if_line_num_buf[nest_cnt - 1] ++;                                                        }                                                                                                               }                                                            else if(p_base ->if_line_num_buf[nest_cnt - 1] == cur_line_num_temp) {                                                             if((p_base ->if_condition_buf[nest_cnt - 1] & 0x0F) != 0) {                                             	p_base ->if_condition_buf[nest_cnt - 1] = 0xFF;                                                             }                                               else {                                                        	p_base ->if_condition_buf[nest_cnt - 1] = 0;}                                                        }                                                                                                      else{                                                                                                          p_base ->if_condition_buf[nest_cnt - 1] &= 0x0F;                                                        }                                                          }while(0);                                   if(p_base ->if_condition_buf[nest_cnt - 1] & 0xF0)
N
N#define T_else               do{     \
N                                    cur_line_num_temp = __LINE__ ;    \
N                                    if((nest_cnt - 1) > MAX_T_TASK_IF_NEST_DEEPTH)  {  \
N                                        X_TASK_LOG(1,(" ---- template task %s : instance %d : else nest deepth(%d) beyond scope(%d) ; line %d \r\n"                   \
N                                        ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,nest_cnt - 1,MAX_T_TASK_IF_NEST_DEEPTH,cur_line_num_temp));  \
N                                        p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1; \
N                                        return ; \
N                                    }    \
N                                    if (p_base ->if_line_num_buf[nest_cnt - 1] <  cur_line_num_temp){  \
N                                        p_base ->if_line_num_buf[nest_cnt - 1] = cur_line_num_temp;  \
N                                        if((p_base ->if_condition_buf[nest_cnt - 1] & 0x0F) == 0) {     \
N                                            p_base ->if_condition_buf[nest_cnt - 1] = 0xFF;   \
N                                        }                              \
N                                        else {                         \
N                                            p_base ->if_condition_buf[nest_cnt - 1] = 0x0F;       \
N                                        }                                                                           \
N                                    }                        \
N                                    else if(p_base ->if_line_num_buf[nest_cnt - 1] == cur_line_num_temp) {                     \
N                                        if((p_base ->if_condition_buf[nest_cnt - 1] & 0x0F) != 0) {     \
N                                            p_base ->if_condition_buf[nest_cnt - 1] = 0xFF;                     \
N                                        }       \
N                                        else {                \
N                                            p_base ->if_condition_buf[nest_cnt - 1] = 0;}                    \
N                                    }                                                                  \
N                                    else{ \
N                                        p_base ->if_condition_buf[nest_cnt - 1] &= 0x0F;                    \
N                                    }                          \
N                                }while(0);   \
N                                if(p_base ->if_condition_buf[nest_cnt - 1] & 0xF0) 
X#define T_else               do{                                         cur_line_num_temp = __LINE__ ;                                        if((nest_cnt - 1) > MAX_T_TASK_IF_NEST_DEEPTH)  {                                          X_TASK_LOG(1,(" ---- template task %s : instance %d : else nest deepth(%d) beyond scope(%d) ; line %d \r\n"                                                           ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,nest_cnt - 1,MAX_T_TASK_IF_NEST_DEEPTH,cur_line_num_temp));                                          p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1;                                         return ;                                     }                                        if (p_base ->if_line_num_buf[nest_cnt - 1] <  cur_line_num_temp){                                          p_base ->if_line_num_buf[nest_cnt - 1] = cur_line_num_temp;                                          if((p_base ->if_condition_buf[nest_cnt - 1] & 0x0F) == 0) {                                                 p_base ->if_condition_buf[nest_cnt - 1] = 0xFF;                                           }                                                                      else {                                                                     p_base ->if_condition_buf[nest_cnt - 1] = 0x0F;                                               }                                                                                                               }                                                            else if(p_base ->if_line_num_buf[nest_cnt - 1] == cur_line_num_temp) {                                                             if((p_base ->if_condition_buf[nest_cnt - 1] & 0x0F) != 0) {                                                 p_base ->if_condition_buf[nest_cnt - 1] = 0xFF;                                                             }                                               else {                                                            p_base ->if_condition_buf[nest_cnt - 1] = 0;}                                                        }                                                                                                      else{                                         p_base ->if_condition_buf[nest_cnt - 1] &= 0x0F;                                                        }                                                          }while(0);                                   if(p_base ->if_condition_buf[nest_cnt - 1] & 0xF0) 
N
N#define T_endif   do{ 													\
N                        cur_line_num_temp = __LINE__ ;    \
N                        nest_cnt --;                                                \
N                        if(nest_cnt > MAX_T_TASK_IF_NEST_DEEPTH )  {  \
N                        X_TASK_LOG(1,(" ---- template task %s : instance %d : end if nest deepth(%d) beyond scope(%d) ; line %d \r\n"                   \
N                        ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,nest_cnt,MAX_T_TASK_IF_NEST_DEEPTH,cur_line_num_temp));  \
N                        p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1; \
N                        return ; \
N                        }    \
N                        if (p_base ->if_line_num_buf[nest_cnt] <  cur_line_num_temp){  \
N                            p_base ->if_line_num_buf[nest_cnt] = cur_line_num_temp;  \
N                        }                                               \
N                    }while(0);
X#define T_endif   do{ 													                        cur_line_num_temp = __LINE__ ;                            nest_cnt --;                                                                        if(nest_cnt > MAX_T_TASK_IF_NEST_DEEPTH )  {                          X_TASK_LOG(1,(" ---- template task %s : instance %d : end if nest deepth(%d) beyond scope(%d) ; line %d \r\n"                                           ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,nest_cnt,MAX_T_TASK_IF_NEST_DEEPTH,cur_line_num_temp));                          p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1;                         return ;                         }                            if (p_base ->if_line_num_buf[nest_cnt] <  cur_line_num_temp){                              p_base ->if_line_num_buf[nest_cnt] = cur_line_num_temp;                          }                                                                   }while(0);
N
N/**********************************************************************************************************************/
N                 
N#define T_while(conditon_true)      do{                                                           \
N                                        cur_line_num_temp = __LINE__ ;    \
N                                        loop_nest_cnt ++;                                                \
N                                        if((loop_nest_cnt - 1) > MAX_T_TASK_LOOP_NEST_DEEPTH)  {  \
N                                            X_TASK_LOG(1,(" ---- template task %s : instance %d : loop nest deepth(%d) beyond scope(%d) ; line %d \r\n"                   \
N                                            ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,loop_nest_cnt - 1,MAX_T_TASK_LOOP_NEST_DEEPTH,cur_line_num_temp));  \
N                                            p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1; \
N                                            return ; \
N                                        }    \
N                                        if (p_base ->loop_line_num_buf[loop_nest_cnt - 1] <=  cur_line_num_temp \
N                                            && p_base ->loop_end_line_num_buf[loop_nest_cnt - 1] < cur_line_num_temp){  \
N                                            p_base ->loop_line_num_buf[loop_nest_cnt - 1] = cur_line_num_temp;  \
N                                            p_base ->loop_end_line_num_buf[loop_nest_cnt - 1] = cur_line_num_temp;  \
N                                            if(conditon_true) {                                                       \
N                                                p_base ->loop_condition_buf[loop_nest_cnt - 1] = 0xFF;  \
N                                                loop_line_num_backup = cur_line_num_temp;}                              \
N                                            else {                                                                    \
N                                                p_base ->loop_condition_buf[loop_nest_cnt - 1] = 0;}                        \
N                                        }                                                                                  \
N                                        else if(p_base ->loop_line_num_buf[loop_nest_cnt - 1] == cur_line_num_temp \
N                                                && p_base ->loop_end_line_num_buf[loop_nest_cnt - 1] == cur_line_num_temp) {   \
N                                                if((p_base ->loop_condition_buf[loop_nest_cnt - 1] & 0x0F)!= 0) {   \
N                                                    p_base ->loop_condition_buf[loop_nest_cnt - 1] = 0xFF ;                \
N                                                    loop_line_num_backup = cur_line_num_temp;}                       \
N                                                else {                                                                          \
N                                                    p_base ->loop_condition_buf[loop_nest_cnt - 1] = 0 ;  }              \
N                                        }                                                                  \
N                                        else if(p_base ->loop_line_num_buf[loop_nest_cnt - 1] > cur_line_num_temp \
N                                                && p_base ->loop_end_line_num_buf[loop_nest_cnt - 1] != cur_line_num_temp) { \
N                                            p_base ->loop_condition_buf[loop_nest_cnt - 1] &= 0x0F;                    \
N                                        }                          \
N                                        else {   \
N                                        X_TASK_LOG(1,(" ---- template task %s : instance %d : loop nest error occur ; line %d ; loop_line %d , loop_end_line %d\r\n",(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,cur_line_num_temp \
N                                        ,p_base ->loop_line_num_buf[loop_nest_cnt - 1],p_base ->loop_end_line_num_buf[loop_nest_cnt - 1]));  \
N                                            p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1; \
N                                            return;}  \
N                                    }while(0);   \
N                                    if(p_base ->loop_condition_buf[loop_nest_cnt - 1] & 0xF0)
X#define T_while(conditon_true)      do{                                                                                                   cur_line_num_temp = __LINE__ ;                                            loop_nest_cnt ++;                                                                                        if((loop_nest_cnt - 1) > MAX_T_TASK_LOOP_NEST_DEEPTH)  {                                              X_TASK_LOG(1,(" ---- template task %s : instance %d : loop nest deepth(%d) beyond scope(%d) ; line %d \r\n"                                                               ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,loop_nest_cnt - 1,MAX_T_TASK_LOOP_NEST_DEEPTH,cur_line_num_temp));                                              p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1;                                             return ;                                         }                                            if (p_base ->loop_line_num_buf[loop_nest_cnt - 1] <=  cur_line_num_temp                                             && p_base ->loop_end_line_num_buf[loop_nest_cnt - 1] < cur_line_num_temp){                                              p_base ->loop_line_num_buf[loop_nest_cnt - 1] = cur_line_num_temp;                                              p_base ->loop_end_line_num_buf[loop_nest_cnt - 1] = cur_line_num_temp;                                              if(conditon_true) {                                                                                                       p_base ->loop_condition_buf[loop_nest_cnt - 1] = 0xFF;                                                  loop_line_num_backup = cur_line_num_temp;}                                                                          else {                                                                                                                    p_base ->loop_condition_buf[loop_nest_cnt - 1] = 0;}                                                                }                                                                                                                          else if(p_base ->loop_line_num_buf[loop_nest_cnt - 1] == cur_line_num_temp                                                 && p_base ->loop_end_line_num_buf[loop_nest_cnt - 1] == cur_line_num_temp) {                                                   if((p_base ->loop_condition_buf[loop_nest_cnt - 1] & 0x0F)!= 0) {                                                       p_base ->loop_condition_buf[loop_nest_cnt - 1] = 0xFF ;                                                                    loop_line_num_backup = cur_line_num_temp;}                                                                       else {                                                                                                                              p_base ->loop_condition_buf[loop_nest_cnt - 1] = 0 ;  }                                                      }                                                                                                          else if(p_base ->loop_line_num_buf[loop_nest_cnt - 1] > cur_line_num_temp                                                 && p_base ->loop_end_line_num_buf[loop_nest_cnt - 1] != cur_line_num_temp) {                                             p_base ->loop_condition_buf[loop_nest_cnt - 1] &= 0x0F;                                                            }                                                                  else {                                           X_TASK_LOG(1,(" ---- template task %s : instance %d : loop nest error occur ; line %d ; loop_line %d , loop_end_line %d\r\n",(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,cur_line_num_temp                                         ,p_base ->loop_line_num_buf[loop_nest_cnt - 1],p_base ->loop_end_line_num_buf[loop_nest_cnt - 1]));                                              p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1;                                             return;}                                      }while(0);                                       if(p_base ->loop_condition_buf[loop_nest_cnt - 1] & 0xF0)
N
N
N#define T_endloop      do{ 				                                     		\
N                            cur_line_num_temp = __LINE__ ;    \
N                            if(p_base ->loop_line_num_buf[loop_nest_cnt - 1] < cur_line_num_temp) {                                            \
N                            X_Task_if_line_pop_All(loop_nest_cnt,MAX_T_TASK_IF_NEST_DEEPTH+1,  \
N                                        &p_base ->if_line_flag_array[loop_nest_cnt][0],p_base ->if_line_num_buf);}  \
N                            loop_nest_cnt --;                                                \
N                            if(loop_nest_cnt > MAX_T_TASK_LOOP_NEST_DEEPTH)  {  \
N                            X_TASK_LOG(1,(" ---- template task %s : instance %d : end loop nest deepth(%d) beyond scope(%d) ; line %d \r\n"                   \
N                            ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,loop_nest_cnt,MAX_T_TASK_LOOP_NEST_DEEPTH,cur_line_num_temp));  \
N                            p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1; \
N                            return ; \
N                            }    \
N                            if(p_base ->cur_line_num < cur_line_num_temp)  {                \
N                                 X_Task_loop_line_pop_all(loop_nest_cnt+1,MAX_T_TASK_LOOP_NEST_DEEPTH+1,  \
N                                                            p_base ->loop_end_line_num_buf,p_base ->loop_line_num_buf);  \
N                                if ( p_base ->loop_condition_buf[loop_nest_cnt] == 0){                                     \
N                                    p_base ->loop_line_num_buf[loop_nest_cnt] = cur_line_num_temp;  \
N                                    p_base ->loop_end_line_num_buf[loop_nest_cnt] = cur_line_num_temp;          \
N                                    p_base ->cur_line_num = cur_line_num_temp;        \
N                                }                                               \
N                                else {                                                                   \
N                                    p_base ->loop_line_num_buf[loop_nest_cnt] = loop_line_num_backup;   \
N                                    p_base ->loop_end_line_num_buf[loop_nest_cnt] = 0;                                       \
N                                    p_base ->cur_line_num = loop_line_num_backup;                               \
N                                return;    }      \
N                            }         \
N                        }while(0);
X#define T_endloop      do{ 				                                     		                            cur_line_num_temp = __LINE__ ;                                if(p_base ->loop_line_num_buf[loop_nest_cnt - 1] < cur_line_num_temp) {                                                                        X_Task_if_line_pop_All(loop_nest_cnt,MAX_T_TASK_IF_NEST_DEEPTH+1,                                          &p_base ->if_line_flag_array[loop_nest_cnt][0],p_base ->if_line_num_buf);}                              loop_nest_cnt --;                                                                            if(loop_nest_cnt > MAX_T_TASK_LOOP_NEST_DEEPTH)  {                              X_TASK_LOG(1,(" ---- template task %s : instance %d : end loop nest deepth(%d) beyond scope(%d) ; line %d \r\n"                                               ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,loop_nest_cnt,MAX_T_TASK_LOOP_NEST_DEEPTH,cur_line_num_temp));                              p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1;                             return ;                             }                                if(p_base ->cur_line_num < cur_line_num_temp)  {                                                 X_Task_loop_line_pop_all(loop_nest_cnt+1,MAX_T_TASK_LOOP_NEST_DEEPTH+1,                                                              p_base ->loop_end_line_num_buf,p_base ->loop_line_num_buf);                                  if ( p_base ->loop_condition_buf[loop_nest_cnt] == 0){                                                                         p_base ->loop_line_num_buf[loop_nest_cnt] = cur_line_num_temp;                                      p_base ->loop_end_line_num_buf[loop_nest_cnt] = cur_line_num_temp;                                              p_base ->cur_line_num = cur_line_num_temp;                                        }                                                                               else {                                                                                                       p_base ->loop_line_num_buf[loop_nest_cnt] = loop_line_num_backup;                                       p_base ->loop_end_line_num_buf[loop_nest_cnt] = 0;                                                                           p_base ->cur_line_num = loop_line_num_backup;                                                               return;    }                                  }                                 }while(0);
N
N#define T_break        do{ 				                                     		\
N                            cur_line_num_temp = __LINE__ ;                              \
N                            if((loop_nest_cnt - 1) > MAX_T_TASK_LOOP_NEST_DEEPTH)  {  \
N                            X_TASK_LOG(1,(" ---- template task %s : instance %d : break nest deepth(%d) beyond scope(%d) ; line %d \r\n"                   \
N                            ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,(loop_nest_cnt - 1),MAX_T_TASK_LOOP_NEST_DEEPTH,cur_line_num_temp));  \
N                            p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1; \
N                            return ; \
N                            }    \
N                            X_Task_if_line_pop_All(loop_nest_cnt,MAX_T_TASK_IF_NEST_DEEPTH+1,  \
N                                        &p_base ->if_line_flag_array[loop_nest_cnt][0],p_base ->if_line_num_buf);  \
N                            X_Task_loop_line_pop_all(loop_nest_cnt,MAX_T_TASK_LOOP_NEST_DEEPTH+1,  \
N                                                            p_base ->loop_end_line_num_buf,p_base ->loop_line_num_buf);  \
N                            p_base ->loop_end_line_num_buf[(loop_nest_cnt - 1)] = cur_line_num_temp; \
N                            p_base ->loop_line_num_buf[(loop_nest_cnt - 1)] = cur_line_num_temp;  \
N                            p_base ->loop_condition_buf[(loop_nest_cnt - 1)] = 0;                                     \
N                            p_base ->cur_line_num = cur_line_num_temp;        \
N                            return ;                                                                          \
N                        }while(0)
X#define T_break        do{ 				                                     		                            cur_line_num_temp = __LINE__ ;                                                          if((loop_nest_cnt - 1) > MAX_T_TASK_LOOP_NEST_DEEPTH)  {                              X_TASK_LOG(1,(" ---- template task %s : instance %d : break nest deepth(%d) beyond scope(%d) ; line %d \r\n"                                               ,(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id,(loop_nest_cnt - 1),MAX_T_TASK_LOOP_NEST_DEEPTH,cur_line_num_temp));                              p_base ->cur_line_num = X_TASK_GOTO_THE_END_LINE_NUM;   p_base ->isErrorOccur = 1;                             return ;                             }                                X_Task_if_line_pop_All(loop_nest_cnt,MAX_T_TASK_IF_NEST_DEEPTH+1,                                          &p_base ->if_line_flag_array[loop_nest_cnt][0],p_base ->if_line_num_buf);                              X_Task_loop_line_pop_all(loop_nest_cnt,MAX_T_TASK_LOOP_NEST_DEEPTH+1,                                                              p_base ->loop_end_line_num_buf,p_base ->loop_line_num_buf);                              p_base ->loop_end_line_num_buf[(loop_nest_cnt - 1)] = cur_line_num_temp;                             p_base ->loop_line_num_buf[(loop_nest_cnt - 1)] = cur_line_num_temp;                              p_base ->loop_condition_buf[(loop_nest_cnt - 1)] = 0;                                                                 p_base ->cur_line_num = cur_line_num_temp;                                    return ;                                                                                                  }while(0)
N/**********************************************************************************************************************/
N
N/**********************************************************************************************************************/
N#define __T_TASK_TO_STR(y)     #y
N#define T_TASK_TO_STR(y)       __T_TASK_TO_STR(y)
N
N#define TEMPLATE_TASKS_BODY_BEGIN( t_task_id,               \
N                                    task_init_func,                     \
N                                    ext_data_struct_descrip,				  \
N									instance_num,...)            							\
N			static uint8_t CONCAT_2(t_task_id,_is_init_OK) = 0;   									\
N			static uint8_t CONCAT_2(t_task_id,_init_flag_buf)[instance_num];   			\
N			static uint8_t CONCAT_2(t_task_id,_freeze_flag_buf)[instance_num];  					\
N            typedef struct {                                                            \
N                s_T_taskCommonParam base;                                                 \
N                ext_data_struct_descrip ext_data;                                       \
N                }CONCAT_2(t_task_id,_s_all_data);                                       \
N            static CONCAT_2(t_task_id,_s_all_data)  CONCAT_2(t_task_id,_all_data_instance)[instance_num];    \
N			static s_T_taskCommonParam * const  CONCAT_2(t_task_id,_p_base_buf)[instance_num]  \
N									= T_BASE_INIT_EXPAND(CONCAT_2(t_task_id,_all_data_instance),instance_num);       \
N			static const uint8_t CONCAT_2(t_task_id,_instance_name_array)[__T_TASK_NUM_INSTANCE(__VA_ARGS__) + 1][MAX_TEMPLATE_INSTANCE_NAME_LENGTH] = {   \
N			"head",##__VA_ARGS__};				\
N			static X_Void CONCAT_2(t_task_id,_abstract_template_func)(uint32_t t_task_ms,    			\
N																uint8_t *p_isInitDone,        			\
N																s_T_taskCommonParam * p_base,       \
N                                                                uint16_t instance_id,uint8_t const * p_name);   	\
N			static const s_T_Tasks_Manager CONCAT_2(t_task_id,_T_Tasks_manager) = {   		\
N                        T_TASK_TO_STR(t_task_id),										        \
N						instance_num,                                            \
N						__T_TASK_NUM_INSTANCE(__VA_ARGS__),                     \
N                        &CONCAT_2(t_task_id,_instance_name_array)[0][0],                 \
N						&CONCAT_2(t_task_id,_is_init_OK),                           \
N						CONCAT_2(t_task_id,_init_flag_buf),                         \
N						CONCAT_2(t_task_id,_freeze_flag_buf),                       \
N						CONCAT_2(t_task_id,_abstract_template_func),                \
N						CONCAT_2(t_task_id,_p_base_buf),    \
N						};                                                                    \
N            static const s_T_Tasks_Manager * t_task_id = &CONCAT_2(t_task_id,_T_Tasks_manager);  \
N            static X_Void CONCAT_2(t_task_id,_abstract_template_func)(  uint32_t t_task_ms,             \
N                                                                        uint8_t *p_isInitDone,        			\
N																        s_T_taskCommonParam * p_base,          \
N                                                                        uint16_t instance_id,uint8_t const * p_name){               \
N                            uint32_t cur_line_num_temp = 0 ;                                                            \
N                            uint16_t nest_cnt = 0,loop_nest_cnt = 0;   uint32_t loop_line_num_backup = 0;                       \
N                            if(p_isInitDone == (uint8_t *)0 || p_base == (s_T_taskCommonParam *)0 || instance_id >= instance_num)    {                      \
N                            X_TASK_LOG(1,(" ---- template task %s :instance %d : parameter error occur \r\n",T_TASK_TO_STR(t_task_id) ,instance_id)); return; }      \
N                            CONCAT_2(t_task_id,_s_all_data) * p_all = (CONCAT_2(t_task_id,_s_all_data)*) p_base ;                    \
N                            ext_data_struct_descrip * p_this = (ext_data_struct_descrip *)&p_all ->ext_data;            \
N                            if(*p_isInitDone == 0)                                          \
N                            {                                                                                  \
N                                *p_isInitDone = 1;                                          \
N                                p_base -> cur_line_num      = 0;                                        \
N                                p_base -> ms_backup         = t_task_ms;                                           \
N                                p_base -> isErrorOccur      = 0;                                            \
N                                if((task_init_func) != (t_one_step)0) {                               \
N                                    (task_init_func)(t_task_ms,instance_id,p_name,p_this);             \
N                                }                                                                     \
N                                X_Task_ByteBufClear(p_base ->if_condition_buf,MAX_T_TASK_IF_NEST_DEEPTH + 1);           \
N                                X_Task_32bitsBufClear(p_base ->if_line_num_buf,MAX_T_TASK_IF_NEST_DEEPTH + 1);           \
N                                X_Task_ByteBufClear(p_base ->loop_condition_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);           \
N                                X_Task_32bitsBufClear(p_base ->loop_line_num_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);           \
N                                X_Task_32bitsBufClear(p_base ->loop_end_line_num_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);           \
N                                X_Task_ByteBufClear(&p_base ->if_line_flag_array[0][0],(MAX_T_TASK_LOOP_NEST_DEEPTH + 2) *(MAX_T_TASK_IF_NEST_DEEPTH + 1) );      \
N                            }                                                                                  \
N                            else if(p_base -> isErrorOccur == 0)                          
X#define TEMPLATE_TASKS_BODY_BEGIN( t_task_id,                                                   task_init_func,                                                         ext_data_struct_descrip,				  									instance_num,...)            										static uint8_t CONCAT_2(t_task_id,_is_init_OK) = 0;   												static uint8_t CONCAT_2(t_task_id,_init_flag_buf)[instance_num];   						static uint8_t CONCAT_2(t_task_id,_freeze_flag_buf)[instance_num];  					            typedef struct {                                                                            s_T_taskCommonParam base;                                                                 ext_data_struct_descrip ext_data;                                                       }CONCAT_2(t_task_id,_s_all_data);                                                   static CONCAT_2(t_task_id,_s_all_data)  CONCAT_2(t_task_id,_all_data_instance)[instance_num];    			static s_T_taskCommonParam * const  CONCAT_2(t_task_id,_p_base_buf)[instance_num]  									= T_BASE_INIT_EXPAND(CONCAT_2(t_task_id,_all_data_instance),instance_num);       			static const uint8_t CONCAT_2(t_task_id,_instance_name_array)[__T_TASK_NUM_INSTANCE(__VA_ARGS__) + 1][MAX_TEMPLATE_INSTANCE_NAME_LENGTH] = {   			"head",##__VA_ARGS__};							static X_Void CONCAT_2(t_task_id,_abstract_template_func)(uint32_t t_task_ms,    																			uint8_t *p_isInitDone,        																			s_T_taskCommonParam * p_base,                                                                       uint16_t instance_id,uint8_t const * p_name);   				static const s_T_Tasks_Manager CONCAT_2(t_task_id,_T_Tasks_manager) = {   		                        T_TASK_TO_STR(t_task_id),										        						instance_num,                                            						__T_TASK_NUM_INSTANCE(__VA_ARGS__),                                             &CONCAT_2(t_task_id,_instance_name_array)[0][0],                 						&CONCAT_2(t_task_id,_is_init_OK),                           						CONCAT_2(t_task_id,_init_flag_buf),                         						CONCAT_2(t_task_id,_freeze_flag_buf),                       						CONCAT_2(t_task_id,_abstract_template_func),                						CONCAT_2(t_task_id,_p_base_buf),    						};                                                                                static const s_T_Tasks_Manager * t_task_id = &CONCAT_2(t_task_id,_T_Tasks_manager);              static X_Void CONCAT_2(t_task_id,_abstract_template_func)(  uint32_t t_task_ms,                                                                                     uint8_t *p_isInitDone,        																			        s_T_taskCommonParam * p_base,                                                                                  uint16_t instance_id,uint8_t const * p_name){                                           uint32_t cur_line_num_temp = 0 ;                                                                                        uint16_t nest_cnt = 0,loop_nest_cnt = 0;   uint32_t loop_line_num_backup = 0;                                                   if(p_isInitDone == (uint8_t *)0 || p_base == (s_T_taskCommonParam *)0 || instance_id >= instance_num)    {                                                  X_TASK_LOG(1,(" ---- template task %s :instance %d : parameter error occur \r\n",T_TASK_TO_STR(t_task_id) ,instance_id)); return; }                                  CONCAT_2(t_task_id,_s_all_data) * p_all = (CONCAT_2(t_task_id,_s_all_data)*) p_base ;                                                ext_data_struct_descrip * p_this = (ext_data_struct_descrip *)&p_all ->ext_data;                                        if(*p_isInitDone == 0)                                                                      {                                                                                                                  *p_isInitDone = 1;                                                                          p_base -> cur_line_num      = 0;                                                                        p_base -> ms_backup         = t_task_ms;                                                                           p_base -> isErrorOccur      = 0;                                                                            if((task_init_func) != (t_one_step)0) {                                                                   (task_init_func)(t_task_ms,instance_id,p_name,p_this);                                             }                                                                                                     X_Task_ByteBufClear(p_base ->if_condition_buf,MAX_T_TASK_IF_NEST_DEEPTH + 1);                                           X_Task_32bitsBufClear(p_base ->if_line_num_buf,MAX_T_TASK_IF_NEST_DEEPTH + 1);                                           X_Task_ByteBufClear(p_base ->loop_condition_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);                                           X_Task_32bitsBufClear(p_base ->loop_line_num_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);                                           X_Task_32bitsBufClear(p_base ->loop_end_line_num_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);                                           X_Task_ByteBufClear(&p_base ->if_line_flag_array[0][0],(MAX_T_TASK_LOOP_NEST_DEEPTH + 2) *(MAX_T_TASK_IF_NEST_DEEPTH + 1) );                                  }                                                                                                              else if(p_base -> isErrorOccur == 0)                          
N                                                                        
N                                                    // T_do
N                                                    // T_wait
N                                                    // T_for 
N                                                    // T_while
N                                                    // ...
N
N#define TEMPLATE_TASKS_BODY_END          \
N                            if(p_base -> isErrorOccur == 0 && nest_cnt == 0 && loop_nest_cnt == 0) {                      \
N                                p_base ->cur_line_num = 0;                                            \
N                                X_Task_ByteBufClear(p_base ->if_condition_buf,MAX_T_TASK_IF_NEST_DEEPTH + 1);           \
N                                X_Task_32bitsBufClear(p_base ->if_line_num_buf,MAX_T_TASK_IF_NEST_DEEPTH + 1);           \
N                                X_Task_ByteBufClear(p_base ->loop_condition_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);           \
N                                X_Task_32bitsBufClear(p_base ->loop_line_num_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);           \
N                                X_Task_32bitsBufClear(p_base ->loop_end_line_num_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);           \
N                                X_Task_ByteBufClear(&p_base ->if_line_flag_array[0][0],(MAX_T_TASK_LOOP_NEST_DEEPTH + 2) *(MAX_T_TASK_IF_NEST_DEEPTH + 1) );      \
N                                UNUSED_VARIABLE(t_task_ms);                                                                                      \
N                                UNUSED_VARIABLE(loop_line_num_backup);                                              \
N                                UNUSED_VARIABLE(cur_line_num_temp);                                                     \
N                                UNUSED_VARIABLE(p_base ->ms_backup);                          \
N                            }                                                           \
N                            else if (p_base -> isErrorOccur == 1 || nest_cnt != 0 || loop_nest_cnt != 0){                                                   \
N                            X_TASK_LOG(1,(" ---- template task %s : instance %d : fatal error occur , task stop !!!\r\n",(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id));                   \
N                            p_base -> isErrorOccur = 2 ;  nest_cnt = 0;    loop_nest_cnt = 0;                      \
N                            }                                           \
N                        }                   
X#define TEMPLATE_TASKS_BODY_END                                      if(p_base -> isErrorOccur == 0 && nest_cnt == 0 && loop_nest_cnt == 0) {                                                      p_base ->cur_line_num = 0;                                                                            X_Task_ByteBufClear(p_base ->if_condition_buf,MAX_T_TASK_IF_NEST_DEEPTH + 1);                                           X_Task_32bitsBufClear(p_base ->if_line_num_buf,MAX_T_TASK_IF_NEST_DEEPTH + 1);                                           X_Task_ByteBufClear(p_base ->loop_condition_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);                                           X_Task_32bitsBufClear(p_base ->loop_line_num_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);                                           X_Task_32bitsBufClear(p_base ->loop_end_line_num_buf,MAX_T_TASK_LOOP_NEST_DEEPTH + 1);                                           X_Task_ByteBufClear(&p_base ->if_line_flag_array[0][0],(MAX_T_TASK_LOOP_NEST_DEEPTH + 2) *(MAX_T_TASK_IF_NEST_DEEPTH + 1) );                                      UNUSED_VARIABLE(t_task_ms);                                                                                                                      UNUSED_VARIABLE(loop_line_num_backup);                                                                              UNUSED_VARIABLE(cur_line_num_temp);                                                                                     UNUSED_VARIABLE(p_base ->ms_backup);                                                      }                                                                                       else if (p_base -> isErrorOccur == 1 || nest_cnt != 0 || loop_nest_cnt != 0){                                                                               X_TASK_LOG(1,(" ---- template task %s : instance %d : fatal error occur , task stop !!!\r\n",(p_name != (uint8_t*)0)? (char *)p_name : "unknow " ,instance_id));                                               p_base -> isErrorOccur = 2 ;  nest_cnt = 0;    loop_nest_cnt = 0;                                                  }                                                                   }                   
N/************************************************sth about get_time_func ************************************************************************
N typedef uint32_t (*x_get_time)(X_Void);
N 
N static x_get_time  p_get_time_func;
N p_get_time_func example:
N
Nvolatile sys_cnt_ms = 0;
N
Nvoid sys_isr(void)
N{
N    sys_cnt_ms ++;
N}
N
Nuint32_t get_sys_time(X_Void)
N{
N    uint32_t temp;
N    ENTER_CRITICAL_REGION;
N    temp = sys_cnt_ms;
N    EXIT_CRITICAL_REGION;
N    return temp;
N}
N
Nsth about CRITICAL_REGION : 
N    if(multi-core CPU)
N    {
N        not in consideration
N    }
N    else if(single core CPU)
N    {
N        if( >= 32 bits) // 32 bits variable , 32 bits register , 32bits bus width
N        {
N            no need enter CRITICAL_REGION
N        }
N        else
N        {
N            need enter CRITICAL_REGION // disable ISR , disable task switch or lock the bus 
N        }
N    }
N
N**********************************************************************************************************************/
N
N/************************************************sth about X_TASK_LOG**********************************************************************
Nchoose your X_TASK_LOG_DEBUG_METHOD  first ;
N#define USE_X_TASK_LOG  1  before release  ;
N#define X_TASK_LOG_DEBUG  1  for more detail if there is a fatal error in task ; 
N**********************************************************************************************************************/
N
N/************************************************task create sample code *******************************************************************
N
N*******************************************************************************************************************/
N
N/***************************************************careful about the "while nest if with break" situation !!!*************
Nthere still some bugs I belive ;
Ntry to use it in different occasions , and find the bugs ;
N
Nalso you could avoid using the code struct below for more security :
N
N~~~~~~~~~~~~~~~~~~~~~bad code struct example ~~~~~~~~~~~~~~~~~~~~~~~~
NX_while(condition1)
N{
N	X_if(condition1.1)
N	{
N		X_if(condition1.1.1)
N		{
N			
N		}
N		X_else
N		{
N			X_break;
N		}X_endif
N	}
N	X_else
N	{
N		
N	}X_endif
N}X_endloop
N
NX_while(condition2)
N{
N	X_if(condition2.1)
N	{
N		X_if(condition2.1.1)
N		{
N			X_do(condition2.1.1 = false);
N			X_delay(100);
N		}
N		X_else
N		{
N			X_break;
N		}X_endif
N	}
N	X_else
N	{
N		
N	}X_endif
N}X_endloop
N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Nthe "loop, if ,break" marco combination is not under full test !!!
Nhere is some suggestions when you have to use the code struct above :
N1, it is better that condition is an expression than a fucntion (try to keep the function have the same behaviour every time it is called)
N2, the code in line 177 "X_do(condition2.1.1 = false);" maybe cause the X_if flase next time ,   call it after "X_delay(100);" is better 
N3, it is better to use "X_break" in X_if rather than in X_else 
N4, do not nest too much , it seems ugly 
N5, try to use only one while loop in a task 
N*******************************************************************************************************************/
N
N/***************************************************an example to convert RTC cnt to UTC time  USE X_TASK (maybe have bugs)*************
Nstatic const uint8_t mon_table[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
NX_Boolean Is_Leap_Year(uint16_t _year)
N{                     
N	if (_year % 4 == 0) // 必须能被4整除 
N	{ 
N		if (_year % 100 == 0) 
N		{ 
N			if (_year % 400 == 0)
N			{
N				return X_True;	// 如果以00结尾,还要能被400整除 
N			}
N			else 
N			{
N				return X_False;   
N			}
N
N		}
N		else 
N		{
N			return X_True;   
N		}
N	}
N	else 
N	{
N		return X_False; 
N	}
N}      
N
Nstatic uint8_t x_month,x_day,x_hour,x_minute,x_sec;
Nstatic uint16_t x_year;
Nstatic uint32_t x_cnt = 0;
Nstatic X_Boolean isBreak = X_False;
N
N#include "../refresh_task_tag.h"
N
Nstatic 	uint32_t x_temp = 0;
Nstatic	uint16_t x_temp1 = 0;
N
NTASK_BODY_BEGIN(loop_task30,X_TASK_NULL_INIT_FUNC,1,0){
N
N	X_do(x_temp = (x_cnt / 86400));   // 得到天数 
N
N	X_do(x_temp1 = 1970);  // 从1970年开始 
N
N	X_while (x_temp >= 365)
N	{                          
N		X_if (Is_Leap_Year(x_temp1) == X_True)	// 是闰年 
N		{
N			X_if (x_temp >= 366)
N			{
N				X_do(x_temp -= 366);		// 闰年的秒钟数 
N			}
N			X_else
N			{
N				//temp1++;		// armfly: 这里闰年处理错误，不能加1 
N				X_break;
N			}X_endif  
N		}
N		X_else 
N		{
N			X_do(x_temp -= 365);       // 平年 
N		}X_endif
N		X_do(x_temp1++);  
N	}X_endloop   
N	X_do(x_year = x_temp1);	// 得到年份 
N	X_do(x_temp1 = 0);
N	X_while (x_temp >= 28)	// 超过了一个月 //
N	{
N		X_if((Is_Leap_Year(x_year) == X_True) && (x_temp1 == 1))	// 当年是不是闰年/2月份 
N		{
N			X_if (x_temp >= 29)
N			{
N				X_do(x_temp -= 29);	// 闰年的秒钟数 
N			}
N			X_else
N			{
N				X_break; 
N			}X_endif
N    }
N    X_else 
N		{
N			X_if (x_temp >= mon_table[x_temp1])//(x_temp >= mon_table[x_temp1])
N			{
N				X_delay(100);
N				X_do(x_temp -= mon_table[x_temp1]);	// 平年 
N				X_delay(10);
N			}
N			X_else 
N			{
N				X_break;
N			}X_endif
N		}X_endif
N		X_do(x_temp1++);  
N	}X_endloop
N
N	X_do(x_month = x_temp1 + 1);	// 得到月份 
N	X_do(x_day = x_temp + 1);  // 得到日期 
N
N	X_do(x_temp = x_cnt % 86400);    // 得到秒钟数 
N
N	X_do(x_hour = x_temp / 3600);	// 小时 
N
N	X_do(x_minute = (x_temp % 3600) / 60); // 分钟 
N
N	X_do(x_sec = (x_temp % 3600) % 60); // 秒钟 
N
N  X_do(freeze_task_in_schedule(30);isBreak = X_True);
N}TASK_BODY_END
N
Nstatic X_Boolean  LoopTask30Regiester(X_Void)               
N{
N  return X_TASK_REGISTE(30,loop_task30);
N}
N************************************************************************************************************************/
N#ifdef __cplusplus
S		}
N#endif
N
N#endif
L 2 "..\..\..\module\component\const_loop_scheduler\TemplateTask\template_task.c" 2
N/********************************************************************************************/
Ne_x_task_error_code t_task_init(const s_T_Tasks_Manager *p_manager)
N{
N    uint16_t i;
N    if(p_manager == (s_T_Tasks_Manager *)0) 
N    {
N        return xte_pointer_null;
N    }
N    if(p_manager ->instance_num > MAX_TEMPLATE_INSTANCE_NUM  
X    if(p_manager ->instance_num > 100  
N        || p_manager ->instance_with_name_num > MAX_TEMPLATE_INSTANCE_NUM 
X        || p_manager ->instance_with_name_num > 100 
N        || p_manager ->instance_num == 0) 
N    {
N        return xte_beyond_scope;
N    }
N    if(p_manager ->p_template_task_func == (t_task_func)0)  //X_TASK_LOG(1,(" fatal init error !!! : task list null \r\n"));
N    {
N        return xte_pointer_null;
N    }
N
N  //  fix it later : 此处可以将每个任务的task id 排序，然后依次比较，发现有相同的相邻的ID就返回 FALSE ，稍后再做
N  //  或者干脆就用枚举类型做task ID,这样就不会重复了
N    for(i=0;i<p_manager -> instance_num;i++)
N    {
N        p_manager ->p_freeze_flag_buf[i] = 0;
N        p_manager ->p_init_flag_buf[i]   = 0;
N    } 
N    
N    *p_manager ->p_is_init_ok = 1;//X_TASK_LOG(1,(" ~~~~~~ task init success ~~~~~~~ ; total task instance number %d \r\n",p_manager -> instance_num));
N    return xte_ok;
N}
N
Ne_x_task_error_code  t_task_scheduler(const s_T_Tasks_Manager *p_manager,uint32_t ms)
N{
N    uint16_t i;
N
N    if(p_manager == (s_T_Tasks_Manager *)0) 
N    {
N        return xte_pointer_null; //X_TASK_LOG(1,(" fatal scheduler error !!! : task manager pointer null \r\n"));
N    }
N    if(*p_manager ->p_is_init_ok == 0) 
N    {
N        return xte_init_failed; //X_TASK_LOG(1,(" fatal scheduler error !!! : init failed \r\n"));
N    }
N     
N    for(i=0;i<p_manager ->instance_num;i++)
N    {
N        if(p_manager ->p_freeze_flag_buf[i] == 0)
N        {
N            p_manager ->p_template_task_func(
N                ms,
N                &(p_manager ->p_init_flag_buf[i]),
N                p_manager ->p_param_buf[i],
N                i,
N                (i >= p_manager ->instance_with_name_num ) ? (uint8_t *)"noname " : &p_manager ->p_instance_name_buf[(i + 1)*MAX_TEMPLATE_INSTANCE_NAME_LENGTH]
X                (i >= p_manager ->instance_with_name_num ) ? (uint8_t *)"noname " : &p_manager ->p_instance_name_buf[(i + 1)*15]
N            );
N        }
N    }
N	return xte_ok;
N}
N
Ne_x_task_error_code freeze_t_task(const s_T_Tasks_Manager *p_manager,uint16_t instance_id)
N{
N    if(p_manager == (s_T_Tasks_Manager *)0) 
N    {
N        return xte_pointer_null; //X_TASK_LOG(1,(" fatal freeze error !!! : task manager pointer null \r\n"));
N    }
N    if(*p_manager ->p_is_init_ok == 0) 
N    {
N        return xte_init_failed; //X_TASK_LOG(1,(" fatal freeze error !!! : init failed \r\n"));
N    }
N
N    if(instance_id >= p_manager ->instance_num)
N    {
N        return xte_beyond_scope;
N    }
N
N    p_manager ->p_freeze_flag_buf[instance_id] = 1;
N
N    return xte_ok;
N}
Ne_x_task_error_code unfreeze_t_task(const s_T_Tasks_Manager *p_manager,uint16_t instance_id)
N{
N    if(p_manager == (s_T_Tasks_Manager *)0) 
N    {
N        return xte_pointer_null; //X_TASK_LOG(1,(" fatal unfreeze error !!! : task manager pointer null \r\n"));
N    }
N    if(*p_manager ->p_is_init_ok == 0) 
N    {
N        return xte_init_failed; // X_TASK_LOG(1,(" fatal unfreeze error !!! : init failed \r\n"));
N    }
N
N    if(instance_id >= p_manager ->instance_num)
N    {
N        return xte_beyond_scope;
N    }
N
N    p_manager ->p_freeze_flag_buf[instance_id] = 0;
N
N    return xte_ok;
N}
Ne_x_task_error_code restart_t_task(const s_T_Tasks_Manager *p_manager,uint16_t instance_id)
N{
N    if(p_manager == (s_T_Tasks_Manager *)0) 
N    {
N        return xte_pointer_null;   ////////X_TASK_LOG(1,(" fatal restart error !!! : task manager pointer null \r\n"));
N    }
N    if(*p_manager ->p_is_init_ok == 0) 
N    {
N        return xte_init_failed;  /////////X_TASK_LOG(1,(" fatal restart error !!! : init failed \r\n"));
N    }
N
N    if(instance_id >= p_manager ->instance_num)
N    {
N        return xte_beyond_scope;
N    }
N
N    p_manager ->p_freeze_flag_buf[instance_id] = 0;
N    p_manager ->p_init_flag_buf[instance_id] = 0;
N
N    return  xte_ok;
N}
