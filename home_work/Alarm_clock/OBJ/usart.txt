; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\usart.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\usart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\HARDWARE\LED -I..\HARDWARE\LCD -I..\HARDWARE\KEY -I..\HARDWARE\SRAM -I..\HARDWARE\SDIO -I..\MALLOC -I..\USMART -I..\HARDWARE\SPI -I..\HARDWARE\W25QXX -I..\FATFS\exfuns -I..\FATFS\src -I..\TEXT -I..\FWLIB\inc -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\I2S -I..\HARDWARE\WM8978 -I..\APP -I..\AUDIOCODEC\wav -I..\new_user -I..\new_user\task -I..\new_user\MVC -I..\..\..\module\common -I..\..\..\module\common\InsertLog -I..\..\..\module\common\loopqueue -I..\..\..\module\common\StateMachine -I..\..\..\module\common\priorityqueue -I..\..\..\module\common\Math -I..\..\..\module\component\const_loop_scheduler -I..\..\..\module\component\const_loop_scheduler\TemplateTask -I..\..\..\module\component\const_loop_scheduler\HierarchicalSM -I..\..\..\module\component\BlockableStateMachine -I..\..\..\module\customize\ButtonModule -I..\..\..\module\external\Segger\SEGGER_RTT_V640\Syscalls -I..\..\..\module\external\Segger\SEGGER_RTT_V640\RTT -I.\RTE\_AudioPlayer -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include" -I"D:\Program Files\ARM\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_COMPILER_PRESENT -DX_TASK_LOG_DEBUG_METHOD=SeggerRTT_LogDebug --omf_browse=..\obj\usart.crf ..\SYSTEM\usart\usart.c]
                          THUMB

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;121    
;;;122    void USART1_IRQHandler(void)                	//串口1中断服务程序
000000  b510              PUSH     {r4,lr}
;;;123    {
;;;124    	u8 Res;
;;;125    #if SYSTEM_SUPPORT_OS 		//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
;;;126    	OSIntEnter();    
;;;127    #endif
;;;128    	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
000002  f2405125          MOV      r1,#0x525
000006  481d              LDR      r0,|L1.124|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b310              CBZ      r0,|L1.84|
;;;129    	{
;;;130    		Res =USART_ReceiveData(USART1);//(USART1->DR);	//读取接收到的数据
00000e  481b              LDR      r0,|L1.124|
000010  f7fffffe          BL       USART_ReceiveData
000014  b2c4              UXTB     r4,r0
;;;131    		
;;;132    		if((USART_RX_STA&0x8000)==0)//接收未完成
000016  481a              LDR      r0,|L1.128|
000018  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00001a  f4004000          AND      r0,r0,#0x8000
00001e  b9c8              CBNZ     r0,|L1.84|
;;;133    		{
;;;134    			if(USART_RX_STA&0x4000)//接收到了0x0d
000020  4817              LDR      r0,|L1.128|
000022  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000024  f4004080          AND      r0,r0,#0x4000
000028  b160              CBZ      r0,|L1.68|
;;;135    			{
;;;136    				if(Res!=0x0a)USART_RX_STA=0;//接收错误,重新开始
00002a  2c0a              CMP      r4,#0xa
00002c  d003              BEQ      |L1.54|
00002e  2000              MOVS     r0,#0
000030  4913              LDR      r1,|L1.128|
000032  8008              STRH     r0,[r1,#0]
000034  e020              B        |L1.120|
                  |L1.54|
;;;137    				else USART_RX_STA|=0x8000;	//接收完成了 
000036  4812              LDR      r0,|L1.128|
000038  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00003a  f4404000          ORR      r0,r0,#0x8000
00003e  4910              LDR      r1,|L1.128|
000040  8008              STRH     r0,[r1,#0]
000042  e019              B        |L1.120|
                  |L1.68|
;;;138    			}
;;;139    			else //还没收到0X0D
;;;140    			{	
;;;141    				if(Res==0x0d)USART_RX_STA|=0x4000;
000044  2c0d              CMP      r4,#0xd
000046  d106              BNE      |L1.86|
000048  480d              LDR      r0,|L1.128|
00004a  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00004c  f4404080          ORR      r0,r0,#0x4000
000050  490b              LDR      r1,|L1.128|
000052  8008              STRH     r0,[r1,#0]
                  |L1.84|
000054  e010              B        |L1.120|
                  |L1.86|
;;;142    				else
;;;143    				{
;;;144    					USART_RX_BUF[USART_RX_STA&0X3FFF]=Res ;
000056  480a              LDR      r0,|L1.128|
000058  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00005a  f3c0000d          UBFX     r0,r0,#0,#14
00005e  4909              LDR      r1,|L1.132|
000060  540c              STRB     r4,[r1,r0]
;;;145    					USART_RX_STA++;
000062  4807              LDR      r0,|L1.128|
000064  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000066  1c40              ADDS     r0,r0,#1
000068  4905              LDR      r1,|L1.128|
00006a  8008              STRH     r0,[r1,#0]
;;;146    					if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收	  
00006c  4608              MOV      r0,r1
00006e  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000070  28c7              CMP      r0,#0xc7
000072  dd01              BLE      |L1.120|
000074  2000              MOVS     r0,#0
000076  8008              STRH     r0,[r1,#0]
                  |L1.120|
;;;147    				}		 
;;;148    			}
;;;149    		}   		 
;;;150      } 
;;;151    #if SYSTEM_SUPPORT_OS 	//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.
;;;152    	OSIntExit();  											 
;;;153    #endif
;;;154    } 
000078  bd10              POP      {r4,pc}
;;;155    #endif	
                          ENDP

00007a  0000              DCW      0x0000
                  |L1.124|
                          DCD      0x40011000
                  |L1.128|
                          DCD      USART_RX_STA
                  |L1.132|
                          DCD      USART_RX_BUF

                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;72     //bound:波特率
;;;73     void uart_init(u32 bound){
000000  b510              PUSH     {r4,lr}
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;74        //GPIO端口设置
;;;75       GPIO_InitTypeDef GPIO_InitStructure;
;;;76     	USART_InitTypeDef USART_InitStructure;
;;;77     	NVIC_InitTypeDef NVIC_InitStructure;
;;;78     	
;;;79     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE); //使能GPIOA时钟
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;80     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);//使能USART1时钟
00000e  2101              MOVS     r1,#1
000010  2010              MOVS     r0,#0x10
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;81      
;;;82     	//串口1对应引脚复用映射
;;;83     	GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_USART1); //GPIOA9复用为USART1
000016  2207              MOVS     r2,#7
000018  2109              MOVS     r1,#9
00001a  4822              LDR      r0,|L2.164|
00001c  f7fffffe          BL       GPIO_PinAFConfig
;;;84     	GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_USART1); //GPIOA10复用为USART1
000020  2207              MOVS     r2,#7
000022  210a              MOVS     r1,#0xa
000024  481f              LDR      r0,|L2.164|
000026  f7fffffe          BL       GPIO_PinAFConfig
;;;85     	
;;;86     	//USART1端口配置
;;;87       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10; //GPIOA9与GPIOA10
00002a  f44f60c0          MOV      r0,#0x600
00002e  9006              STR      r0,[sp,#0x18]
;;;88     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
000030  2002              MOVS     r0,#2
000032  f88d001c          STRB     r0,[sp,#0x1c]
;;;89     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	//速度50MHz
000036  f88d001d          STRB     r0,[sp,#0x1d]
;;;90     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; //推挽复用输出
00003a  2000              MOVS     r0,#0
00003c  f88d001e          STRB     r0,[sp,#0x1e]
;;;91     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; //上拉
000040  2001              MOVS     r0,#1
000042  f88d001f          STRB     r0,[sp,#0x1f]
;;;92     	GPIO_Init(GPIOA,&GPIO_InitStructure); //初始化PA9，PA10
000046  a906              ADD      r1,sp,#0x18
000048  4816              LDR      r0,|L2.164|
00004a  f7fffffe          BL       GPIO_Init
;;;93     
;;;94        //USART1 初始化设置
;;;95     	USART_InitStructure.USART_BaudRate = bound;//波特率设置
00004e  9402              STR      r4,[sp,#8]
;;;96     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
000050  2000              MOVS     r0,#0
000052  f8ad000c          STRH     r0,[sp,#0xc]
;;;97     	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
000056  f8ad000e          STRH     r0,[sp,#0xe]
;;;98     	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
00005a  f8ad0010          STRH     r0,[sp,#0x10]
;;;99     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
00005e  f8ad0014          STRH     r0,[sp,#0x14]
;;;100    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000062  200c              MOVS     r0,#0xc
000064  f8ad0012          STRH     r0,[sp,#0x12]
;;;101      USART_Init(USART1, &USART_InitStructure); //初始化串口1
000068  a902              ADD      r1,sp,#8
00006a  480f              LDR      r0,|L2.168|
00006c  f7fffffe          BL       USART_Init
;;;102    	
;;;103      USART_Cmd(USART1, ENABLE);  //使能串口1 
000070  2101              MOVS     r1,#1
000072  480d              LDR      r0,|L2.168|
000074  f7fffffe          BL       USART_Cmd
;;;104    	
;;;105    	//USART_ClearFlag(USART1, USART_FLAG_TC);
;;;106    	
;;;107    #if EN_USART1_RX	
;;;108    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启相关中断
000078  2201              MOVS     r2,#1
00007a  f2405125          MOV      r1,#0x525
00007e  480a              LDR      r0,|L2.168|
000080  f7fffffe          BL       USART_ITConfig
;;;109    
;;;110    	//Usart1 NVIC 配置
;;;111      NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;//串口1中断通道
000084  2025              MOVS     r0,#0x25
000086  f88d0004          STRB     r0,[sp,#4]
;;;112    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3;//抢占优先级3
00008a  2003              MOVS     r0,#3
00008c  f88d0005          STRB     r0,[sp,#5]
;;;113    	NVIC_InitStructure.NVIC_IRQChannelSubPriority =3;		//子优先级3
000090  f88d0006          STRB     r0,[sp,#6]
;;;114    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
000094  2001              MOVS     r0,#1
000096  f88d0007          STRB     r0,[sp,#7]
;;;115    	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器、
00009a  a801              ADD      r0,sp,#4
00009c  f7fffffe          BL       NVIC_Init
;;;116    
;;;117    #endif
;;;118    	
;;;119    }
0000a0  b008              ADD      sp,sp,#0x20
0000a2  bd10              POP      {r4,pc}
;;;120    
                          ENDP

                  |L2.164|
                          DCD      0x40020000
                  |L2.168|
                          DCD      0x40011000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=1

                  USART_RX_STA
000000  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\usart\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_7cc17ae7____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___7_usart_c_7cc17ae7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_7cc17ae7____REVSH|
#line 144
|__asm___7_usart_c_7cc17ae7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
