; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\wavplay.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\wavplay.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\HARDWARE\LED -I..\HARDWARE\LCD -I..\HARDWARE\KEY -I..\HARDWARE\SRAM -I..\HARDWARE\SDIO -I..\MALLOC -I..\USMART -I..\HARDWARE\SPI -I..\HARDWARE\W25QXX -I..\FATFS\exfuns -I..\FATFS\src -I..\TEXT -I..\FWLIB\inc -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\I2S -I..\HARDWARE\WM8978 -I..\APP -I..\AUDIOCODEC\wav -I..\new_user -I..\new_user\task -I..\new_user\MVC -I..\..\..\module\common -I..\..\..\module\common\InsertLog -I..\..\..\module\common\loopqueue -I..\..\..\module\common\StateMachine -I..\..\..\module\common\priorityqueue -I..\..\..\module\common\Math -I..\..\..\module\component\const_loop_scheduler -I..\..\..\module\component\const_loop_scheduler\TemplateTask -I..\..\..\module\component\const_loop_scheduler\HierarchicalSM -I..\..\..\module\component\BlockableStateMachine -I..\..\..\module\customize\ButtonModule -I..\..\..\module\external\Segger\SEGGER_RTT_V640\Syscalls -I..\..\..\module\external\Segger\SEGGER_RTT_V640\RTT -I.\RTE\_AudioPlayer -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include" -I"D:\Program Files\ARM\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_COMPILER_PRESENT -DX_TASK_LOG_DEBUG_METHOD=SeggerRTT_LogDebug --omf_browse=..\obj\wavplay.crf ..\AUDIOCODEC\wav\wavplay.c]
                          THUMB

                          AREA ||i.wav_buffill||, CODE, READONLY, ALIGN=2

                  wav_buffill PROC
;;;98     //返回值:读到的数据个数
;;;99     u32 wav_buffill(u8 *buf,u16 size,u8 bits)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;100    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;101    	u16 readlen=0;
00000a  f04f0900          MOV      r9,#0
;;;102    	u32 bread;
;;;103    	u16 i;
;;;104    	u8 *p;
;;;105    	if(bits==24)//24bit音频,需要处理一下
00000e  f1b80f18          CMP      r8,#0x18
000012  d12b              BNE      |L1.108|
;;;106    	{
;;;107    		readlen=(size/4)*3;							//此次要读取的字节数
000014  4628              MOV      r0,r5
000016  17e9              ASRS     r1,r5,#31
000018  eb057191          ADD      r1,r5,r1,LSR #30
00001c  1089              ASRS     r1,r1,#2
00001e  eb010141          ADD      r1,r1,r1,LSL #1
000022  fa1ff981          UXTH     r9,r1
;;;108    		f_read(audiodev.file,audiodev.tbuf,readlen,(UINT*)&bread);	//读取数据
000026  4a1d              LDR      r2,|L1.156|
000028  6891              LDR      r1,[r2,#8]  ; audiodev
00002a  68d0              LDR      r0,[r2,#0xc]  ; audiodev
00002c  466b              MOV      r3,sp
00002e  464a              MOV      r2,r9
000030  f7fffffe          BL       f_read
;;;109    		p=audiodev.tbuf;
000034  4819              LDR      r0,|L1.156|
000036  6887              LDR      r7,[r0,#8]  ; audiodev
;;;110    		for(i=0;i<size;)
000038  2400              MOVS     r4,#0
00003a  e00e              B        |L1.90|
                  |L1.60|
;;;111    		{
;;;112    			buf[i++]=p[1];
00003c  787a              LDRB     r2,[r7,#1]
00003e  4620              MOV      r0,r4
000040  1c61              ADDS     r1,r4,#1
000042  b28c              UXTH     r4,r1
000044  5432              STRB     r2,[r6,r0]
;;;113    			buf[i]=p[2]; 
000046  78b8              LDRB     r0,[r7,#2]
000048  5530              STRB     r0,[r6,r4]
;;;114    			i+=2;
00004a  1ca0              ADDS     r0,r4,#2
00004c  b284              UXTH     r4,r0
;;;115    			buf[i++]=p[0];
00004e  783a              LDRB     r2,[r7,#0]
000050  4620              MOV      r0,r4
000052  1c61              ADDS     r1,r4,#1
000054  b28c              UXTH     r4,r1
000056  5432              STRB     r2,[r6,r0]
;;;116    			p+=3;
000058  1cff              ADDS     r7,r7,#3
                  |L1.90|
00005a  42ac              CMP      r4,r5                 ;110
00005c  dbee              BLT      |L1.60|
;;;117    		} 
;;;118    		bread=(bread*4)/3;		//填充后的大小.
00005e  9800              LDR      r0,[sp,#0]
000060  0080              LSLS     r0,r0,#2
000062  2103              MOVS     r1,#3
000064  fbb0f0f1          UDIV     r0,r0,r1
000068  9000              STR      r0,[sp,#0]
00006a  e014              B        |L1.150|
                  |L1.108|
;;;119    	}else 
;;;120    	{
;;;121    		f_read(audiodev.file,buf,size,(UINT*)&bread);//16bit音频,直接读取数据  
00006c  490b              LDR      r1,|L1.156|
00006e  68c8              LDR      r0,[r1,#0xc]  ; audiodev
000070  466b              MOV      r3,sp
000072  462a              MOV      r2,r5
000074  4631              MOV      r1,r6
000076  f7fffffe          BL       f_read
;;;122    		if(bread<size)//不够数据了,补充0
00007a  9800              LDR      r0,[sp,#0]
00007c  42a8              CMP      r0,r5
00007e  d20a              BCS      |L1.150|
;;;123    		{
;;;124    			for(i=bread;i<size-bread;i++)buf[i]=0; 
000080  9800              LDR      r0,[sp,#0]
000082  b284              UXTH     r4,r0
000084  e003              B        |L1.142|
                  |L1.134|
000086  2000              MOVS     r0,#0
000088  5530              STRB     r0,[r6,r4]
00008a  1c60              ADDS     r0,r4,#1
00008c  b284              UXTH     r4,r0
                  |L1.142|
00008e  9800              LDR      r0,[sp,#0]
000090  1a28              SUBS     r0,r5,r0
000092  42a0              CMP      r0,r4
000094  d8f7              BHI      |L1.134|
                  |L1.150|
;;;125    		}
;;;126    	}
;;;127    	return bread;
000096  9800              LDR      r0,[sp,#0]
;;;128    }  
000098  e8bd83f8          POP      {r3-r9,pc}
;;;129    //WAV播放时,I2S DMA传输回调函数
                          ENDP

                  |L1.156|
                          DCD      audiodev

                          AREA ||i.wav_decode_init||, CODE, READONLY, ALIGN=2

                  wav_decode_init PROC
;;;35     //返回值:0,成功;1,打开文件失败;2,非WAV文件;3,DATA区域未找到.
;;;36     u8 wav_decode_init(u8* fname,__wavctrl* wavx)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;37     {
000004  4682              MOV      r10,r0
000006  460c              MOV      r4,r1
;;;38     	FIL*ftemp;
;;;39     	u8 *buf; 
;;;40     	u32 br=0;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
;;;41     	u8 res=0;
00000c  9000              STR      r0,[sp,#0]
;;;42     	
;;;43     	ChunkRIFF *riff;
;;;44     	ChunkFMT *fmt;
;;;45     	ChunkFACT *fact;
;;;46     	ChunkDATA *data;
;;;47     	ftemp=(FIL*)mymalloc(SRAMIN,sizeof(FIL));
00000e  f44f710a          MOV      r1,#0x228
000012  f7fffffe          BL       mymalloc
000016  4680              MOV      r8,r0
;;;48     	buf=mymalloc(SRAMIN,512);
000018  f44f7100          MOV      r1,#0x200
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       mymalloc
000022  4606              MOV      r6,r0
;;;49     	if(ftemp&&buf)	//内存申请成功
000024  f1b80f00          CMP      r8,#0
000028  d056              BEQ      |L2.216|
00002a  2e00              CMP      r6,#0
00002c  d054              BEQ      |L2.216|
;;;50     	{
;;;51     		res=f_open(ftemp,(TCHAR*)fname,FA_READ);//打开文件
00002e  2201              MOVS     r2,#1
000030  4651              MOV      r1,r10
000032  4640              MOV      r0,r8
000034  f7fffffe          BL       f_open
000038  9000              STR      r0,[sp,#0]
;;;52     		if(res==FR_OK)
00003a  9800              LDR      r0,[sp,#0]
00003c  2800              CMP      r0,#0
00003e  d149              BNE      |L2.212|
;;;53     		{
;;;54     			f_read(ftemp,buf,512,&br);	//读取512字节在数据
000040  ab01              ADD      r3,sp,#4
000042  f44f7200          MOV      r2,#0x200
000046  4631              MOV      r1,r6
000048  4640              MOV      r0,r8
00004a  f7fffffe          BL       f_read
;;;55     			riff=(ChunkRIFF *)buf;		//获取RIFF块
00004e  46b3              MOV      r11,r6
;;;56     			if(riff->Format==0X45564157)//是WAV文件
000050  465e              MOV      r6,r11
000052  f8db0008          LDR      r0,[r11,#8]
000056  4927              LDR      r1,|L2.244|
000058  4288              CMP      r0,r1
00005a  d138              BNE      |L2.206|
;;;57     			{
;;;58     				fmt=(ChunkFMT *)(buf+12);	//获取FMT块 
00005c  f106050c          ADD      r5,r6,#0xc
;;;59     				fact=(ChunkFACT *)(buf+12+8+fmt->ChunkSize);//读取FACT块
000060  6869              LDR      r1,[r5,#4]
000062  f1060014          ADD      r0,r6,#0x14
000066  180f              ADDS     r7,r1,r0
;;;60     				if(fact->ChunkID==0X74636166||fact->ChunkID==0X5453494C)wavx->datastart=12+8+fmt->ChunkSize+8+fact->ChunkSize;//具有fact/LIST块的时候(未测试)
000068  6838              LDR      r0,[r7,#0]
00006a  4923              LDR      r1,|L2.248|
00006c  4288              CMP      r0,r1
00006e  d003              BEQ      |L2.120|
000070  6838              LDR      r0,[r7,#0]
000072  4922              LDR      r1,|L2.252|
000074  4288              CMP      r0,r1
000076  d105              BNE      |L2.132|
                  |L2.120|
000078  6868              LDR      r0,[r5,#4]
00007a  301c              ADDS     r0,r0,#0x1c
00007c  6879              LDR      r1,[r7,#4]
00007e  4408              ADD      r0,r0,r1
000080  61e0              STR      r0,[r4,#0x1c]
000082  e002              B        |L2.138|
                  |L2.132|
;;;61     				else wavx->datastart=12+8+fmt->ChunkSize;  
000084  6868              LDR      r0,[r5,#4]
000086  3014              ADDS     r0,r0,#0x14
000088  61e0              STR      r0,[r4,#0x1c]
                  |L2.138|
;;;62     				data=(ChunkDATA *)(buf+wavx->datastart);	//读取DATA块
00008a  69e0              LDR      r0,[r4,#0x1c]
00008c  eb000906          ADD      r9,r0,r6
;;;63     				if(data->ChunkID==0X61746164)//解析成功!
000090  f8d90000          LDR      r0,[r9,#0]
000094  491a              LDR      r1,|L2.256|
000096  4288              CMP      r0,r1
000098  d116              BNE      |L2.200|
;;;64     				{
;;;65     					wavx->audioformat=fmt->AudioFormat;		//音频格式
00009a  8928              LDRH     r0,[r5,#8]
00009c  8020              STRH     r0,[r4,#0]
;;;66     					wavx->nchannels=fmt->NumOfChannels;		//通道数
00009e  8968              LDRH     r0,[r5,#0xa]
0000a0  8060              STRH     r0,[r4,#2]
;;;67     					wavx->samplerate=fmt->SampleRate;		//采样率
0000a2  68e8              LDR      r0,[r5,#0xc]
0000a4  f8c40016          STR      r0,[r4,#0x16]
;;;68     					wavx->bitrate=fmt->ByteRate*8;			//得到位速
0000a8  6928              LDR      r0,[r5,#0x10]
0000aa  00c0              LSLS     r0,r0,#3
0000ac  f8c40012          STR      r0,[r4,#0x12]
;;;69     					wavx->blockalign=fmt->BlockAlign;		//块对齐
0000b0  8aa8              LDRH     r0,[r5,#0x14]
0000b2  80a0              STRH     r0,[r4,#4]
;;;70     					wavx->bps=fmt->BitsPerSample;			//位数,16/24/32位
0000b4  8ae8              LDRH     r0,[r5,#0x16]
0000b6  8360              STRH     r0,[r4,#0x1a]
;;;71     					
;;;72     					wavx->datasize=data->ChunkSize;			//数据块大小
0000b8  f8d90004          LDR      r0,[r9,#4]
0000bc  f8c40006          STR      r0,[r4,#6]
;;;73     					wavx->datastart=wavx->datastart+8;		//数据流开始的地方. 
0000c0  69e0              LDR      r0,[r4,#0x1c]
0000c2  3008              ADDS     r0,r0,#8
0000c4  61e0              STR      r0,[r4,#0x1c]
0000c6  e007              B        |L2.216|
                  |L2.200|
;;;74     					 
;;;75     ////////					printf("wavx->audioformat:%d\r\n",wavx->audioformat);
;;;76     ////////					printf("wavx->nchannels:%d\r\n",wavx->nchannels);
;;;77     ////////					printf("wavx->samplerate:%d\r\n",wavx->samplerate);
;;;78     ////////					printf("wavx->bitrate:%d\r\n",wavx->bitrate);
;;;79     ////////					printf("wavx->blockalign:%d\r\n",wavx->blockalign);
;;;80     ////////					printf("wavx->bps:%d\r\n",wavx->bps);
;;;81     ////////					printf("wavx->datasize:%d\r\n",wavx->datasize);
;;;82     ////////					printf("wavx->datastart:%d\r\n",wavx->datastart);  
;;;83     				}else res=3;//data区域未找到.
0000c8  2003              MOVS     r0,#3
0000ca  9000              STR      r0,[sp,#0]
0000cc  e004              B        |L2.216|
                  |L2.206|
;;;84     			}else res=2;//非wav文件
0000ce  2002              MOVS     r0,#2
0000d0  9000              STR      r0,[sp,#0]
0000d2  e001              B        |L2.216|
                  |L2.212|
;;;85     			
;;;86     		}else res=1;//打开文件错误
0000d4  2001              MOVS     r0,#1
0000d6  9000              STR      r0,[sp,#0]
                  |L2.216|
;;;87     	}
;;;88     	f_close(ftemp);
0000d8  4640              MOV      r0,r8
0000da  f7fffffe          BL       f_close
;;;89     	myfree(SRAMIN,ftemp);//释放内存
0000de  4641              MOV      r1,r8
0000e0  2000              MOVS     r0,#0
0000e2  f7fffffe          BL       myfree
;;;90     	myfree(SRAMIN,buf); 
0000e6  4631              MOV      r1,r6
0000e8  2000              MOVS     r0,#0
0000ea  f7fffffe          BL       myfree
;;;91     	return 0;
0000ee  2000              MOVS     r0,#0
;;;92     }
0000f0  e8bd9ffc          POP      {r2-r12,pc}
;;;93     
                          ENDP

                  |L2.244|
                          DCD      0x45564157
                  |L2.248|
                          DCD      0x74636166
                  |L2.252|
                          DCD      0x5453494c
                  |L2.256|
                          DCD      0x61746164

                          AREA ||i.wav_get_curtime||, CODE, READONLY, ALIGN=1

                  wav_get_curtime PROC
;;;158    //wavx:wav播放控制器
;;;159    void wav_get_curtime(FIL*fx,__wavctrl *wavx)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;160    {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
;;;161    	long long fpos;  	
;;;162     	wavx->totsec=wavx->datasize/(wavx->bitrate/8);	//歌曲总长度(单位:秒) 
000008  f8540f06          LDR      r0,[r4,#6]!
00000c  68e1              LDR      r1,[r4,#0xc]
00000e  08c9              LSRS     r1,r1,#3
000010  fbb0f0f1          UDIV     r0,r0,r1
000014  6060              STR      r0,[r4,#4]
;;;163    	fpos=fx->fptr-wavx->datastart; 					//得到当前文件播放到的地方 
000016  f8d90008          LDR      r0,[r9,#8]
00001a  f8d41016          LDR      r1,[r4,#0x16]
00001e  1a45              SUBS     r5,r0,r1
000020  2600              MOVS     r6,#0
;;;164    	wavx->cursec=fpos*wavx->totsec/wavx->datasize;	//当前播放到第多少秒了?	
000022  f8d4c000          LDR      r12,[r4,#0]
000026  6860              LDR      r0,[r4,#4]
000028  2100              MOVS     r1,#0
00002a  462a              MOV      r2,r5
00002c  fba07b02          UMULL    r7,r11,r0,r2
000030  fb01b105          MLA      r1,r1,r5,r11
000034  fb001106          MLA      r1,r0,r6,r1
000038  4662              MOV      r2,r12
00003a  2300              MOVS     r3,#0
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       __aeabi_ldivmod
000042  60a0              STR      r0,[r4,#8]
000044  1fa4              SUBS     r4,r4,#6
;;;165    }
000046  e8bd9ff0          POP      {r4-r12,pc}
;;;166    //播放某个WAV文件
                          ENDP


                          AREA ||i.wav_i2s_dma_tx_callback||, CODE, READONLY, ALIGN=2

                  wav_i2s_dma_tx_callback PROC
;;;129    //WAV播放时,I2S DMA传输回调函数
;;;130    void wav_i2s_dma_tx_callback(void) 
000000  4917              LDR      r1,|L4.96|
;;;131    {   
;;;132    	u16 i;
;;;133    	if(DMA1_Stream4->CR&(1<<19))
000002  6f09              LDR      r1,[r1,#0x70]
000004  f4012100          AND      r1,r1,#0x80000
000008  b199              CBZ      r1,|L4.50|
;;;134    	{
;;;135    		wavwitchbuf=0;
00000a  2100              MOVS     r1,#0
00000c  4a15              LDR      r2,|L4.100|
00000e  7011              STRB     r1,[r2,#0]
;;;136    		if((audiodev.status&0X01)==0)
000010  4915              LDR      r1,|L4.104|
000012  7c09              LDRB     r1,[r1,#0x10]  ; audiodev
000014  f0010101          AND      r1,r1,#1
000018  b9f1              CBNZ     r1,|L4.88|
;;;137    		{
;;;138    			for(i=0;i<WAV_I2S_TX_DMA_BUFSIZE;i++)//暂停
00001a  2000              MOVS     r0,#0
00001c  e005              B        |L4.42|
                  |L4.30|
;;;139    			{
;;;140    				audiodev.i2sbuf1[i]=0;//填充0
00001e  2100              MOVS     r1,#0
000020  4a11              LDR      r2,|L4.104|
000022  6812              LDR      r2,[r2,#0]  ; audiodev
000024  5411              STRB     r1,[r2,r0]
000026  1c41              ADDS     r1,r0,#1              ;138
000028  b288              UXTH     r0,r1                 ;138
                  |L4.42|
00002a  f5b05f00          CMP      r0,#0x2000            ;138
00002e  dbf6              BLT      |L4.30|
000030  e012              B        |L4.88|
                  |L4.50|
;;;141    			}
;;;142    		}
;;;143    	}else 
;;;144    	{
;;;145    		wavwitchbuf=1;
000032  2101              MOVS     r1,#1
000034  4a0b              LDR      r2,|L4.100|
000036  7011              STRB     r1,[r2,#0]
;;;146    		if((audiodev.status&0X01)==0)
000038  490b              LDR      r1,|L4.104|
00003a  7c09              LDRB     r1,[r1,#0x10]  ; audiodev
00003c  f0010101          AND      r1,r1,#1
000040  b951              CBNZ     r1,|L4.88|
;;;147    		{
;;;148    			for(i=0;i<WAV_I2S_TX_DMA_BUFSIZE;i++)//暂停
000042  2000              MOVS     r0,#0
000044  e005              B        |L4.82|
                  |L4.70|
;;;149    			{
;;;150    				audiodev.i2sbuf2[i]=0;//填充0
000046  2100              MOVS     r1,#0
000048  4a07              LDR      r2,|L4.104|
00004a  6852              LDR      r2,[r2,#4]  ; audiodev
00004c  5411              STRB     r1,[r2,r0]
00004e  1c41              ADDS     r1,r0,#1              ;148
000050  b288              UXTH     r0,r1                 ;148
                  |L4.82|
000052  f5b05f00          CMP      r0,#0x2000            ;148
000056  dbf6              BLT      |L4.70|
                  |L4.88|
;;;151    			}
;;;152    		}
;;;153    	}
;;;154    	wavtransferend=1;
000058  2101              MOVS     r1,#1
00005a  4a04              LDR      r2,|L4.108|
00005c  7011              STRB     r1,[r2,#0]
;;;155    } 
00005e  4770              BX       lr
;;;156    //得到当前播放时间
                          ENDP

                  |L4.96|
                          DCD      0x40026000
                  |L4.100|
                          DCD      wavwitchbuf
                  |L4.104|
                          DCD      audiodev
                  |L4.108|
                          DCD      wavtransferend

                          AREA ||i.wav_play_song||, CODE, READONLY, ALIGN=2

                  wav_play_song PROC
;;;171    //其他:错误
;;;172    u8 wav_play_song(u8* fname)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;173    {
000004  4606              MOV      r6,r0
;;;174    	u8 key;
;;;175    	u8 t=0; 
000006  2700              MOVS     r7,#0
;;;176    	u8 res;  
;;;177    	u32 fillnum; 
;;;178    	audiodev.file=(FIL*)mymalloc(SRAMIN,sizeof(FIL));
000008  f44f710a          MOV      r1,#0x228
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       mymalloc
000012  4987              LDR      r1,|L5.560|
000014  60c8              STR      r0,[r1,#0xc]  ; audiodev
;;;179    	audiodev.i2sbuf1=mymalloc(SRAMIN,WAV_I2S_TX_DMA_BUFSIZE);
000016  f44f5100          MOV      r1,#0x2000
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       mymalloc
000020  4983              LDR      r1,|L5.560|
000022  6008              STR      r0,[r1,#0]  ; audiodev
;;;180    	audiodev.i2sbuf2=mymalloc(SRAMIN,WAV_I2S_TX_DMA_BUFSIZE);
000024  f44f5100          MOV      r1,#0x2000
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       mymalloc
00002e  4980              LDR      r1,|L5.560|
000030  6048              STR      r0,[r1,#4]  ; audiodev
;;;181    	audiodev.tbuf=mymalloc(SRAMIN,WAV_I2S_TX_DMA_BUFSIZE);
000032  f44f5100          MOV      r1,#0x2000
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       mymalloc
00003c  497c              LDR      r1,|L5.560|
00003e  6088              STR      r0,[r1,#8]  ; audiodev
;;;182    	if(audiodev.file&&audiodev.i2sbuf1&&audiodev.i2sbuf2&&audiodev.tbuf)
000040  4608              MOV      r0,r1
000042  68c0              LDR      r0,[r0,#0xc]  ; audiodev
000044  2800              CMP      r0,#0
                  |L5.70|
000046  d072              BEQ      |L5.302|
000048  4608              MOV      r0,r1
00004a  6800              LDR      r0,[r0,#0]  ; audiodev
00004c  2800              CMP      r0,#0
00004e  d0fa              BEQ      |L5.70|
000050  4608              MOV      r0,r1
000052  6840              LDR      r0,[r0,#4]  ; audiodev
000054  2800              CMP      r0,#0
000056  d0f6              BEQ      |L5.70|
000058  4608              MOV      r0,r1
00005a  6880              LDR      r0,[r0,#8]  ; audiodev
00005c  2800              CMP      r0,#0
00005e  d0f2              BEQ      |L5.70|
;;;183    	{ 
;;;184    		res=wav_decode_init(fname,&wavctrl);//得到文件的信息
000060  4974              LDR      r1,|L5.564|
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       wav_decode_init
000068  4605              MOV      r5,r0
;;;185    		if(res==0)//解析文件成功
00006a  2d00              CMP      r5,#0
00006c  d177              BNE      |L5.350|
;;;186    		{
;;;187    			if(wavctrl.bps==16)
00006e  4871              LDR      r0,|L5.564|
000070  8b40              LDRH     r0,[r0,#0x1a]  ; wavctrl
000072  2810              CMP      r0,#0x10
000074  d10a              BNE      |L5.140|
;;;188    			{
;;;189    				WM8978_I2S_Cfg(2,0);	//飞利浦标准,16位数据长度
000076  2100              MOVS     r1,#0
000078  2002              MOVS     r0,#2
00007a  f7fffffe          BL       WM8978_I2S_Cfg
;;;190    				I2S2_Init(I2S_Standard_Phillips,I2S_Mode_MasterTx,I2S_CPOL_Low,I2S_DataFormat_16bextended);		//飞利浦标准,主机发送,时钟低电平有效,16位扩展帧长度
00007e  2301              MOVS     r3,#1
000080  2200              MOVS     r2,#0
000082  0259              LSLS     r1,r3,#9
000084  4610              MOV      r0,r2
000086  f7fffffe          BL       I2S2_Init
00008a  e00e              B        |L5.170|
                  |L5.140|
;;;191    			}else if(wavctrl.bps==24)
00008c  4869              LDR      r0,|L5.564|
00008e  8b40              LDRH     r0,[r0,#0x1a]  ; wavctrl
000090  2818              CMP      r0,#0x18
000092  d10a              BNE      |L5.170|
;;;192    			{
;;;193    				WM8978_I2S_Cfg(2,2);	//飞利浦标准,24位数据长度
000094  2102              MOVS     r1,#2
000096  4608              MOV      r0,r1
000098  f7fffffe          BL       WM8978_I2S_Cfg
;;;194    				I2S2_Init(I2S_Standard_Phillips,I2S_Mode_MasterTx,I2S_CPOL_Low,I2S_DataFormat_24b);		//飞利浦标准,主机发送,时钟低电平有效,24位扩展帧长度
00009c  2303              MOVS     r3,#3
00009e  2200              MOVS     r2,#0
0000a0  f44f7100          MOV      r1,#0x200
0000a4  4610              MOV      r0,r2
0000a6  f7fffffe          BL       I2S2_Init
                  |L5.170|
;;;195    			}
;;;196    			I2S2_SampleRate_Set(wavctrl.samplerate);//设置采样率
0000aa  4962              LDR      r1,|L5.564|
0000ac  f8d10016          LDR      r0,[r1,#0x16]  ; wavctrl
0000b0  f7fffffe          BL       I2S2_SampleRate_Set
;;;197    			I2S2_TX_DMA_Init(audiodev.i2sbuf1,audiodev.i2sbuf2,WAV_I2S_TX_DMA_BUFSIZE/2); //配置TX DMA
0000b4  4a5e              LDR      r2,|L5.560|
0000b6  6851              LDR      r1,[r2,#4]  ; audiodev
0000b8  6810              LDR      r0,[r2,#0]  ; audiodev
0000ba  f44f5280          MOV      r2,#0x1000
0000be  f7fffffe          BL       I2S2_TX_DMA_Init
;;;198    			i2s_tx_callback=wav_i2s_dma_tx_callback;			//回调函数指wav_i2s_dma_callback
0000c2  485d              LDR      r0,|L5.568|
0000c4  495d              LDR      r1,|L5.572|
0000c6  6008              STR      r0,[r1,#0]  ; i2s_tx_callback
;;;199    			audio_stop();
0000c8  f7fffffe          BL       audio_stop
;;;200    			res=f_open(audiodev.file,(TCHAR*)fname,FA_READ);	//打开文件
0000cc  4958              LDR      r1,|L5.560|
0000ce  68c8              LDR      r0,[r1,#0xc]  ; audiodev
0000d0  2201              MOVS     r2,#1
0000d2  4631              MOV      r1,r6
0000d4  f7fffffe          BL       f_open
0000d8  4605              MOV      r5,r0
;;;201    			if(res==0)
0000da  2d00              CMP      r5,#0
0000dc  d176              BNE      |L5.460|
;;;202    			{
;;;203    				f_lseek(audiodev.file, wavctrl.datastart);		//跳过文件头
0000de  4a55              LDR      r2,|L5.564|
0000e0  69d1              LDR      r1,[r2,#0x1c]  ; wavctrl
0000e2  4a53              LDR      r2,|L5.560|
0000e4  68d0              LDR      r0,[r2,#0xc]  ; audiodev
0000e6  f7fffffe          BL       f_lseek
;;;204    				fillnum=wav_buffill(audiodev.i2sbuf1,WAV_I2S_TX_DMA_BUFSIZE,wavctrl.bps);
0000ea  4952              LDR      r1,|L5.564|
0000ec  7e8a              LDRB     r2,[r1,#0x1a]  ; wavctrl
0000ee  4950              LDR      r1,|L5.560|
0000f0  6808              LDR      r0,[r1,#0]  ; audiodev
0000f2  f44f5100          MOV      r1,#0x2000
0000f6  f7fffffe          BL       wav_buffill
0000fa  4680              MOV      r8,r0
;;;205    				fillnum=wav_buffill(audiodev.i2sbuf2,WAV_I2S_TX_DMA_BUFSIZE,wavctrl.bps);
0000fc  494d              LDR      r1,|L5.564|
0000fe  7e8a              LDRB     r2,[r1,#0x1a]  ; wavctrl
000100  494b              LDR      r1,|L5.560|
000102  6848              LDR      r0,[r1,#4]  ; audiodev
000104  f44f5100          MOV      r1,#0x2000
000108  f7fffffe          BL       wav_buffill
00010c  4680              MOV      r8,r0
;;;206    				audio_start();  
00010e  f7fffffe          BL       audio_start
;;;207    				while(res==0)
000112  e06b              B        |L5.492|
                  |L5.276|
;;;208    				{ 
;;;209    					while(wavtransferend==0);//等待wav传输完成; 
000114  bf00              NOP      
                  |L5.278|
000116  484a              LDR      r0,|L5.576|
000118  7800              LDRB     r0,[r0,#0]  ; wavtransferend
00011a  2800              CMP      r0,#0
00011c  d0fb              BEQ      |L5.278|
;;;210    					wavtransferend=0;
00011e  2000              MOVS     r0,#0
000120  4947              LDR      r1,|L5.576|
000122  7008              STRB     r0,[r1,#0]
;;;211    					if(fillnum!=WAV_I2S_TX_DMA_BUFSIZE)//播放结束?
000124  f5b85f00          CMP      r8,#0x2000
000128  d002              BEQ      |L5.304|
;;;212    					{
;;;213    						res=KEY0_PRES;
00012a  2501              MOVS     r5,#1
;;;214    						break;
00012c  e060              B        |L5.496|
                  |L5.302|
00012e  e067              B        |L5.512|
                  |L5.304|
;;;215    					} 
;;;216     					if(wavwitchbuf)fillnum=wav_buffill(audiodev.i2sbuf2,WAV_I2S_TX_DMA_BUFSIZE,wavctrl.bps);//填充buf2
000130  4844              LDR      r0,|L5.580|
000132  7800              LDRB     r0,[r0,#0]  ; wavwitchbuf
000134  b148              CBZ      r0,|L5.330|
000136  493f              LDR      r1,|L5.564|
000138  7e8a              LDRB     r2,[r1,#0x1a]  ; wavctrl
00013a  493d              LDR      r1,|L5.560|
00013c  6848              LDR      r0,[r1,#4]  ; audiodev
00013e  f44f5100          MOV      r1,#0x2000
000142  f7fffffe          BL       wav_buffill
000146  4680              MOV      r8,r0
000148  e008              B        |L5.348|
                  |L5.330|
;;;217    					else fillnum=wav_buffill(audiodev.i2sbuf1,WAV_I2S_TX_DMA_BUFSIZE,wavctrl.bps);//填充buf1
00014a  493a              LDR      r1,|L5.564|
00014c  7e8a              LDRB     r2,[r1,#0x1a]  ; wavctrl
00014e  4938              LDR      r1,|L5.560|
000150  6808              LDR      r0,[r1,#0]  ; audiodev
000152  f44f5100          MOV      r1,#0x2000
000156  f7fffffe          BL       wav_buffill
00015a  4680              MOV      r8,r0
                  |L5.348|
;;;218    					while(1)
00015c  e044              B        |L5.488|
                  |L5.350|
00015e  e04d              B        |L5.508|
                  |L5.352|
;;;219    					{
;;;220    						key=KEY_Scan(0); 
000160  2000              MOVS     r0,#0
000162  f7fffffe          BL       KEY_Scan
000166  4604              MOV      r4,r0
;;;221    						if(key==WKUP_PRES)//暂停
000168  2c04              CMP      r4,#4
00016a  d111              BNE      |L5.400|
;;;222    						{
;;;223    							if(audiodev.status&0X01)audiodev.status&=~(1<<0);
00016c  4830              LDR      r0,|L5.560|
00016e  7c00              LDRB     r0,[r0,#0x10]  ; audiodev
000170  f0000001          AND      r0,r0,#1
000174  b130              CBZ      r0,|L5.388|
000176  482e              LDR      r0,|L5.560|
000178  7c00              LDRB     r0,[r0,#0x10]  ; audiodev
00017a  f0200001          BIC      r0,r0,#1
00017e  492c              LDR      r1,|L5.560|
000180  7408              STRB     r0,[r1,#0x10]
000182  e005              B        |L5.400|
                  |L5.388|
;;;224    							else audiodev.status|=0X01;  
000184  482a              LDR      r0,|L5.560|
000186  7c00              LDRB     r0,[r0,#0x10]  ; audiodev
000188  f0400001          ORR      r0,r0,#1
00018c  4928              LDR      r1,|L5.560|
00018e  7408              STRB     r0,[r1,#0x10]
                  |L5.400|
;;;225    						}
;;;226    						if(key==KEY2_PRES||key==KEY0_PRES)//下一曲/上一曲
000190  2c03              CMP      r4,#3
000192  d001              BEQ      |L5.408|
000194  2c01              CMP      r4,#1
000196  d101              BNE      |L5.412|
                  |L5.408|
;;;227    						{
;;;228    							res=key;
000198  4625              MOV      r5,r4
;;;229    							break; 
00019a  e026              B        |L5.490|
                  |L5.412|
;;;230    						}
;;;231    						wav_get_curtime(audiodev.file,&wavctrl);//得到总时间和当前播放的时间 
00019c  4924              LDR      r1,|L5.560|
00019e  68c8              LDR      r0,[r1,#0xc]  ; audiodev
0001a0  4924              LDR      r1,|L5.564|
0001a2  f7fffffe          BL       wav_get_curtime
;;;232    						audio_msg_show(wavctrl.totsec,wavctrl.cursec,wavctrl.bitrate);
0001a6  4b23              LDR      r3,|L5.564|
0001a8  f8d32012          LDR      r2,[r3,#0x12]  ; wavctrl
0001ac  f8d3100e          LDR      r1,[r3,#0xe]  ; wavctrl
0001b0  f8d3000a          LDR      r0,[r3,#0xa]  ; wavctrl
0001b4  f7fffffe          BL       audio_msg_show
;;;233    						t++;
0001b8  1c78              ADDS     r0,r7,#1
0001ba  b2c7              UXTB     r7,r0
;;;234    						if(t==20)
0001bc  2f14              CMP      r7,#0x14
0001be  d109              BNE      |L5.468|
;;;235    						{
;;;236    							t=0;
0001c0  2700              MOVS     r7,#0
;;;237     							LED0=!LED0;
0001c2  4821              LDR      r0,|L5.584|
0001c4  6800              LDR      r0,[r0,#0]
0001c6  b910              CBNZ     r0,|L5.462|
0001c8  2001              MOVS     r0,#1
0001ca  e001              B        |L5.464|
                  |L5.460|
0001cc  e014              B        |L5.504|
                  |L5.462|
0001ce  2000              MOVS     r0,#0
                  |L5.464|
0001d0  491d              LDR      r1,|L5.584|
0001d2  6008              STR      r0,[r1,#0]
                  |L5.468|
;;;238    						}
;;;239    						if((audiodev.status&0X01)==0)delay_ms(10);
0001d4  4816              LDR      r0,|L5.560|
0001d6  7c00              LDRB     r0,[r0,#0x10]  ; audiodev
0001d8  f0000001          AND      r0,r0,#1
0001dc  b918              CBNZ     r0,|L5.486|
0001de  200a              MOVS     r0,#0xa
0001e0  f7fffffe          BL       delay_ms
0001e4  e000              B        |L5.488|
                  |L5.486|
;;;240    						else break;
0001e6  e000              B        |L5.490|
                  |L5.488|
0001e8  e7ba              B        |L5.352|
                  |L5.490|
0001ea  bf00              NOP                            ;229
                  |L5.492|
0001ec  2d00              CMP      r5,#0                 ;207
0001ee  d091              BEQ      |L5.276|
                  |L5.496|
0001f0  bf00              NOP                            ;214
;;;241    					}
;;;242    				}
;;;243    				audio_stop(); 
0001f2  f7fffffe          BL       audio_stop
0001f6  e004              B        |L5.514|
                  |L5.504|
;;;244    			}else res=0XFF; 
0001f8  25ff              MOVS     r5,#0xff
0001fa  e002              B        |L5.514|
                  |L5.508|
;;;245    		}else res=0XFF;
0001fc  25ff              MOVS     r5,#0xff
0001fe  e000              B        |L5.514|
                  |L5.512|
;;;246    	}else res=0XFF; 
000200  25ff              MOVS     r5,#0xff
                  |L5.514|
;;;247    	myfree(SRAMIN,audiodev.tbuf);	//释放内存
000202  480b              LDR      r0,|L5.560|
000204  6881              LDR      r1,[r0,#8]  ; audiodev
000206  2000              MOVS     r0,#0
000208  f7fffffe          BL       myfree
;;;248    	myfree(SRAMIN,audiodev.i2sbuf1);//释放内存
00020c  4808              LDR      r0,|L5.560|
00020e  6801              LDR      r1,[r0,#0]  ; audiodev
000210  2000              MOVS     r0,#0
000212  f7fffffe          BL       myfree
;;;249    	myfree(SRAMIN,audiodev.i2sbuf2);//释放内存 
000216  4806              LDR      r0,|L5.560|
000218  6841              LDR      r1,[r0,#4]  ; audiodev
00021a  2000              MOVS     r0,#0
00021c  f7fffffe          BL       myfree
;;;250    	myfree(SRAMIN,audiodev.file);	//释放内存 
000220  4803              LDR      r0,|L5.560|
000222  68c1              LDR      r1,[r0,#0xc]  ; audiodev
000224  2000              MOVS     r0,#0
000226  f7fffffe          BL       myfree
;;;251    	return res;
00022a  4628              MOV      r0,r5
;;;252    } 
00022c  e8bd81f0          POP      {r4-r8,pc}
;;;253    	
                          ENDP

                  |L5.560|
                          DCD      audiodev
                  |L5.564|
                          DCD      wavctrl
                  |L5.568|
                          DCD      wav_i2s_dma_tx_callback
                  |L5.572|
                          DCD      i2s_tx_callback
                  |L5.576|
                          DCD      wavtransferend
                  |L5.580|
                          DCD      wavwitchbuf
                  |L5.584|
                          DCD      0x424282a4

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  wavctrl
                          %        32

                          AREA ||.data||, DATA, ALIGN=0

                  wavtransferend
000000  00                DCB      0x00
                  wavwitchbuf
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\AUDIOCODEC\\wav\\wavplay.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_wavplay_c_1841484f____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___9_wavplay_c_1841484f____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_wavplay_c_1841484f____REVSH|
#line 144
|__asm___9_wavplay_c_1841484f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
