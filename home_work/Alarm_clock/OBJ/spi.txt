; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\spi.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\spi.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\HARDWARE\LED -I..\HARDWARE\LCD -I..\HARDWARE\KEY -I..\HARDWARE\SRAM -I..\HARDWARE\SDIO -I..\MALLOC -I..\USMART -I..\HARDWARE\SPI -I..\HARDWARE\W25QXX -I..\FATFS\exfuns -I..\FATFS\src -I..\TEXT -I..\FWLIB\inc -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\I2S -I..\HARDWARE\WM8978 -I..\APP -I..\AUDIOCODEC\wav -I..\new_user -I..\new_user\task -I..\new_user\MVC -I..\..\..\module\common -I..\..\..\module\common\InsertLog -I..\..\..\module\common\loopqueue -I..\..\..\module\common\StateMachine -I..\..\..\module\common\priorityqueue -I..\..\..\module\common\Math -I..\..\..\module\component\const_loop_scheduler -I..\..\..\module\component\const_loop_scheduler\TemplateTask -I..\..\..\module\component\const_loop_scheduler\HierarchicalSM -I..\..\..\module\component\BlockableStateMachine -I..\..\..\module\customize\ButtonModule -I..\..\..\module\external\Segger\SEGGER_RTT_V640\Syscalls -I..\..\..\module\external\Segger\SEGGER_RTT_V640\RTT -I.\RTE\_AudioPlayer -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include" -I"D:\Program Files\ARM\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_COMPILER_PRESENT -DX_TASK_LOG_DEBUG_METHOD=SeggerRTT_LogDebug --omf_browse=..\obj\spi.crf ..\HARDWARE\SPI\spi.c]
                          THUMB

                          AREA ||i.SPI1_Init||, CODE, READONLY, ALIGN=2

                  SPI1_Init PROC
;;;18     //这里针是对SPI1的初始化
;;;19     void SPI1_Init(void)
000000  b500              PUSH     {lr}
;;;20     {	 
000002  b087              SUB      sp,sp,#0x1c
;;;21       GPIO_InitTypeDef  GPIO_InitStructure;
;;;22       SPI_InitTypeDef  SPI_InitStructure;
;;;23     	
;;;24       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);//使能GPIOA时钟
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;25       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);//使能SPI1时钟
00000c  2101              MOVS     r1,#1
00000e  0308              LSLS     r0,r1,#12
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;26      
;;;27       //GPIOF9,F10初始化设置
;;;28       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;//PB3~5复用功能输出	
000014  2038              MOVS     r0,#0x38
000016  9005              STR      r0,[sp,#0x14]
;;;29       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
000018  2002              MOVS     r0,#2
00001a  f88d0018          STRB     r0,[sp,#0x18]
;;;30       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
00001e  2000              MOVS     r0,#0
000020  f88d001a          STRB     r0,[sp,#0x1a]
;;;31       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
000024  2003              MOVS     r0,#3
000026  f88d0019          STRB     r0,[sp,#0x19]
;;;32       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
00002a  2001              MOVS     r0,#1
00002c  f88d001b          STRB     r0,[sp,#0x1b]
;;;33       GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
000030  a905              ADD      r1,sp,#0x14
000032  4822              LDR      r0,|L1.188|
000034  f7fffffe          BL       GPIO_Init
;;;34     	
;;;35     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource3,GPIO_AF_SPI1); //PB3复用为 SPI1
000038  2205              MOVS     r2,#5
00003a  2103              MOVS     r1,#3
00003c  481f              LDR      r0,|L1.188|
00003e  f7fffffe          BL       GPIO_PinAFConfig
;;;36     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource4,GPIO_AF_SPI1); //PB4复用为 SPI1
000042  2205              MOVS     r2,#5
000044  2104              MOVS     r1,#4
000046  481d              LDR      r0,|L1.188|
000048  f7fffffe          BL       GPIO_PinAFConfig
;;;37     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource5,GPIO_AF_SPI1); //PB5复用为 SPI1
00004c  2205              MOVS     r2,#5
00004e  4611              MOV      r1,r2
000050  481a              LDR      r0,|L1.188|
000052  f7fffffe          BL       GPIO_PinAFConfig
;;;38     
;;;39      
;;;40     	//这里只针对SPI口初始化
;;;41     	RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1,ENABLE);//复位SPI1
000056  2101              MOVS     r1,#1
000058  0308              LSLS     r0,r1,#12
00005a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;42     	RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1,DISABLE);//停止复位SPI1
00005e  2100              MOVS     r1,#0
000060  f44f5080          MOV      r0,#0x1000
000064  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;43     
;;;44     	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
000068  2000              MOVS     r0,#0
00006a  f8ad0000          STRH     r0,[sp,#0]
;;;45     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
00006e  f44f7082          MOV      r0,#0x104
000072  f8ad0002          STRH     r0,[sp,#2]
;;;46     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;		//设置SPI的数据大小:SPI发送接收8位帧结构
000076  2000              MOVS     r0,#0
000078  f8ad0004          STRH     r0,[sp,#4]
;;;47     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;		//串行同步时钟的空闲状态为高电平
00007c  2002              MOVS     r0,#2
00007e  f8ad0006          STRH     r0,[sp,#6]
;;;48     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样
000082  2001              MOVS     r0,#1
000084  f8ad0008          STRH     r0,[sp,#8]
;;;49     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
000088  0240              LSLS     r0,r0,#9
00008a  f8ad000a          STRH     r0,[sp,#0xa]
;;;50     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;		//定义波特率预分频的值:波特率预分频值为256
00008e  2038              MOVS     r0,#0x38
000090  f8ad000c          STRH     r0,[sp,#0xc]
;;;51     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
000094  2000              MOVS     r0,#0
000096  f8ad000e          STRH     r0,[sp,#0xe]
;;;52     	SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
00009a  2007              MOVS     r0,#7
00009c  f8ad0010          STRH     r0,[sp,#0x10]
;;;53     	SPI_Init(SPI1, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
0000a0  4669              MOV      r1,sp
0000a2  4807              LDR      r0,|L1.192|
0000a4  f7fffffe          BL       SPI_Init
;;;54      
;;;55     	SPI_Cmd(SPI1, ENABLE); //使能SPI外设
0000a8  2101              MOVS     r1,#1
0000aa  4805              LDR      r0,|L1.192|
0000ac  f7fffffe          BL       SPI_Cmd
;;;56     
;;;57     	SPI1_ReadWriteByte(0xff);//启动传输		 
0000b0  20ff              MOVS     r0,#0xff
0000b2  f7fffffe          BL       SPI1_ReadWriteByte
;;;58     }   
0000b6  b007              ADD      sp,sp,#0x1c
0000b8  bd00              POP      {pc}
;;;59     //SPI1速度设置函数
                          ENDP

0000ba  0000              DCW      0x0000
                  |L1.188|
                          DCD      0x40020400
                  |L1.192|
                          DCD      0x40013000

                          AREA ||i.SPI1_ReadWriteByte||, CODE, READONLY, ALIGN=2

                  SPI1_ReadWriteByte PROC
;;;72     //返回值:读取到的字节
;;;73     u8 SPI1_ReadWriteByte(u8 TxData)
000000  b510              PUSH     {r4,lr}
;;;74     {		 			 
000002  4604              MOV      r4,r0
;;;75      
;;;76       while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET){}//等待发送区空  
000004  bf00              NOP      
                  |L2.6|
000006  2102              MOVS     r1,#2
000008  480a              LDR      r0,|L2.52|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L2.6|
;;;77     	
;;;78     	SPI_I2S_SendData(SPI1, TxData); //通过外设SPIx发送一个byte  数据
000012  4621              MOV      r1,r4
000014  4807              LDR      r0,|L2.52|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;79     		
;;;80       while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET){} //等待接收完一个byte  
00001a  bf00              NOP      
                  |L2.28|
00001c  2101              MOVS     r1,#1
00001e  4805              LDR      r0,|L2.52|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L2.28|
;;;81      
;;;82     	return SPI_I2S_ReceiveData(SPI1); //返回通过SPIx最近接收的数据	
000028  4802              LDR      r0,|L2.52|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c0              UXTB     r0,r0
;;;83      		    
;;;84     }
000030  bd10              POP      {r4,pc}
;;;85     
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      0x40013000

                          AREA ||i.SPI1_SetSpeed||, CODE, READONLY, ALIGN=2

                  SPI1_SetSpeed PROC
;;;62     //fAPB2时钟一般为84Mhz
;;;63     void SPI1_SetSpeed(u8 SPI_BaudRatePrescaler)
000000  b510              PUSH     {r4,lr}
;;;64     {
000002  4604              MOV      r4,r0
;;;65       	assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_BaudRatePrescaler));
;;;66     	SPI1->CR1&=0XFFC7;
000004  4807              LDR      r0,|L3.36|
000006  8800              LDRH     r0,[r0,#0]
000008  f64f71c7          MOV      r1,#0xffc7
00000c  4008              ANDS     r0,r0,r1
00000e  4905              LDR      r1,|L3.36|
000010  8008              STRH     r0,[r1,#0]
;;;67     	SPI1->CR1|=SPI_BaudRatePrescaler;	//设置SPI1速度 
000012  4608              MOV      r0,r1
000014  8800              LDRH     r0,[r0,#0]
000016  4320              ORRS     r0,r0,r4
000018  8008              STRH     r0,[r1,#0]
;;;68     	SPI_Cmd(SPI1,ENABLE);  
00001a  2101              MOVS     r1,#1
00001c  4801              LDR      r0,|L3.36|
00001e  f7fffffe          BL       SPI_Cmd
;;;69     } 
000022  bd10              POP      {r4,pc}
;;;70     //SPI1 读写一个字节
                          ENDP

                  |L3.36|
                          DCD      0x40013000

;*** Start embedded assembler ***

#line 1 "..\\HARDWARE\\SPI\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_1b04b235____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___5_spi_c_1b04b235____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_1b04b235____REVSH|
#line 144
|__asm___5_spi_c_1b04b235____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
