; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\w25qxx.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\w25qxx.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\HARDWARE\LED -I..\HARDWARE\LCD -I..\HARDWARE\KEY -I..\HARDWARE\SRAM -I..\HARDWARE\SDIO -I..\MALLOC -I..\USMART -I..\HARDWARE\SPI -I..\HARDWARE\W25QXX -I..\FATFS\exfuns -I..\FATFS\src -I..\TEXT -I..\FWLIB\inc -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\I2S -I..\HARDWARE\WM8978 -I..\APP -I..\AUDIOCODEC\wav -I..\new_user -I..\new_user\task -I..\new_user\MVC -I..\..\..\module\common -I..\..\..\module\common\InsertLog -I..\..\..\module\common\loopqueue -I..\..\..\module\common\StateMachine -I..\..\..\module\common\priorityqueue -I..\..\..\module\common\Math -I..\..\..\module\component\const_loop_scheduler -I..\..\..\module\component\const_loop_scheduler\TemplateTask -I..\..\..\module\component\const_loop_scheduler\HierarchicalSM -I..\..\..\module\component\BlockableStateMachine -I..\..\..\module\customize\ButtonModule -I..\..\..\module\external\Segger\SEGGER_RTT_V640\Syscalls -I..\..\..\module\external\Segger\SEGGER_RTT_V640\RTT -I.\RTE\_AudioPlayer -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include" -I"D:\Program Files\ARM\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_COMPILER_PRESENT -DX_TASK_LOG_DEBUG_METHOD=SeggerRTT_LogDebug --omf_browse=..\obj\w25qxx.crf ..\HARDWARE\W25QXX\w25qxx.c]
                          THUMB

                          AREA ||i.W25QXX_Erase_Chip||, CODE, READONLY, ALIGN=2

                  W25QXX_Erase_Chip PROC
;;;230    //等待时间超长...
;;;231    void W25QXX_Erase_Chip(void)   
000000  b510              PUSH     {r4,lr}
;;;232    {                                   
;;;233        W25QXX_Write_Enable();                  //SET WEL 
000002  f7fffffe          BL       W25QXX_Write_Enable
;;;234        W25QXX_Wait_Busy();   
000006  f7fffffe          BL       W25QXX_Wait_Busy
;;;235      	W25QXX_CS=0;                            //使能器件   
00000a  2000              MOVS     r0,#0
00000c  4905              LDR      r1,|L1.36|
00000e  6008              STR      r0,[r1,#0]
;;;236        SPI1_ReadWriteByte(W25X_ChipErase);        //发送片擦除命令  
000010  20c7              MOVS     r0,#0xc7
000012  f7fffffe          BL       SPI1_ReadWriteByte
;;;237    	W25QXX_CS=1;                            //取消片选     	      
000016  2001              MOVS     r0,#1
000018  4903              LDR      r1,|L1.40|
00001a  f8c102b8          STR      r0,[r1,#0x2b8]
;;;238    	W25QXX_Wait_Busy();   				   //等待芯片擦除结束
00001e  f7fffffe          BL       W25QXX_Wait_Busy
;;;239    }   
000022  bd10              POP      {r4,pc}
;;;240    //擦除一个扇区
                          ENDP

                  |L1.36|
                          DCD      0x424082b8
                  |L1.40|
                          DCD      0x42408000

                          AREA ||i.W25QXX_Erase_Sector||, CODE, READONLY, ALIGN=2

                  W25QXX_Erase_Sector PROC
;;;242    //擦除一个山区的最少时间:150ms
;;;243    void W25QXX_Erase_Sector(u32 Dst_Addr)   
000000  b510              PUSH     {r4,lr}
;;;244    {  
000002  4604              MOV      r4,r0
;;;245    	//监视falsh擦除情况,测试用   
;;;246    ////// 	printf("fe:%x\r\n",Dst_Addr);	  
;;;247     	Dst_Addr*=4096;
000004  0324              LSLS     r4,r4,#12
;;;248        W25QXX_Write_Enable();                  //SET WEL 	 
000006  f7fffffe          BL       W25QXX_Write_Enable
;;;249        W25QXX_Wait_Busy();   
00000a  f7fffffe          BL       W25QXX_Wait_Busy
;;;250      	W25QXX_CS=0;                            //使能器件   
00000e  2000              MOVS     r0,#0
000010  490b              LDR      r1,|L2.64|
000012  6008              STR      r0,[r1,#0]
;;;251        SPI1_ReadWriteByte(W25X_SectorErase);      //发送扇区擦除指令 
000014  2020              MOVS     r0,#0x20
000016  f7fffffe          BL       SPI1_ReadWriteByte
;;;252        SPI1_ReadWriteByte((u8)((Dst_Addr)>>16));  //发送24bit地址    
00001a  f3c44007          UBFX     r0,r4,#16,#8
00001e  f7fffffe          BL       SPI1_ReadWriteByte
;;;253        SPI1_ReadWriteByte((u8)((Dst_Addr)>>8));   
000022  f3c42007          UBFX     r0,r4,#8,#8
000026  f7fffffe          BL       SPI1_ReadWriteByte
;;;254        SPI1_ReadWriteByte((u8)Dst_Addr);  
00002a  b2e0              UXTB     r0,r4
00002c  f7fffffe          BL       SPI1_ReadWriteByte
;;;255    	W25QXX_CS=1;                            //取消片选     	      
000030  2001              MOVS     r0,#1
000032  4904              LDR      r1,|L2.68|
000034  f8c102b8          STR      r0,[r1,#0x2b8]
;;;256        W25QXX_Wait_Busy();   				   //等待擦除完成
000038  f7fffffe          BL       W25QXX_Wait_Busy
;;;257    }  
00003c  bd10              POP      {r4,pc}
;;;258    //等待空闲
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      0x424082b8
                  |L2.68|
                          DCD      0x42408000

                          AREA ||i.W25QXX_Init||, CODE, READONLY, ALIGN=2

                  W25QXX_Init PROC
;;;25     //初始化SPI FLASH的IO口
;;;26     void W25QXX_Init(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;27     { 
;;;28       GPIO_InitTypeDef  GPIO_InitStructure;
;;;29      
;;;30       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);//使能GPIOB时钟
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;31       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);//使能GPIOG时钟
00000a  2101              MOVS     r1,#1
00000c  2040              MOVS     r0,#0x40
00000e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;32     
;;;33     	  //GPIOB14
;;;34       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;//PB14
000012  f44f4080          MOV      r0,#0x4000
000016  9000              STR      r0,[sp,#0]
;;;35       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;//输出
000018  2001              MOVS     r0,#1
00001a  f88d0004          STRB     r0,[sp,#4]
;;;36       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
00001e  2000              MOVS     r0,#0
000020  f88d0006          STRB     r0,[sp,#6]
;;;37       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
000024  2003              MOVS     r0,#3
000026  f88d0005          STRB     r0,[sp,#5]
;;;38       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
00002a  2001              MOVS     r0,#1
00002c  f88d0007          STRB     r0,[sp,#7]
;;;39       GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
000030  4669              MOV      r1,sp
000032  480d              LDR      r0,|L3.104|
000034  f7fffffe          BL       GPIO_Init
;;;40     
;;;41     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;//PG7
000038  2080              MOVS     r0,#0x80
00003a  9000              STR      r0,[sp,#0]
;;;42       GPIO_Init(GPIOG, &GPIO_InitStructure);//初始化
00003c  4669              MOV      r1,sp
00003e  480b              LDR      r0,|L3.108|
000040  f7fffffe          BL       GPIO_Init
;;;43      
;;;44     	GPIO_SetBits(GPIOG,GPIO_Pin_7);//PG7输出1,防止NRF干扰SPI FLASH的通信 
000044  2180              MOVS     r1,#0x80
000046  4809              LDR      r0,|L3.108|
000048  f7fffffe          BL       GPIO_SetBits
;;;45     	W25QXX_CS=1;			//SPI FLASH不选中
00004c  2001              MOVS     r0,#1
00004e  4908              LDR      r1,|L3.112|
000050  6008              STR      r0,[r1,#0]
;;;46     	SPI1_Init();		   			//初始化SPI
000052  f7fffffe          BL       SPI1_Init
;;;47     	SPI1_SetSpeed(SPI_BaudRatePrescaler_2);		//设置为42M时钟,高速模式 
000056  2000              MOVS     r0,#0
000058  f7fffffe          BL       SPI1_SetSpeed
;;;48     	W25QXX_TYPE=W25QXX_ReadID();	//读取FLASH ID.
00005c  f7fffffe          BL       W25QXX_ReadID
000060  4904              LDR      r1,|L3.116|
000062  8008              STRH     r0,[r1,#0]
;;;49     }  
000064  bd1c              POP      {r2-r4,pc}
;;;50     
                          ENDP

000066  0000              DCW      0x0000
                  |L3.104|
                          DCD      0x40020400
                  |L3.108|
                          DCD      0x40021800
                  |L3.112|
                          DCD      0x424082b8
                  |L3.116|
                          DCD      W25QXX_TYPE

                          AREA ||i.W25QXX_PowerDown||, CODE, READONLY, ALIGN=2

                  W25QXX_PowerDown PROC
;;;263    //进入掉电模式
;;;264    void W25QXX_PowerDown(void)   
000000  b510              PUSH     {r4,lr}
;;;265    { 
;;;266      	W25QXX_CS=0;                            //使能器件   
000002  2000              MOVS     r0,#0
000004  4906              LDR      r1,|L4.32|
000006  6008              STR      r0,[r1,#0]
;;;267        SPI1_ReadWriteByte(W25X_PowerDown);        //发送掉电命令  
000008  20b9              MOVS     r0,#0xb9
00000a  f7fffffe          BL       SPI1_ReadWriteByte
;;;268    	W25QXX_CS=1;                            //取消片选     	      
00000e  2001              MOVS     r0,#1
000010  4904              LDR      r1,|L4.36|
000012  f8c102b8          STR      r0,[r1,#0x2b8]
;;;269        delay_us(3);                               //等待TPD  
000016  2003              MOVS     r0,#3
000018  f7fffffe          BL       delay_us
;;;270    }   
00001c  bd10              POP      {r4,pc}
;;;271    //唤醒
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x424082b8
                  |L4.36|
                          DCD      0x42408000

                          AREA ||i.W25QXX_Read||, CODE, READONLY, ALIGN=2

                  W25QXX_Read PROC
;;;117    //NumByteToRead:要读取的字节数(最大65535)
;;;118    void W25QXX_Read(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;119    { 
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;120     	u16 i;   										    
;;;121    	W25QXX_CS=0;                            //使能器件   
00000a  2000              MOVS     r0,#0
00000c  490f              LDR      r1,|L5.76|
00000e  6008              STR      r0,[r1,#0]
;;;122        SPI1_ReadWriteByte(W25X_ReadData);         //发送读取命令   
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       SPI1_ReadWriteByte
;;;123        SPI1_ReadWriteByte((u8)((ReadAddr)>>16));  //发送24bit地址    
000016  f3c44007          UBFX     r0,r4,#16,#8
00001a  f7fffffe          BL       SPI1_ReadWriteByte
;;;124        SPI1_ReadWriteByte((u8)((ReadAddr)>>8));   
00001e  f3c42007          UBFX     r0,r4,#8,#8
000022  f7fffffe          BL       SPI1_ReadWriteByte
;;;125        SPI1_ReadWriteByte((u8)ReadAddr);   
000026  b2e0              UXTB     r0,r4
000028  f7fffffe          BL       SPI1_ReadWriteByte
;;;126        for(i=0;i<NumByteToRead;i++)
00002c  2500              MOVS     r5,#0
00002e  e005              B        |L5.60|
                  |L5.48|
;;;127    	{ 
;;;128            pBuffer[i]=SPI1_ReadWriteByte(0XFF);   //循环读数  
000030  20ff              MOVS     r0,#0xff
000032  f7fffffe          BL       SPI1_ReadWriteByte
000036  5570              STRB     r0,[r6,r5]
000038  1c68              ADDS     r0,r5,#1              ;126
00003a  b285              UXTH     r5,r0                 ;126
                  |L5.60|
00003c  42bd              CMP      r5,r7                 ;126
00003e  dbf7              BLT      |L5.48|
;;;129        }
;;;130    	W25QXX_CS=1;  				    	      
000040  2001              MOVS     r0,#1
000042  4902              LDR      r1,|L5.76|
000044  6008              STR      r0,[r1,#0]
;;;131    }  
000046  e8bd81f0          POP      {r4-r8,pc}
;;;132    //SPI在一页(0~65535)内写入少于256个字节的数据
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      0x424082b8

                          AREA ||i.W25QXX_ReadID||, CODE, READONLY, ALIGN=2

                  W25QXX_ReadID PROC
;;;99     //0XEF17,表示芯片型号为W25Q128 	  
;;;100    u16 W25QXX_ReadID(void)
000000  b510              PUSH     {r4,lr}
;;;101    {
;;;102    	u16 Temp = 0;	  
000002  2400              MOVS     r4,#0
;;;103    	W25QXX_CS=0;				    
000004  2000              MOVS     r0,#0
000006  490e              LDR      r1,|L6.64|
000008  6008              STR      r0,[r1,#0]
;;;104    	SPI1_ReadWriteByte(0x90);//发送读取ID命令	    
00000a  2090              MOVS     r0,#0x90
00000c  f7fffffe          BL       SPI1_ReadWriteByte
;;;105    	SPI1_ReadWriteByte(0x00); 	    
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       SPI1_ReadWriteByte
;;;106    	SPI1_ReadWriteByte(0x00); 	    
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       SPI1_ReadWriteByte
;;;107    	SPI1_ReadWriteByte(0x00); 	 			   
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       SPI1_ReadWriteByte
;;;108    	Temp|=SPI1_ReadWriteByte(0xFF)<<8;  
000022  20ff              MOVS     r0,#0xff
000024  f7fffffe          BL       SPI1_ReadWriteByte
000028  ea442400          ORR      r4,r4,r0,LSL #8
;;;109    	Temp|=SPI1_ReadWriteByte(0xFF);	 
00002c  20ff              MOVS     r0,#0xff
00002e  f7fffffe          BL       SPI1_ReadWriteByte
000032  4304              ORRS     r4,r4,r0
;;;110    	W25QXX_CS=1;				    
000034  2001              MOVS     r0,#1
000036  4903              LDR      r1,|L6.68|
000038  f8c102b8          STR      r0,[r1,#0x2b8]
;;;111    	return Temp;
00003c  4620              MOV      r0,r4
;;;112    }   		    
00003e  bd10              POP      {r4,pc}
;;;113    //读取SPI FLASH  
                          ENDP

                  |L6.64|
                          DCD      0x424082b8
                  |L6.68|
                          DCD      0x42408000

                          AREA ||i.W25QXX_ReadSR||, CODE, READONLY, ALIGN=2

                  W25QXX_ReadSR PROC
;;;58     //默认:0x00
;;;59     u8 W25QXX_ReadSR(void)   
000000  b510              PUSH     {r4,lr}
;;;60     {  
;;;61     	u8 byte=0;   
000002  2400              MOVS     r4,#0
;;;62     	W25QXX_CS=0;                            //使能器件   
000004  2000              MOVS     r0,#0
000006  4907              LDR      r1,|L7.36|
000008  6008              STR      r0,[r1,#0]
;;;63     	SPI1_ReadWriteByte(W25X_ReadStatusReg);    //发送读取状态寄存器命令    
00000a  2005              MOVS     r0,#5
00000c  f7fffffe          BL       SPI1_ReadWriteByte
;;;64     	byte=SPI1_ReadWriteByte(0Xff);             //读取一个字节  
000010  20ff              MOVS     r0,#0xff
000012  f7fffffe          BL       SPI1_ReadWriteByte
000016  4604              MOV      r4,r0
;;;65     	W25QXX_CS=1;                            //取消片选     
000018  2001              MOVS     r0,#1
00001a  4903              LDR      r1,|L7.40|
00001c  f8c102b8          STR      r0,[r1,#0x2b8]
;;;66     	return byte;   
000020  4620              MOV      r0,r4
;;;67     } 
000022  bd10              POP      {r4,pc}
;;;68     //写W25QXX状态寄存器
                          ENDP

                  |L7.36|
                          DCD      0x424082b8
                  |L7.40|
                          DCD      0x42408000

                          AREA ||i.W25QXX_WAKEUP||, CODE, READONLY, ALIGN=2

                  W25QXX_WAKEUP PROC
;;;271    //唤醒
;;;272    void W25QXX_WAKEUP(void)   
000000  b510              PUSH     {r4,lr}
;;;273    {  
;;;274      	W25QXX_CS=0;                            //使能器件   
000002  2000              MOVS     r0,#0
000004  4906              LDR      r1,|L8.32|
000006  6008              STR      r0,[r1,#0]
;;;275        SPI1_ReadWriteByte(W25X_ReleasePowerDown);   //  send W25X_PowerDown command 0xAB    
000008  20ab              MOVS     r0,#0xab
00000a  f7fffffe          BL       SPI1_ReadWriteByte
;;;276    	W25QXX_CS=1;                            //取消片选     	      
00000e  2001              MOVS     r0,#1
000010  4904              LDR      r1,|L8.36|
000012  f8c102b8          STR      r0,[r1,#0x2b8]
;;;277        delay_us(3);                               //等待TRES1
000016  2003              MOVS     r0,#3
000018  f7fffffe          BL       delay_us
;;;278    }   
00001c  bd10              POP      {r4,pc}
;;;279    
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      0x424082b8
                  |L8.36|
                          DCD      0x42408000

                          AREA ||i.W25QXX_Wait_Busy||, CODE, READONLY, ALIGN=1

                  W25QXX_Wait_Busy PROC
;;;258    //等待空闲
;;;259    void W25QXX_Wait_Busy(void)   
000000  b510              PUSH     {r4,lr}
;;;260    {   
;;;261    	while((W25QXX_ReadSR()&0x01)==0x01);   // 等待BUSY位清空
000002  bf00              NOP      
                  |L9.4|
000004  f7fffffe          BL       W25QXX_ReadSR
000008  f0000001          AND      r0,r0,#1
00000c  2800              CMP      r0,#0
00000e  d1f9              BNE      |L9.4|
;;;262    }  
000010  bd10              POP      {r4,pc}
;;;263    //进入掉电模式
                          ENDP


                          AREA ||i.W25QXX_Write||, CODE, READONLY, ALIGN=2

                  W25QXX_Write PROC
;;;184    u8 W25QXX_BUFFER[4096];		 
;;;185    void W25QXX_Write(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)   
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;186    { 
000004  4681              MOV      r9,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;187    	u32 secpos;
;;;188    	u16 secoff;
;;;189    	u16 secremain;	   
;;;190     	u16 i;    
;;;191    	u8 * W25QXX_BUF;	  
;;;192       	W25QXX_BUF=W25QXX_BUFFER;	     
00000a  f8dfb0a8          LDR      r11,|L10.180|
;;;193     	secpos=WriteAddr/4096;//扇区地址  
00000e  ea4f3817          LSR      r8,r7,#12
;;;194    	secoff=WriteAddr%4096;//在扇区内的偏移
000012  f3c70a0b          UBFX     r10,r7,#0,#12
;;;195    	secremain=4096-secoff;//扇区剩余空间大小   
000016  f5ca5480          RSB      r4,r10,#0x1000
;;;196     	//printf("ad:%X,nb:%X\r\n",WriteAddr,NumByteToWrite);//测试用
;;;197     	if(NumByteToWrite<=secremain)secremain=NumByteToWrite;//不大于4096个字节
00001a  42a6              CMP      r6,r4
00001c  dc00              BGT      |L10.32|
00001e  4634              MOV      r4,r6
                  |L10.32|
;;;198    	while(1) 
000020  e044              B        |L10.172|
                  |L10.34|
;;;199    	{	
;;;200    		W25QXX_Read(W25QXX_BUF,secpos*4096,4096);//读出整个扇区的内容
000022  ea4f3108          LSL      r1,r8,#12
000026  f44f5280          MOV      r2,#0x1000
00002a  4658              MOV      r0,r11
00002c  f7fffffe          BL       W25QXX_Read
;;;201    		for(i=0;i<secremain;i++)//校验数据
000030  2500              MOVS     r5,#0
000032  e008              B        |L10.70|
                  |L10.52|
;;;202    		{
;;;203    			if(W25QXX_BUF[secoff+i]!=0XFF)break;//需要擦除  	  
000034  eb0a0005          ADD      r0,r10,r5
000038  f81b0000          LDRB     r0,[r11,r0]
00003c  28ff              CMP      r0,#0xff
00003e  d000              BEQ      |L10.66|
000040  e003              B        |L10.74|
                  |L10.66|
000042  1c68              ADDS     r0,r5,#1              ;201
000044  b285              UXTH     r5,r0                 ;201
                  |L10.70|
000046  42a5              CMP      r5,r4                 ;201
000048  dbf4              BLT      |L10.52|
                  |L10.74|
00004a  bf00              NOP      
;;;204    		}
;;;205    		if(i<secremain)//需要擦除
00004c  42a5              CMP      r5,r4
00004e  da16              BGE      |L10.126|
;;;206    		{
;;;207    			W25QXX_Erase_Sector(secpos);//擦除这个扇区
000050  4640              MOV      r0,r8
000052  f7fffffe          BL       W25QXX_Erase_Sector
;;;208    			for(i=0;i<secremain;i++)	   //复制
000056  2500              MOVS     r5,#0
000058  e007              B        |L10.106|
                  |L10.90|
;;;209    			{
;;;210    				W25QXX_BUF[i+secoff]=pBuffer[i];	  
00005a  f8190005          LDRB     r0,[r9,r5]
00005e  eb05010a          ADD      r1,r5,r10
000062  f80b0001          STRB     r0,[r11,r1]
000066  1c68              ADDS     r0,r5,#1              ;208
000068  b285              UXTH     r5,r0                 ;208
                  |L10.106|
00006a  42a5              CMP      r5,r4                 ;208
00006c  dbf5              BLT      |L10.90|
;;;211    			}
;;;212    			W25QXX_Write_NoCheck(W25QXX_BUF,secpos*4096,4096);//写入整个扇区  
00006e  ea4f3108          LSL      r1,r8,#12
000072  f44f5280          MOV      r2,#0x1000
000076  4658              MOV      r0,r11
000078  f7fffffe          BL       W25QXX_Write_NoCheck
00007c  e004              B        |L10.136|
                  |L10.126|
;;;213    
;;;214    		}else W25QXX_Write_NoCheck(pBuffer,WriteAddr,secremain);//写已经擦除了的,直接写入扇区剩余区间. 				   
00007e  4622              MOV      r2,r4
000080  4639              MOV      r1,r7
000082  4648              MOV      r0,r9
000084  f7fffffe          BL       W25QXX_Write_NoCheck
                  |L10.136|
;;;215    		if(NumByteToWrite==secremain)break;//写入结束了
000088  42a6              CMP      r6,r4
00008a  d100              BNE      |L10.142|
00008c  e00f              B        |L10.174|
                  |L10.142|
;;;216    		else//写入未结束
;;;217    		{
;;;218    			secpos++;//扇区地址增1
00008e  f1080801          ADD      r8,r8,#1
;;;219    			secoff=0;//偏移位置为0 	 
000092  f04f0a00          MOV      r10,#0
;;;220    
;;;221    		   	pBuffer+=secremain;  //指针偏移
000096  44a1              ADD      r9,r9,r4
;;;222    			WriteAddr+=secremain;//写地址偏移	   
000098  4427              ADD      r7,r7,r4
;;;223    		   	NumByteToWrite-=secremain;				//字节数递减
00009a  1b30              SUBS     r0,r6,r4
00009c  b286              UXTH     r6,r0
;;;224    			if(NumByteToWrite>4096)secremain=4096;	//下一个扇区还是写不完
00009e  f5b65f80          CMP      r6,#0x1000
0000a2  dd02              BLE      |L10.170|
0000a4  f44f5480          MOV      r4,#0x1000
0000a8  e000              B        |L10.172|
                  |L10.170|
;;;225    			else secremain=NumByteToWrite;			//下一个扇区可以写完了
0000aa  4634              MOV      r4,r6
                  |L10.172|
0000ac  e7b9              B        |L10.34|
                  |L10.174|
0000ae  bf00              NOP                            ;215
;;;226    		}	 
;;;227    	};	 
;;;228    }
0000b0  e8bd9ff0          POP      {r4-r12,pc}
;;;229    //擦除整个芯片		  
                          ENDP

                  |L10.180|
                          DCD      W25QXX_BUFFER

                          AREA ||i.W25QXX_Write_Disable||, CODE, READONLY, ALIGN=2

                  W25QXX_Write_Disable PROC
;;;86     //将WEL清零  
;;;87     void W25QXX_Write_Disable(void)   
000000  b510              PUSH     {r4,lr}
;;;88     {  
;;;89     	W25QXX_CS=0;                            //使能器件   
000002  2000              MOVS     r0,#0
000004  4904              LDR      r1,|L11.24|
000006  6008              STR      r0,[r1,#0]
;;;90         SPI1_ReadWriteByte(W25X_WriteDisable);     //发送写禁止指令    
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       SPI1_ReadWriteByte
;;;91     	W25QXX_CS=1;                            //取消片选     	      
00000e  2001              MOVS     r0,#1
000010  4902              LDR      r1,|L11.28|
000012  f8c102b8          STR      r0,[r1,#0x2b8]
;;;92     } 		
000016  bd10              POP      {r4,pc}
;;;93     //读取芯片ID
                          ENDP

                  |L11.24|
                          DCD      0x424082b8
                  |L11.28|
                          DCD      0x42408000

                          AREA ||i.W25QXX_Write_Enable||, CODE, READONLY, ALIGN=2

                  W25QXX_Write_Enable PROC
;;;78     //将WEL置位   
;;;79     void W25QXX_Write_Enable(void)   
000000  b510              PUSH     {r4,lr}
;;;80     {
;;;81     	W25QXX_CS=0;                            //使能器件   
000002  2000              MOVS     r0,#0
000004  4904              LDR      r1,|L12.24|
000006  6008              STR      r0,[r1,#0]
;;;82         SPI1_ReadWriteByte(W25X_WriteEnable);      //发送写使能  
000008  2006              MOVS     r0,#6
00000a  f7fffffe          BL       SPI1_ReadWriteByte
;;;83     	W25QXX_CS=1;                            //取消片选     	      
00000e  2001              MOVS     r0,#1
000010  4902              LDR      r1,|L12.28|
000012  f8c102b8          STR      r0,[r1,#0x2b8]
;;;84     } 
000016  bd10              POP      {r4,pc}
;;;85     //W25QXX写禁止	
                          ENDP

                  |L12.24|
                          DCD      0x424082b8
                  |L12.28|
                          DCD      0x42408000

                          AREA ||i.W25QXX_Write_NoCheck||, CODE, READONLY, ALIGN=1

                  W25QXX_Write_NoCheck PROC
;;;157    //CHECK OK
;;;158    void W25QXX_Write_NoCheck(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;159    { 			 		 
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;160    	u16 pageremain;	   
;;;161    	pageremain=256-WriteAddr%256; //单页剩余的字节数		 	    
00000a  b2f0              UXTB     r0,r6
00000c  f5c07580          RSB      r5,r0,#0x100
;;;162    	if(NumByteToWrite<=pageremain)pageremain=NumByteToWrite;//不大于256个字节
000010  42ac              CMP      r4,r5
000012  dc00              BGT      |L13.22|
000014  4625              MOV      r5,r4
                  |L13.22|
;;;163    	while(1)
000016  e012              B        |L13.62|
                  |L13.24|
;;;164    	{	   
;;;165    		W25QXX_Write_Page(pBuffer,WriteAddr,pageremain);
000018  462a              MOV      r2,r5
00001a  4631              MOV      r1,r6
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       W25QXX_Write_Page
;;;166    		if(NumByteToWrite==pageremain)break;//写入结束了
000022  42ac              CMP      r4,r5
000024  d100              BNE      |L13.40|
000026  e00b              B        |L13.64|
                  |L13.40|
;;;167    	 	else //NumByteToWrite>pageremain
;;;168    		{
;;;169    			pBuffer+=pageremain;
000028  442f              ADD      r7,r7,r5
;;;170    			WriteAddr+=pageremain;	
00002a  442e              ADD      r6,r6,r5
;;;171    
;;;172    			NumByteToWrite-=pageremain;			  //减去已经写入了的字节数
00002c  1b60              SUBS     r0,r4,r5
00002e  b284              UXTH     r4,r0
;;;173    			if(NumByteToWrite>256)pageremain=256; //一次可以写入256个字节
000030  f5b47f80          CMP      r4,#0x100
000034  dd02              BLE      |L13.60|
000036  f44f7580          MOV      r5,#0x100
00003a  e000              B        |L13.62|
                  |L13.60|
;;;174    			else pageremain=NumByteToWrite; 	  //不够256个字节了
00003c  4625              MOV      r5,r4
                  |L13.62|
00003e  e7eb              B        |L13.24|
                  |L13.64|
000040  bf00              NOP                            ;166
;;;175    		}
;;;176    	};	    
;;;177    } 
000042  e8bd81f0          POP      {r4-r8,pc}
;;;178    //写SPI FLASH  
                          ENDP


                          AREA ||i.W25QXX_Write_Page||, CODE, READONLY, ALIGN=2

                  W25QXX_Write_Page PROC
;;;136    //NumByteToWrite:要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!	 
;;;137    void W25QXX_Write_Page(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;138    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;139     	u16 i;  
;;;140        W25QXX_Write_Enable();                  //SET WEL 
00000a  f7fffffe          BL       W25QXX_Write_Enable
;;;141    	W25QXX_CS=0;                            //使能器件   
00000e  2000              MOVS     r0,#0
000010  490f              LDR      r1,|L14.80|
000012  6008              STR      r0,[r1,#0]
;;;142        SPI1_ReadWriteByte(W25X_PageProgram);      //发送写页命令   
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       SPI1_ReadWriteByte
;;;143        SPI1_ReadWriteByte((u8)((WriteAddr)>>16)); //发送24bit地址    
00001a  f3c44007          UBFX     r0,r4,#16,#8
00001e  f7fffffe          BL       SPI1_ReadWriteByte
;;;144        SPI1_ReadWriteByte((u8)((WriteAddr)>>8));   
000022  f3c42007          UBFX     r0,r4,#8,#8
000026  f7fffffe          BL       SPI1_ReadWriteByte
;;;145        SPI1_ReadWriteByte((u8)WriteAddr);   
00002a  b2e0              UXTB     r0,r4
00002c  f7fffffe          BL       SPI1_ReadWriteByte
;;;146        for(i=0;i<NumByteToWrite;i++)SPI1_ReadWriteByte(pBuffer[i]);//循环写数  
000030  2500              MOVS     r5,#0
000032  e004              B        |L14.62|
                  |L14.52|
000034  5d70              LDRB     r0,[r6,r5]
000036  f7fffffe          BL       SPI1_ReadWriteByte
00003a  1c68              ADDS     r0,r5,#1
00003c  b285              UXTH     r5,r0
                  |L14.62|
00003e  42bd              CMP      r5,r7
000040  dbf8              BLT      |L14.52|
;;;147    	W25QXX_CS=1;                            //取消片选 
000042  2001              MOVS     r0,#1
000044  4902              LDR      r1,|L14.80|
000046  6008              STR      r0,[r1,#0]
;;;148    	W25QXX_Wait_Busy();					   //等待写入结束
000048  f7fffffe          BL       W25QXX_Wait_Busy
;;;149    } 
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;150    //无检验写SPI FLASH 
                          ENDP

                  |L14.80|
                          DCD      0x424082b8

                          AREA ||i.W25QXX_Write_SR||, CODE, READONLY, ALIGN=2

                  W25QXX_Write_SR PROC
;;;69     //只有SPR,TB,BP2,BP1,BP0(bit 7,5,4,3,2)可以写!!!
;;;70     void W25QXX_Write_SR(u8 sr)   
000000  b510              PUSH     {r4,lr}
;;;71     {   
000002  4604              MOV      r4,r0
;;;72     	W25QXX_CS=0;                            //使能器件   
000004  2000              MOVS     r0,#0
000006  4906              LDR      r1,|L15.32|
000008  6008              STR      r0,[r1,#0]
;;;73     	SPI1_ReadWriteByte(W25X_WriteStatusReg);   //发送写取状态寄存器命令    
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       SPI1_ReadWriteByte
;;;74     	SPI1_ReadWriteByte(sr);               //写入一个字节  
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       SPI1_ReadWriteByte
;;;75     	W25QXX_CS=1;                            //取消片选     	      
000016  2001              MOVS     r0,#1
000018  4902              LDR      r1,|L15.36|
00001a  f8c102b8          STR      r0,[r1,#0x2b8]
;;;76     }   
00001e  bd10              POP      {r4,pc}
;;;77     //W25QXX写使能	
                          ENDP

                  |L15.32|
                          DCD      0x424082b8
                  |L15.36|
                          DCD      0x42408000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  W25QXX_BUFFER
                          %        4096

                          AREA ||.data||, DATA, ALIGN=1

                  W25QXX_TYPE
000000  ef17              DCW      0xef17

;*** Start embedded assembler ***

#line 1 "..\\HARDWARE\\W25QXX\\w25qxx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_w25qxx_c_7a854d5a____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___8_w25qxx_c_7a854d5a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_w25qxx_c_7a854d5a____REVSH|
#line 144
|__asm___8_w25qxx_c_7a854d5a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
