; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\bit_operation.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\bit_operation.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\HARDWARE\LED -I..\HARDWARE\LCD -I..\HARDWARE\KEY -I..\HARDWARE\SRAM -I..\HARDWARE\SDIO -I..\MALLOC -I..\USMART -I..\HARDWARE\SPI -I..\HARDWARE\W25QXX -I..\FATFS\exfuns -I..\FATFS\src -I..\TEXT -I..\FWLIB\inc -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\I2S -I..\HARDWARE\WM8978 -I..\APP -I..\AUDIOCODEC\wav -I..\new_user -I..\new_user\task -I..\new_user\MVC -I..\..\..\module\common -I..\..\..\module\common\InsertLog -I..\..\..\module\common\loopqueue -I..\..\..\module\common\StateMachine -I..\..\..\module\common\priorityqueue -I..\..\..\module\common\Math -I..\..\..\module\component\const_loop_scheduler -I..\..\..\module\component\const_loop_scheduler\TemplateTask -I..\..\..\module\component\const_loop_scheduler\HierarchicalSM -I..\..\..\module\component\BlockableStateMachine -I..\..\..\module\customize\ButtonModule -I..\..\..\module\external\Segger\SEGGER_RTT_V640\Syscalls -I..\..\..\module\external\Segger\SEGGER_RTT_V640\RTT -I.\RTE\_AudioPlayer -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include" -I"D:\Program Files\ARM\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_COMPILER_PRESENT -DX_TASK_LOG_DEBUG_METHOD=SeggerRTT_LogDebug --omf_browse=..\obj\bit_operation.crf ..\..\..\module\common\Math\bit_operation.c]
                          THUMB

                          AREA ||i.ByteFactorSet||, CODE, READONLY, ALIGN=1

                  ByteFactorSet PROC
;;;51     
;;;52     uint8_t ByteFactorSet(uint8_t factor,uint8_t bit_number,X_Boolean SetOrClear)
000000  b570              PUSH     {r4-r6,lr}
;;;53     {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;54     	uint8_t  value;
;;;55     	if(SetOrClear == Set)
000008  2c01              CMP      r4,#1
00000a  d105              BNE      |L1.24|
;;;56     	{
;;;57     		value = byte_setbit(factor,bit_number);
00000c  4631              MOV      r1,r6
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       byte_setbit
000014  4603              MOV      r3,r0
000016  e004              B        |L1.34|
                  |L1.24|
;;;58     	}
;;;59     	else
;;;60     	{
;;;61     		value = byte_clearbit(factor,bit_number);
000018  4631              MOV      r1,r6
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       byte_clearbit
000020  4603              MOV      r3,r0
                  |L1.34|
;;;62     }
;;;63     
;;;64     	return value;
000022  4618              MOV      r0,r3
;;;65     }
000024  bd70              POP      {r4-r6,pc}
;;;66     
                          ENDP


                          AREA ||i.FourByteFactorSet||, CODE, READONLY, ALIGN=1

                  FourByteFactorSet PROC
;;;153    
;;;154    uint32_t FourByteFactorSet(uint32_t factor,uint8_t bit_number,X_Boolean SetOrClear)
000000  b570              PUSH     {r4-r6,lr}
;;;155    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;156    	uint32_t  value;
;;;157    	if(SetOrClear == Set)
000008  2c01              CMP      r4,#1
00000a  d105              BNE      |L2.24|
;;;158    	{
;;;159    		value = fourbyte_setbit(factor,bit_number);
00000c  4631              MOV      r1,r6
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       fourbyte_setbit
000014  4603              MOV      r3,r0
000016  e004              B        |L2.34|
                  |L2.24|
;;;160    	}
;;;161    	else
;;;162    	{
;;;163    		value = fourbyte_clearbit(factor,bit_number);
000018  4631              MOV      r1,r6
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       fourbyte_clearbit
000020  4603              MOV      r3,r0
                  |L2.34|
;;;164    }
;;;165    
;;;166    	return value;
000022  4618              MOV      r0,r3
;;;167    }
000024  bd70              POP      {r4-r6,pc}
;;;168    
                          ENDP


                          AREA ||i.GetBinaryBitNumber||, CODE, READONLY, ALIGN=2

                  GetBinaryBitNumber PROC
;;;182    
;;;183    uint8_t GetBinaryBitNumber(uint32_t value)
000000  4602              MOV      r2,r0
;;;184    {
;;;185    	uint8_t i;
;;;186    	if(value == 0) {return 1;}
000002  b90a              CBNZ     r2,|L3.8|
000004  2001              MOVS     r0,#1
                  |L3.6|
;;;187    	for(i=0;i<sizeof(power_table_for_number2)/sizeof(power_table_for_number2[0]);i++)
;;;188    	{
;;;189    		if(value < power_table_for_number2[i].result) {return i;}
;;;190    	}
;;;191    	return i+1; // 32
;;;192    }
000006  4770              BX       lr
                  |L3.8|
000008  2100              MOVS     r1,#0                 ;187
00000a  e009              B        |L3.32|
                  |L3.12|
00000c  4807              LDR      r0,|L3.44|
00000e  eb0000c1          ADD      r0,r0,r1,LSL #3       ;189
000012  6840              LDR      r0,[r0,#4]            ;189
000014  4290              CMP      r0,r2                 ;189
000016  d901              BLS      |L3.28|
000018  4608              MOV      r0,r1                 ;189
00001a  e7f4              B        |L3.6|
                  |L3.28|
00001c  1c48              ADDS     r0,r1,#1              ;187
00001e  b2c1              UXTB     r1,r0                 ;187
                  |L3.32|
000020  2920              CMP      r1,#0x20              ;187
000022  d3f3              BCC      |L3.12|
000024  1c48              ADDS     r0,r1,#1              ;191
000026  b2c0              UXTB     r0,r0                 ;191
000028  e7ed              B        |L3.6|
;;;193    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      power_table_for_number2

                          AREA ||i.GetLeadZeroCount||, CODE, READONLY, ALIGN=2

                  GetLeadZeroCount PROC
;;;214    
;;;215    uint8_t GetLeadZeroCount(uint32_t source)
000000  4601              MOV      r1,r0
;;;216    {
;;;217    	uint8_t nbr_lead_zeros;
;;;218    	uint8_t ix;
;;;219    	if (source > 0x0000FFFFu)
000002  f5b13f80          CMP      r1,#0x10000
000006  d30d              BCC      |L4.36|
;;;220    	{
;;;221    		if (source > 0x00FFFFFFu)
000008  f1b17f80          CMP      r1,#0x1000000
00000c  d303              BCC      |L4.22|
;;;222    		{
;;;223    			ix = (uint8_t)(source >> 24u);
00000e  0e0a              LSRS     r2,r1,#24
;;;224    			nbr_lead_zeros=(LeadZeroTable_8[ix]+0u);
000010  4b0c              LDR      r3,|L4.68|
000012  5c98              LDRB     r0,[r3,r2]
000014  e014              B        |L4.64|
                  |L4.22|
;;;225    		}
;;;226    		else
;;;227    		{
;;;228    			ix = (uint8_t)(source >> 16u);
000016  f3c14207          UBFX     r2,r1,#16,#8
;;;229    			nbr_lead_zeros = (LeadZeroTable_8[ix] + 8u);
00001a  4b0a              LDR      r3,|L4.68|
00001c  5c9b              LDRB     r3,[r3,r2]
00001e  3308              ADDS     r3,r3,#8
000020  b2d8              UXTB     r0,r3
000022  e00d              B        |L4.64|
                  |L4.36|
;;;230    		}
;;;231    	}
;;;232    	else
;;;233    	{
;;;234    		if (source > 0x000000FFu)
000024  29ff              CMP      r1,#0xff
000026  d906              BLS      |L4.54|
;;;235    		{
;;;236    			ix = (uint8_t)(source >> 8u);
000028  f3c12207          UBFX     r2,r1,#8,#8
;;;237    			nbr_lead_zeros = (LeadZeroTable_8[ix] + 16u);
00002c  4b05              LDR      r3,|L4.68|
00002e  5c9b              LDRB     r3,[r3,r2]
000030  3310              ADDS     r3,r3,#0x10
000032  b2d8              UXTB     r0,r3
000034  e004              B        |L4.64|
                  |L4.54|
;;;238    		}
;;;239    		else {
;;;240    			ix = (uint8_t)(source >> 0u);
000036  b2ca              UXTB     r2,r1
;;;241    			nbr_lead_zeros = (LeadZeroTable_8[ix] + 24u);
000038  4b02              LDR      r3,|L4.68|
00003a  5c9b              LDRB     r3,[r3,r2]
00003c  3318              ADDS     r3,r3,#0x18
00003e  b2d8              UXTB     r0,r3
                  |L4.64|
;;;242    		}
;;;243    	}
;;;244    	return (nbr_lead_zeros);
;;;245    }
000040  4770              BX       lr
;;;246    
                          ENDP

000042  0000              DCW      0x0000
                  |L4.68|
                          DCD      LeadZeroTable_8

                          AREA ||i.GetRearZeroCount||, CODE, READONLY, ALIGN=1

                  GetRearZeroCount PROC
;;;246    
;;;247    uint8_t GetRearZeroCount(uint32_t source)
000000  b510              PUSH     {r4,lr}
;;;248    {
000002  4604              MOV      r4,r0
;;;249    	source = uint32_rotate_bit(source);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       uint32_rotate_bit
00000a  4604              MOV      r4,r0
;;;250    	return GetLeadZeroCount(source);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       GetLeadZeroCount
;;;251    }
000012  bd10              POP      {r4,pc}
;;;252    #endif
                          ENDP


                          AREA ||i.TwoByteFactorSet||, CODE, READONLY, ALIGN=1

                  TwoByteFactorSet PROC
;;;98     
;;;99     uint16_t TwoByteFactorSet(uint16_t factor,uint8_t bit_number,X_Boolean SetOrClear)
000000  b570              PUSH     {r4-r6,lr}
;;;100    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;101    	uint16_t  value;
;;;102    	if(SetOrClear == Set)
000008  2c01              CMP      r4,#1
00000a  d105              BNE      |L6.24|
;;;103    	{
;;;104    		value = twobyte_setbit(factor,bit_number);
00000c  4631              MOV      r1,r6
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       twobyte_setbit
000014  4603              MOV      r3,r0
000016  e004              B        |L6.34|
                  |L6.24|
;;;105    	}
;;;106    	else
;;;107    	{
;;;108    		value = twobyte_clearbit(factor,bit_number);
000018  4631              MOV      r1,r6
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       twobyte_clearbit
000020  4603              MOV      r3,r0
                  |L6.34|
;;;109    }
;;;110    
;;;111    	return value;
000022  4618              MOV      r0,r3
;;;112    }
000024  bd70              POP      {r4-r6,pc}
;;;113    
                          ENDP


                          AREA ||i.byte_bitoverturn||, CODE, READONLY, ALIGN=1

                  byte_bitoverturn PROC
;;;42     }
;;;43     uint8_t byte_bitoverturn(uint8_t source,uint8_t bitnumber)
000000  2201              MOVS     r2,#1
;;;44     {
;;;45     	uint8_t bitmask = ByteMask;
;;;46     	bitmask = bitmask << bitnumber;
000002  fa02f301          LSL      r3,r2,r1
000006  b2da              UXTB     r2,r3
;;;47     	source = source ^ bitmask;
000008  4050              EORS     r0,r0,r2
;;;48     	return source;
;;;49     	
;;;50     }
00000a  4770              BX       lr
;;;51     
                          ENDP


                          AREA ||i.byte_clearbit||, CODE, READONLY, ALIGN=1

                  byte_clearbit PROC
;;;29     }
;;;30     uint8_t byte_clearbit(uint8_t source,uint8_t bitnumber)
000000  2201              MOVS     r2,#1
;;;31     {
;;;32     	source = source & (~(ByteMask << bitnumber));
000002  408a              LSLS     r2,r2,r1
000004  4390              BICS     r0,r0,r2
;;;33     	return source;
;;;34     }
000006  4770              BX       lr
;;;35     uint8_t byte_getbit(uint8_t source,uint8_t bitnumber)
                          ENDP


                          AREA ||i.byte_getbit||, CODE, READONLY, ALIGN=1

                  byte_getbit PROC
;;;34     }
;;;35     uint8_t byte_getbit(uint8_t source,uint8_t bitnumber)
000000  4602              MOV      r2,r0
;;;36     {
;;;37     	if((source & (ByteMask << bitnumber)) != 0)
000002  2001              MOVS     r0,#1
000004  4088              LSLS     r0,r0,r1
000006  4010              ANDS     r0,r0,r2
000008  b108              CBZ      r0,|L9.14|
;;;38     	{
;;;39     		return 1;
00000a  2001              MOVS     r0,#1
                  |L9.12|
;;;40     	}
;;;41     	return 0;
;;;42     }
00000c  4770              BX       lr
                  |L9.14|
00000e  2000              MOVS     r0,#0                 ;41
000010  e7fc              B        |L9.12|
;;;43     uint8_t byte_bitoverturn(uint8_t source,uint8_t bitnumber)
                          ENDP


                          AREA ||i.byte_rotate_bit||, CODE, READONLY, ALIGN=1

                  byte_rotate_bit PROC
;;;15     
;;;16     uint8_t byte_rotate_bit(uint8_t source)// ! careful about the hardware platform ,test arm 32 ok
000000  f00001aa          AND      r1,r0,#0xaa
;;;17     {
;;;18     		source = (source & 0xaa) >> 1 | (source & 0x55) << 1;
000004  1049              ASRS     r1,r1,#1
000006  f0000255          AND      r2,r0,#0x55
00000a  ea410042          ORR      r0,r1,r2,LSL #1
;;;19     		source = (source & 0xcc) >> 2 | (source & 0x33) << 2;
00000e  f00001cc          AND      r1,r0,#0xcc
000012  1089              ASRS     r1,r1,#2
000014  f0000233          AND      r2,r0,#0x33
000018  ea410082          ORR      r0,r1,r2,LSL #2
;;;20     		source = (source & 0xf0) >> 4 | (source & 0x0f) << 4;
00001c  0901              LSRS     r1,r0,#4
00001e  f000020f          AND      r2,r0,#0xf
000022  ea411002          ORR      r0,r1,r2,LSL #4
;;;21     ////////////		SEGGER_RTT_Debug(ROTATE_BIT_DEBUG,(" source: %d \r\n",source));
;;;22     		return source;
;;;23     }
000026  4770              BX       lr
;;;24     
                          ENDP


                          AREA ||i.byte_setbit||, CODE, READONLY, ALIGN=1

                  byte_setbit PROC
;;;24     
;;;25     uint8_t byte_setbit(uint8_t source,uint8_t bitnumber)
000000  2201              MOVS     r2,#1
;;;26     {
;;;27     	source = source | (ByteMask << bitnumber);
000002  408a              LSLS     r2,r2,r1
000004  4302              ORRS     r2,r2,r0
000006  b2d0              UXTB     r0,r2
;;;28     	return source;
;;;29     }
000008  4770              BX       lr
;;;30     uint8_t byte_clearbit(uint8_t source,uint8_t bitnumber)
                          ENDP


                          AREA ||i.fourbyte_bitoverturn||, CODE, READONLY, ALIGN=1

                  fourbyte_bitoverturn PROC
;;;144    
;;;145    uint32_t fourbyte_bitoverturn(uint32_t source,uint8_t bitnumber)
000000  2201              MOVS     r2,#1
;;;146    {
;;;147    	uint32_t bitmask = FourByteMask;
;;;148    	bitmask = bitmask << bitnumber;
000002  408a              LSLS     r2,r2,r1
;;;149    	source = source ^ bitmask;
000004  4050              EORS     r0,r0,r2
;;;150    	return source;
;;;151    	
;;;152    }
000006  4770              BX       lr
;;;153    
                          ENDP


                          AREA ||i.fourbyte_clearbit||, CODE, READONLY, ALIGN=1

                  fourbyte_clearbit PROC
;;;130    }
;;;131    uint32_t fourbyte_clearbit(uint32_t source,uint8_t bitnumber)
000000  2201              MOVS     r2,#1
;;;132    {
;;;133    	source = source & (~(FourByteMask << bitnumber));
000002  408a              LSLS     r2,r2,r1
000004  4390              BICS     r0,r0,r2
;;;134    	return source;
;;;135    }
000006  4770              BX       lr
;;;136    uint32_t fourbyte_getbit(uint32_t source,uint8_t bitnumber)
                          ENDP


                          AREA ||i.fourbyte_getbit||, CODE, READONLY, ALIGN=1

                  fourbyte_getbit PROC
;;;135    }
;;;136    uint32_t fourbyte_getbit(uint32_t source,uint8_t bitnumber)
000000  4602              MOV      r2,r0
;;;137    {
;;;138    	if((source & (FourByteMask << bitnumber)) != 0)
000002  2001              MOVS     r0,#1
000004  4088              LSLS     r0,r0,r1
000006  4010              ANDS     r0,r0,r2
000008  b108              CBZ      r0,|L14.14|
;;;139    	{
;;;140    		return 1;
00000a  2001              MOVS     r0,#1
                  |L14.12|
;;;141    	}
;;;142    	return 0;
;;;143    }
00000c  4770              BX       lr
                  |L14.14|
00000e  2000              MOVS     r0,#0                 ;142
000010  e7fc              B        |L14.12|
;;;144    
                          ENDP


                          AREA ||i.fourbyte_setbit||, CODE, READONLY, ALIGN=1

                  fourbyte_setbit PROC
;;;125    
;;;126    uint32_t fourbyte_setbit(uint32_t source,uint8_t bitnumber)
000000  2201              MOVS     r2,#1
;;;127    {
;;;128    	source = source | (FourByteMask << bitnumber);
000002  408a              LSLS     r2,r2,r1
000004  4310              ORRS     r0,r0,r2
;;;129    	return source;
;;;130    }
000006  4770              BX       lr
;;;131    uint32_t fourbyte_clearbit(uint32_t source,uint8_t bitnumber)
                          ENDP


                          AREA ||i.twobyte_bitoverturn||, CODE, READONLY, ALIGN=1

                  twobyte_bitoverturn PROC
;;;89     
;;;90     uint16_t twobyte_bitoverturn(uint16_t source,uint8_t bitnumber)
000000  2201              MOVS     r2,#1
;;;91     {
;;;92     	uint16_t bitmask = TwoByteMask;
;;;93     	bitmask = bitmask << bitnumber;
000002  fa02f301          LSL      r3,r2,r1
000006  b29a              UXTH     r2,r3
;;;94     	source = source ^ bitmask;
000008  4050              EORS     r0,r0,r2
;;;95     	return source;
;;;96     	
;;;97     }
00000a  4770              BX       lr
;;;98     
                          ENDP


                          AREA ||i.twobyte_clearbit||, CODE, READONLY, ALIGN=1

                  twobyte_clearbit PROC
;;;75     }
;;;76     uint16_t twobyte_clearbit(uint16_t source,uint8_t bitnumber)
000000  2201              MOVS     r2,#1
;;;77     {
;;;78     	source = source & (~(TwoByteMask << bitnumber));
000002  408a              LSLS     r2,r2,r1
000004  4390              BICS     r0,r0,r2
;;;79     	return source;
;;;80     }
000006  4770              BX       lr
;;;81     uint16_t twobyte_getbit(uint16_t source,uint8_t bitnumber)
                          ENDP


                          AREA ||i.twobyte_getbit||, CODE, READONLY, ALIGN=1

                  twobyte_getbit PROC
;;;80     }
;;;81     uint16_t twobyte_getbit(uint16_t source,uint8_t bitnumber)
000000  4602              MOV      r2,r0
;;;82     {
;;;83     	if((source & (TwoByteMask << bitnumber)) != 0)
000002  2001              MOVS     r0,#1
000004  4088              LSLS     r0,r0,r1
000006  4010              ANDS     r0,r0,r2
000008  b108              CBZ      r0,|L18.14|
;;;84     	{
;;;85     		return 1;
00000a  2001              MOVS     r0,#1
                  |L18.12|
;;;86     	}
;;;87     	return 0;
;;;88     }
00000c  4770              BX       lr
                  |L18.14|
00000e  2000              MOVS     r0,#0                 ;87
000010  e7fc              B        |L18.12|
;;;89     
                          ENDP


                          AREA ||i.twobyte_setbit||, CODE, READONLY, ALIGN=1

                  twobyte_setbit PROC
;;;70     
;;;71     uint16_t twobyte_setbit(uint16_t source,uint8_t bitnumber)
000000  2201              MOVS     r2,#1
;;;72     {
;;;73     	source = source | (TwoByteMask << bitnumber);
000002  408a              LSLS     r2,r2,r1
000004  4302              ORRS     r2,r2,r0
000006  b290              UXTH     r0,r2
;;;74     	return source;
;;;75     }
000008  4770              BX       lr
;;;76     uint16_t twobyte_clearbit(uint16_t source,uint8_t bitnumber)
                          ENDP


                          AREA ||i.uint32_rotate_bit||, CODE, READONLY, ALIGN=1

                  uint32_rotate_bit PROC
;;;113    
;;;114    uint32_t uint32_rotate_bit(uint32_t source)// ! careful about the hardware platform
000000  4601              MOV      r1,r0
;;;115    {
;;;116    	source = (((source & 0xaaaaaaaa) >> 1) | ((source & 0x55555555) << 1));
000002  f00130aa          AND      r0,r1,#0xaaaaaaaa
000006  0840              LSRS     r0,r0,#1
000008  f0013255          AND      r2,r1,#0x55555555
00000c  ea400142          ORR      r1,r0,r2,LSL #1
;;;117    	source = (((source & 0xcccccccc) >> 2) | ((source & 0x33333333) << 2));
000010  f00130cc          AND      r0,r1,#0xcccccccc
000014  0880              LSRS     r0,r0,#2
000016  f0013233          AND      r2,r1,#0x33333333
00001a  ea400182          ORR      r1,r0,r2,LSL #2
;;;118    	source = (((source & 0xf0f0f0f0) >> 4) | ((source & 0x0f0f0f0f) << 4));
00001e  f00130f0          AND      r0,r1,#0xf0f0f0f0
000022  0900              LSRS     r0,r0,#4
000024  f001320f          AND      r2,r1,#0xf0f0f0f
000028  ea401102          ORR      r1,r0,r2,LSL #4
;;;119    	source = (((source & 0xff00ff00) >> 8) | ((source & 0x00ff00ff) << 8));
00002c  f00120ff          AND      r0,r1,#0xff00ff00
000030  0a00              LSRS     r0,r0,#8
000032  f00112ff          AND      r2,r1,#0xff00ff
000036  ea402102          ORR      r1,r0,r2,LSL #8
;;;120        return((source >> 16) | (source << 16));
00003a  0c08              LSRS     r0,r1,#16
00003c  ea404001          ORR      r0,r0,r1,LSL #16
;;;121    }
000040  4770              BX       lr
;;;122    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  power_table_for_number2
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000001
000008  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0x00000002
000010  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0x00000004
000018  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0x00000008
000020  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      0x00000010
000028  05000000          DCB      0x05,0x00,0x00,0x00
                          DCD      0x00000020
000030  06000000          DCB      0x06,0x00,0x00,0x00
                          DCD      0x00000040
000038  07000000          DCB      0x07,0x00,0x00,0x00
                          DCD      0x00000080
000040  08000000          DCB      0x08,0x00,0x00,0x00
                          DCD      0x00000100
000048  09000000          DCB      0x09,0x00,0x00,0x00
                          DCD      0x00000200
000050  0a000000          DCB      0x0a,0x00,0x00,0x00
                          DCD      0x00000400
000058  0b000000          DCB      0x0b,0x00,0x00,0x00
                          DCD      0x00000800
000060  0c000000          DCB      0x0c,0x00,0x00,0x00
                          DCD      0x00001000
000068  0d000000          DCB      0x0d,0x00,0x00,0x00
                          DCD      0x00002000
000070  0e000000          DCB      0x0e,0x00,0x00,0x00
                          DCD      0x00004000
000078  0f000000          DCB      0x0f,0x00,0x00,0x00
                          DCD      0x0004fe00
000080  10000000          DCB      0x10,0x00,0x00,0x00
                          DCD      0x00010000
000088  11000000          DCB      0x11,0x00,0x00,0x00
                          DCD      0x00020000
000090  12000000          DCB      0x12,0x00,0x00,0x00
                          DCD      0x00040000
000098  13000000          DCB      0x13,0x00,0x00,0x00
                          DCD      0x00080000
0000a0  14000000          DCB      0x14,0x00,0x00,0x00
                          DCD      0x00100000
0000a8  15000000          DCB      0x15,0x00,0x00,0x00
                          DCD      0x00200000
0000b0  16000000          DCB      0x16,0x00,0x00,0x00
                          DCD      0x00400000
0000b8  17000000          DCB      0x17,0x00,0x00,0x00
                          DCD      0x00800000
0000c0  18000000          DCB      0x18,0x00,0x00,0x00
                          DCD      0x01000000
0000c8  19000000          DCB      0x19,0x00,0x00,0x00
                          DCD      0x02000000
0000d0  1a000000          DCB      0x1a,0x00,0x00,0x00
                          DCD      0x04000000
0000d8  1b000000          DCB      0x1b,0x00,0x00,0x00
                          DCD      0x08000000
0000e0  1c000000          DCB      0x1c,0x00,0x00,0x00
                          DCD      0x10000000
0000e8  1d000000          DCB      0x1d,0x00,0x00,0x00
                          DCD      0x20000000
0000f0  1e000000          DCB      0x1e,0x00,0x00,0x00
                          DCD      0x40000000
0000f8  1f000000          DCB      0x1f,0x00,0x00,0x00
                          DCD      0x80000000
                  LeadZeroTable_8
000100  08070606          DCB      0x08,0x07,0x06,0x06
000104  05050505          DCB      0x05,0x05,0x05,0x05
000108  04040404          DCB      0x04,0x04,0x04,0x04
00010c  04040404          DCB      0x04,0x04,0x04,0x04
000110  03030303          DCB      0x03,0x03,0x03,0x03
000114  03030303          DCB      0x03,0x03,0x03,0x03
000118  03030303          DCB      0x03,0x03,0x03,0x03
00011c  03030303          DCB      0x03,0x03,0x03,0x03
000120  02020202          DCB      0x02,0x02,0x02,0x02
000124  02020202          DCB      0x02,0x02,0x02,0x02
000128  02020202          DCB      0x02,0x02,0x02,0x02
00012c  02020202          DCB      0x02,0x02,0x02,0x02
000130  02020202          DCB      0x02,0x02,0x02,0x02
000134  02020202          DCB      0x02,0x02,0x02,0x02
000138  02020202          DCB      0x02,0x02,0x02,0x02
00013c  02020202          DCB      0x02,0x02,0x02,0x02
000140  01010101          DCB      0x01,0x01,0x01,0x01
000144  01010101          DCB      0x01,0x01,0x01,0x01
000148  01010101          DCB      0x01,0x01,0x01,0x01
00014c  01010101          DCB      0x01,0x01,0x01,0x01
000150  01010101          DCB      0x01,0x01,0x01,0x01
000154  01010101          DCB      0x01,0x01,0x01,0x01
000158  01010101          DCB      0x01,0x01,0x01,0x01
00015c  01010101          DCB      0x01,0x01,0x01,0x01
000160  01010101          DCB      0x01,0x01,0x01,0x01
000164  01010101          DCB      0x01,0x01,0x01,0x01
000168  01010101          DCB      0x01,0x01,0x01,0x01
00016c  01010101          DCB      0x01,0x01,0x01,0x01
000170  01010101          DCB      0x01,0x01,0x01,0x01
000174  01010101          DCB      0x01,0x01,0x01,0x01
000178  01010101          DCB      0x01,0x01,0x01,0x01
00017c  01010101          DCB      0x01,0x01,0x01,0x01
000180  00000000          DCB      0x00,0x00,0x00,0x00
000184  00000000          DCB      0x00,0x00,0x00,0x00
000188  00000000          DCB      0x00,0x00,0x00,0x00
00018c  00000000          DCB      0x00,0x00,0x00,0x00
000190  00000000          DCB      0x00,0x00,0x00,0x00
000194  00000000          DCB      0x00,0x00,0x00,0x00
000198  00000000          DCB      0x00,0x00,0x00,0x00
00019c  00000000          DCB      0x00,0x00,0x00,0x00
0001a0  00000000          DCB      0x00,0x00,0x00,0x00
0001a4  00000000          DCB      0x00,0x00,0x00,0x00
0001a8  00000000          DCB      0x00,0x00,0x00,0x00
0001ac  00000000          DCB      0x00,0x00,0x00,0x00
0001b0  00000000          DCB      0x00,0x00,0x00,0x00
0001b4  00000000          DCB      0x00,0x00,0x00,0x00
0001b8  00000000          DCB      0x00,0x00,0x00,0x00
0001bc  00000000          DCB      0x00,0x00,0x00,0x00
0001c0  00000000          DCB      0x00,0x00,0x00,0x00
0001c4  00000000          DCB      0x00,0x00,0x00,0x00
0001c8  00000000          DCB      0x00,0x00,0x00,0x00
0001cc  00000000          DCB      0x00,0x00,0x00,0x00
0001d0  00000000          DCB      0x00,0x00,0x00,0x00
0001d4  00000000          DCB      0x00,0x00,0x00,0x00
0001d8  00000000          DCB      0x00,0x00,0x00,0x00
0001dc  00000000          DCB      0x00,0x00,0x00,0x00
0001e0  00000000          DCB      0x00,0x00,0x00,0x00
0001e4  00000000          DCB      0x00,0x00,0x00,0x00
0001e8  00000000          DCB      0x00,0x00,0x00,0x00
0001ec  00000000          DCB      0x00,0x00,0x00,0x00
0001f0  00000000          DCB      0x00,0x00,0x00,0x00
0001f4  00000000          DCB      0x00,0x00,0x00,0x00
0001f8  00000000          DCB      0x00,0x00,0x00,0x00
0001fc  00000000          DCB      0x00,0x00,0x00,0x00
