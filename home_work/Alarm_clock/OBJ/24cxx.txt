; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\24cxx.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\24cxx.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\HARDWARE\LED -I..\HARDWARE\LCD -I..\HARDWARE\KEY -I..\HARDWARE\SRAM -I..\HARDWARE\SDIO -I..\MALLOC -I..\USMART -I..\HARDWARE\SPI -I..\HARDWARE\W25QXX -I..\FATFS\exfuns -I..\FATFS\src -I..\TEXT -I..\FWLIB\inc -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\I2S -I..\HARDWARE\WM8978 -I..\APP -I..\AUDIOCODEC\wav -I..\new_user -I..\new_user\task -I..\new_user\MVC -I..\..\..\module\common -I..\..\..\module\common\InsertLog -I..\..\..\module\common\loopqueue -I..\..\..\module\common\StateMachine -I..\..\..\module\common\priorityqueue -I..\..\..\module\common\Math -I..\..\..\module\component\const_loop_scheduler -I..\..\..\module\component\const_loop_scheduler\TemplateTask -I..\..\..\module\component\const_loop_scheduler\HierarchicalSM -I..\..\..\module\component\BlockableStateMachine -I..\..\..\module\customize\ButtonModule -I..\..\..\module\external\Segger\SEGGER_RTT_V640\Syscalls -I..\..\..\module\external\Segger\SEGGER_RTT_V640\RTT -I.\RTE\_AudioPlayer -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include" -I"D:\Program Files\ARM\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_COMPILER_PRESENT -DX_TASK_LOG_DEBUG_METHOD=SeggerRTT_LogDebug --omf_browse=..\obj\24cxx.crf ..\HARDWARE\24CXX\24cxx.c]
                          THUMB

                          AREA ||i.AT24CXX_Check||, CODE, READONLY, ALIGN=1

                  AT24CXX_Check PROC
;;;98     //返回0:检测成功
;;;99     u8 AT24CXX_Check(void)
000000  b510              PUSH     {r4,lr}
;;;100    {
;;;101    	u8 temp;
;;;102    	temp=AT24CXX_ReadOneByte(255);//避免每次开机都写AT24CXX			   
000002  20ff              MOVS     r0,#0xff
000004  f7fffffe          BL       AT24CXX_ReadOneByte
000008  4604              MOV      r4,r0
;;;103    	if(temp==0X55)return 0;		   
00000a  2c55              CMP      r4,#0x55
00000c  d101              BNE      |L1.18|
00000e  2000              MOVS     r0,#0
                  |L1.16|
;;;104    	else//排除第一次初始化的情况
;;;105    	{
;;;106    		AT24CXX_WriteOneByte(255,0X55);
;;;107    	    temp=AT24CXX_ReadOneByte(255);	  
;;;108    		if(temp==0X55)return 0;
;;;109    	}
;;;110    	return 1;											  
;;;111    }
000010  bd10              POP      {r4,pc}
                  |L1.18|
000012  2155              MOVS     r1,#0x55              ;106
000014  20ff              MOVS     r0,#0xff              ;106
000016  f7fffffe          BL       AT24CXX_WriteOneByte
00001a  20ff              MOVS     r0,#0xff              ;107
00001c  f7fffffe          BL       AT24CXX_ReadOneByte
000020  4604              MOV      r4,r0                 ;107
000022  2c55              CMP      r4,#0x55              ;108
000024  d101              BNE      |L1.42|
000026  2000              MOVS     r0,#0                 ;108
000028  e7f2              B        |L1.16|
                  |L1.42|
00002a  2001              MOVS     r0,#1                 ;110
00002c  e7f0              B        |L1.16|
;;;112    
                          ENDP


                          AREA ||i.AT24CXX_Init||, CODE, READONLY, ALIGN=1

                  AT24CXX_Init PROC
;;;16     //初始化IIC接口
;;;17     void AT24CXX_Init(void)
000000  b510              PUSH     {r4,lr}
;;;18     {
;;;19     	IIC_Init();//IIC初始化
000002  f7fffffe          BL       IIC_Init
;;;20     }
000006  bd10              POP      {r4,pc}
;;;21     //在AT24CXX指定地址读出一个数据
                          ENDP


                          AREA ||i.AT24CXX_Read||, CODE, READONLY, ALIGN=1

                  AT24CXX_Read PROC
;;;116    //NumToRead:要读出数据的个数
;;;117    void AT24CXX_Read(u16 ReadAddr,u8 *pBuffer,u16 NumToRead)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;119    	while(NumToRead)
000008  e008              B        |L3.28|
                  |L3.10|
;;;120    	{
;;;121    		*pBuffer++=AT24CXX_ReadOneByte(ReadAddr++);	
00000a  4630              MOV      r0,r6
00000c  1c72              ADDS     r2,r6,#1
00000e  b296              UXTH     r6,r2
000010  f7fffffe          BL       AT24CXX_ReadOneByte
000014  f8040b01          STRB     r0,[r4],#1
;;;122    		NumToRead--;
000018  1e68              SUBS     r0,r5,#1
00001a  b285              UXTH     r5,r0
                  |L3.28|
00001c  2d00              CMP      r5,#0                 ;119
00001e  d1f4              BNE      |L3.10|
;;;123    	}
;;;124    }  
000020  bd70              POP      {r4-r6,pc}
;;;125    //在AT24CXX里面的指定地址开始写入指定个数的数据
                          ENDP


                          AREA ||i.AT24CXX_ReadLenByte||, CODE, READONLY, ALIGN=1

                  AT24CXX_ReadLenByte PROC
;;;82     //Len        :要读出数据的长度2,4
;;;83     u32 AT24CXX_ReadLenByte(u16 ReadAddr,u8 Len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     {  	
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;85     	u8 t;
;;;86     	u32 temp=0;
000008  2600              MOVS     r6,#0
;;;87     	for(t=0;t<Len;t++)
00000a  2500              MOVS     r5,#0
00000c  e009              B        |L4.34|
                  |L4.14|
;;;88     	{
;;;89     		temp<<=8;
00000e  0236              LSLS     r6,r6,#8
;;;90     		temp+=AT24CXX_ReadOneByte(ReadAddr+Len-t-1); 	 				   
000010  1939              ADDS     r1,r7,r4
000012  1b49              SUBS     r1,r1,r5
000014  1e49              SUBS     r1,r1,#1
000016  b288              UXTH     r0,r1
000018  f7fffffe          BL       AT24CXX_ReadOneByte
00001c  4406              ADD      r6,r6,r0
00001e  1c68              ADDS     r0,r5,#1              ;87
000020  b2c5              UXTB     r5,r0                 ;87
                  |L4.34|
000022  42a5              CMP      r5,r4                 ;87
000024  dbf3              BLT      |L4.14|
;;;91     	}
;;;92     	return temp;												    
000026  4630              MOV      r0,r6
;;;93     }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;94     //检查AT24CXX是否正常
                          ENDP


                          AREA ||i.AT24CXX_ReadOneByte||, CODE, READONLY, ALIGN=1

                  AT24CXX_ReadOneByte PROC
;;;23     //返回值  :读到的数据
;;;24     u8 AT24CXX_ReadOneByte(u16 ReadAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;25     {				  
000002  4604              MOV      r4,r0
;;;26     	u8 temp=0;		  	    																 
000004  2600              MOVS     r6,#0
;;;27         IIC_Start();  
000006  f7fffffe          BL       IIC_Start
;;;28     	if(EE_TYPE>AT24C16)
;;;29     	{
;;;30     		IIC_Send_Byte(0XA0);	   //发送写命令
;;;31     		IIC_Wait_Ack();
;;;32     		IIC_Send_Byte(ReadAddr>>8);//发送高地址	    
;;;33     	}else IIC_Send_Byte(0XA0+((ReadAddr/256)<<1));   //发送器件地址0XA0,写数据 	   
00000a  4625              MOV      r5,r4
00000c  17e1              ASRS     r1,r4,#31
00000e  eb046111          ADD      r1,r4,r1,LSR #24
000012  1209              ASRS     r1,r1,#8
000014  22a0              MOVS     r2,#0xa0
000016  eb020141          ADD      r1,r2,r1,LSL #1
00001a  b2c8              UXTB     r0,r1
00001c  f7fffffe          BL       IIC_Send_Byte
;;;34     	IIC_Wait_Ack(); 
000020  f7fffffe          BL       IIC_Wait_Ack
;;;35         IIC_Send_Byte(ReadAddr%256);   //发送低地址
000024  17e1              ASRS     r1,r4,#31
000026  eb046111          ADD      r1,r4,r1,LSR #24
00002a  1209              ASRS     r1,r1,#8
00002c  eba42101          SUB      r1,r4,r1,LSL #8
000030  b2c8              UXTB     r0,r1
000032  f7fffffe          BL       IIC_Send_Byte
;;;36     	IIC_Wait_Ack();	    
000036  f7fffffe          BL       IIC_Wait_Ack
;;;37     	IIC_Start();  	 	   
00003a  f7fffffe          BL       IIC_Start
;;;38     	IIC_Send_Byte(0XA1);           //进入接收模式			   
00003e  20a1              MOVS     r0,#0xa1
000040  f7fffffe          BL       IIC_Send_Byte
;;;39     	IIC_Wait_Ack();	 
000044  f7fffffe          BL       IIC_Wait_Ack
;;;40         temp=IIC_Read_Byte(0);		   
000048  2000              MOVS     r0,#0
00004a  f7fffffe          BL       IIC_Read_Byte
00004e  4606              MOV      r6,r0
;;;41         IIC_Stop();//产生一个停止条件	    
000050  f7fffffe          BL       IIC_Stop
;;;42     	return temp;
000054  4630              MOV      r0,r6
;;;43     }
000056  bd70              POP      {r4-r6,pc}
;;;44     //在AT24CXX指定地址写入一个数据
                          ENDP


                          AREA ||i.AT24CXX_Write||, CODE, READONLY, ALIGN=1

                  AT24CXX_Write PROC
;;;128    //NumToWrite:要写入数据的个数
;;;129    void AT24CXX_Write(u16 WriteAddr,u8 *pBuffer,u16 NumToWrite)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;131    	while(NumToWrite--)
000008  e006              B        |L6.24|
                  |L6.10|
;;;132    	{
;;;133    		AT24CXX_WriteOneByte(WriteAddr,*pBuffer);
00000a  7821              LDRB     r1,[r4,#0]
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       AT24CXX_WriteOneByte
;;;134    		WriteAddr++;
000012  1c68              ADDS     r0,r5,#1
000014  b285              UXTH     r5,r0
;;;135    		pBuffer++;
000016  1c64              ADDS     r4,r4,#1
                  |L6.24|
000018  1e30              SUBS     r0,r6,#0              ;131
00001a  f1a60101          SUB      r1,r6,#1              ;131
00001e  b28e              UXTH     r6,r1                 ;131
000020  d1f3              BNE      |L6.10|
;;;136    	}
;;;137    }
000022  bd70              POP      {r4-r6,pc}
;;;138    
                          ENDP


                          AREA ||i.AT24CXX_WriteLenByte||, CODE, READONLY, ALIGN=1

                  AT24CXX_WriteLenByte PROC
;;;68     //Len        :要写入数据的长度2,4
;;;69     void AT24CXX_WriteLenByte(u16 WriteAddr,u32 DataToWrite,u8 Len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;70     {  	
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;71     	u8 t;
;;;72     	for(t=0;t<Len;t++)
00000a  2400              MOVS     r4,#0
00000c  e009              B        |L7.34|
                  |L7.14|
;;;73     	{
;;;74     		AT24CXX_WriteOneByte(WriteAddr+t,(DataToWrite>>(8*t))&0xff);
00000e  00e2              LSLS     r2,r4,#3
000010  fa26f202          LSR      r2,r6,r2
000014  b2d1              UXTB     r1,r2
000016  192a              ADDS     r2,r5,r4
000018  b290              UXTH     r0,r2
00001a  f7fffffe          BL       AT24CXX_WriteOneByte
00001e  1c60              ADDS     r0,r4,#1              ;72
000020  b2c4              UXTB     r4,r0                 ;72
                  |L7.34|
000022  42bc              CMP      r4,r7                 ;72
000024  dbf3              BLT      |L7.14|
;;;75     	}												    
;;;76     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;77     
                          ENDP


                          AREA ||i.AT24CXX_WriteOneByte||, CODE, READONLY, ALIGN=1

                  AT24CXX_WriteOneByte PROC
;;;46     //DataToWrite:要写入的数据
;;;47     void AT24CXX_WriteOneByte(u16 WriteAddr,u8 DataToWrite)
000000  b570              PUSH     {r4-r6,lr}
;;;48     {				   	  	    																 
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;49         IIC_Start();  
000006  f7fffffe          BL       IIC_Start
;;;50     	if(EE_TYPE>AT24C16)
;;;51     	{
;;;52     		IIC_Send_Byte(0XA0);	    //发送写命令
;;;53     		IIC_Wait_Ack();
;;;54     		IIC_Send_Byte(WriteAddr>>8);//发送高地址	  
;;;55     	}else IIC_Send_Byte(0XA0+((WriteAddr/256)<<1));   //发送器件地址0XA0,写数据 	 
00000a  4625              MOV      r5,r4
00000c  17e1              ASRS     r1,r4,#31
00000e  eb046111          ADD      r1,r4,r1,LSR #24
000012  1209              ASRS     r1,r1,#8
000014  22a0              MOVS     r2,#0xa0
000016  eb020141          ADD      r1,r2,r1,LSL #1
00001a  b2c8              UXTB     r0,r1
00001c  f7fffffe          BL       IIC_Send_Byte
;;;56     	IIC_Wait_Ack();	   
000020  f7fffffe          BL       IIC_Wait_Ack
;;;57         IIC_Send_Byte(WriteAddr%256);   //发送低地址
000024  17e1              ASRS     r1,r4,#31
000026  eb046111          ADD      r1,r4,r1,LSR #24
00002a  1209              ASRS     r1,r1,#8
00002c  eba42101          SUB      r1,r4,r1,LSL #8
000030  b2c8              UXTB     r0,r1
000032  f7fffffe          BL       IIC_Send_Byte
;;;58     	IIC_Wait_Ack(); 	 										  		   
000036  f7fffffe          BL       IIC_Wait_Ack
;;;59     	IIC_Send_Byte(DataToWrite);     //发送字节							   
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       IIC_Send_Byte
;;;60     	IIC_Wait_Ack();  		    	   
000040  f7fffffe          BL       IIC_Wait_Ack
;;;61         IIC_Stop();//产生一个停止条件 
000044  f7fffffe          BL       IIC_Stop
;;;62     	delay_ms(10);	 
000048  200a              MOVS     r0,#0xa
00004a  f7fffffe          BL       delay_ms
;;;63     }
00004e  bd70              POP      {r4-r6,pc}
;;;64     //在AT24CXX里面的指定地址开始写入长度为Len的数据
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\HARDWARE\\24CXX\\24cxx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_24cxx_c_ad1b7485____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___7_24cxx_c_ad1b7485____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_24cxx_c_ad1b7485____REVSH|
#line 144
|__asm___7_24cxx_c_ad1b7485____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
