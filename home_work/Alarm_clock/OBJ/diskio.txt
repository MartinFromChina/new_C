; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\diskio.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\diskio.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USER -I..\HARDWARE\LED -I..\HARDWARE\LCD -I..\HARDWARE\KEY -I..\HARDWARE\SRAM -I..\HARDWARE\SDIO -I..\MALLOC -I..\USMART -I..\HARDWARE\SPI -I..\HARDWARE\W25QXX -I..\FATFS\exfuns -I..\FATFS\src -I..\TEXT -I..\FWLIB\inc -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\I2S -I..\HARDWARE\WM8978 -I..\APP -I..\AUDIOCODEC\wav -I..\new_user -I..\new_user\task -I..\new_user\MVC -I..\..\..\module\common -I..\..\..\module\common\InsertLog -I..\..\..\module\common\loopqueue -I..\..\..\module\common\StateMachine -I..\..\..\module\common\priorityqueue -I..\..\..\module\common\Math -I..\..\..\module\component\const_loop_scheduler -I..\..\..\module\component\const_loop_scheduler\TemplateTask -I..\..\..\module\component\const_loop_scheduler\HierarchicalSM -I..\..\..\module\component\BlockableStateMachine -I..\..\..\module\customize\ButtonModule -I..\..\..\module\external\Segger\SEGGER_RTT_V640\Syscalls -I..\..\..\module\external\Segger\SEGGER_RTT_V640\RTT -I.\RTE\_AudioPlayer -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include" -I"D:\Program Files\ARM\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F4xx_DFP\2.7.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_COMPILER_PRESENT -DX_TASK_LOG_DEBUG_METHOD=SeggerRTT_LogDebug --omf_browse=..\obj\diskio.crf ..\FATFS\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=2

                  disk_initialize PROC
;;;37     //初始化磁盘
;;;38     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;39     	BYTE pdrv				/* Physical drive nmuber (0..) */
;;;40     )
;;;41     {
000002  4604              MOV      r4,r0
;;;42     	u8 res=0;	    
000004  2500              MOVS     r5,#0
;;;43     	switch(pdrv)
000006  b114              CBZ      r4,|L1.14|
000008  2c01              CMP      r4,#1
00000a  d10b              BNE      |L1.36|
00000c  e003              B        |L1.22|
                  |L1.14|
;;;44     	{
;;;45     		case SD_CARD://SD卡
;;;46     			res=SD_Init();//SD卡初始化 
00000e  f7fffffe          BL       SD_Init
000012  4605              MOV      r5,r0
;;;47       			break;
000014  e008              B        |L1.40|
                  |L1.22|
;;;48     		case EX_FLASH://外部flash
;;;49     			W25QXX_Init();
000016  f7fffffe          BL       W25QXX_Init
;;;50     			FLASH_SECTOR_COUNT=2048*12;//W25Q1218,前12M字节给FATFS占用 
00001a  f44f40c0          MOV      r0,#0x6000
00001e  4905              LDR      r1,|L1.52|
000020  8008              STRH     r0,[r1,#0]
;;;51      			break;
000022  e001              B        |L1.40|
                  |L1.36|
;;;52     		default:
;;;53     			res=1; 
000024  2501              MOVS     r5,#1
000026  bf00              NOP                            ;43
                  |L1.40|
000028  bf00              NOP                            ;47
;;;54     	}		 
;;;55     	if(res)return  STA_NOINIT;
00002a  b10d              CBZ      r5,|L1.48|
00002c  2001              MOVS     r0,#1
                  |L1.46|
;;;56     	else return 0; //初始化成功
;;;57     }  
00002e  bd70              POP      {r4-r6,pc}
                  |L1.48|
000030  2000              MOVS     r0,#0                 ;56
000032  e7fc              B        |L1.46|
;;;58     
                          ENDP

                  |L1.52|
                          DCD      FLASH_SECTOR_COUNT

                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;158    #if _USE_IOCTL
;;;159    DRESULT disk_ioctl (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;160    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;161    	BYTE cmd,		/* Control code */
;;;162    	void *buff		/* Buffer to send/receive control data */
;;;163    )
;;;164    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;165    	DRESULT res;						  			     
;;;166    	if(pdrv==SD_CARD)//SD卡
00000a  bb46              CBNZ     r6,|L2.94|
;;;167    	{
;;;168    	    switch(cmd)
00000c  f1b90f00          CMP      r9,#0
000010  d009              BEQ      |L2.38|
000012  f1b90f01          CMP      r9,#1
000016  d013              BEQ      |L2.64|
000018  f1b90f02          CMP      r9,#2
00001c  d005              BEQ      |L2.42|
00001e  f1b90f03          CMP      r9,#3
000022  d119              BNE      |L2.88|
000024  e006              B        |L2.52|
                  |L2.38|
;;;169    	    {
;;;170    		    case CTRL_SYNC:
;;;171    				res = RES_OK; 
000026  2400              MOVS     r4,#0
;;;172    		        break;	 
000028  e018              B        |L2.92|
                  |L2.42|
;;;173    		    case GET_SECTOR_SIZE:
;;;174    				*(DWORD*)buff = 512; 
00002a  f44f7000          MOV      r0,#0x200
00002e  6028              STR      r0,[r5,#0]
;;;175    		        res = RES_OK;
000030  2400              MOVS     r4,#0
;;;176    		        break;	 
000032  e013              B        |L2.92|
                  |L2.52|
;;;177    		    case GET_BLOCK_SIZE:
;;;178    				*(WORD*)buff = SDCardInfo.CardBlockSize;
000034  481d              LDR      r0,|L2.172|
000036  f8b00050          LDRH     r0,[r0,#0x50]  ; SDCardInfo
00003a  8028              STRH     r0,[r5,#0]
;;;179    		        res = RES_OK;
00003c  2400              MOVS     r4,#0
;;;180    		        break;	 
00003e  e00d              B        |L2.92|
                  |L2.64|
;;;181    		    case GET_SECTOR_COUNT:
;;;182    		        *(DWORD*)buff = SDCardInfo.CardCapacity/512;
000040  481a              LDR      r0,|L2.172|
000042  f44f7200          MOV      r2,#0x200
000046  2300              MOVS     r3,#0
000048  e9d07112          LDRD     r7,r1,[r0,#0x48]
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       __aeabi_ldivmod
000052  6028              STR      r0,[r5,#0]
;;;183    		        res = RES_OK;
000054  2400              MOVS     r4,#0
;;;184    		        break;
000056  e001              B        |L2.92|
                  |L2.88|
;;;185    		    default:
;;;186    		        res = RES_PARERR;
000058  2404              MOVS     r4,#4
;;;187    		        break;
00005a  bf00              NOP      
                  |L2.92|
00005c  e022              B        |L2.164|
                  |L2.94|
;;;188    	    }
;;;189    	}else if(pdrv==EX_FLASH)	//外部FLASH  
00005e  2e01              CMP      r6,#1
000060  d11f              BNE      |L2.162|
;;;190    	{
;;;191    	    switch(cmd)
000062  f1b90f00          CMP      r9,#0
000066  d009              BEQ      |L2.124|
000068  f1b90f01          CMP      r9,#1
00006c  d011              BEQ      |L2.146|
00006e  f1b90f02          CMP      r9,#2
000072  d005              BEQ      |L2.128|
000074  f1b90f03          CMP      r9,#3
000078  d110              BNE      |L2.156|
00007a  e006              B        |L2.138|
                  |L2.124|
;;;192    	    {
;;;193    		    case CTRL_SYNC:
;;;194    				res = RES_OK; 
00007c  2400              MOVS     r4,#0
;;;195    		        break;	 
00007e  e00f              B        |L2.160|
                  |L2.128|
;;;196    		    case GET_SECTOR_SIZE:
;;;197    		        *(WORD*)buff = FLASH_SECTOR_SIZE;
000080  f44f7000          MOV      r0,#0x200
000084  8028              STRH     r0,[r5,#0]
;;;198    		        res = RES_OK;
000086  2400              MOVS     r4,#0
;;;199    		        break;	 
000088  e00a              B        |L2.160|
                  |L2.138|
;;;200    		    case GET_BLOCK_SIZE:
;;;201    		        *(WORD*)buff = FLASH_BLOCK_SIZE;
00008a  2008              MOVS     r0,#8
00008c  8028              STRH     r0,[r5,#0]
;;;202    		        res = RES_OK;
00008e  2400              MOVS     r4,#0
;;;203    		        break;	 
000090  e006              B        |L2.160|
                  |L2.146|
;;;204    		    case GET_SECTOR_COUNT:
;;;205    		        *(DWORD*)buff = FLASH_SECTOR_COUNT;
000092  4807              LDR      r0,|L2.176|
000094  8800              LDRH     r0,[r0,#0]  ; FLASH_SECTOR_COUNT
000096  6028              STR      r0,[r5,#0]
;;;206    		        res = RES_OK;
000098  2400              MOVS     r4,#0
;;;207    		        break;
00009a  e001              B        |L2.160|
                  |L2.156|
;;;208    		    default:
;;;209    		        res = RES_PARERR;
00009c  2404              MOVS     r4,#4
;;;210    		        break;
00009e  bf00              NOP      
                  |L2.160|
0000a0  e000              B        |L2.164|
                  |L2.162|
;;;211    	    }
;;;212    	}else res=RES_ERROR;//其他的不支持
0000a2  2401              MOVS     r4,#1
                  |L2.164|
;;;213        return res;
0000a4  4620              MOV      r0,r4
;;;214    }
0000a6  e8bd87f0          POP      {r4-r10,pc}
;;;215    #endif
                          ENDP

0000aa  0000              DCW      0x0000
                  |L2.172|
                          DCD      SDCardInfo
                  |L2.176|
                          DCD      FLASH_SECTOR_COUNT

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;71     //count:需要读取的扇区数
;;;72     DRESULT disk_read (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;73     	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;74     	BYTE *buff,		/* Data buffer to store read data */
;;;75     	DWORD sector,	/* Sector address (LBA) */
;;;76     	UINT count		/* Number of sectors to read (1..128) */
;;;77     )
;;;78     {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
;;;79     	u8 res=0; 
00000c  f04f0800          MOV      r8,#0
;;;80         if (!count)return RES_PARERR;//count不能等于0，否则返回参数错误		 	 
000010  b914              CBNZ     r4,|L3.24|
000012  2004              MOVS     r0,#4
                  |L3.20|
;;;81     	switch(pdrv)
;;;82     	{
;;;83     		case SD_CARD://SD卡
;;;84     			res=SD_ReadDisk(buff,sector,count);	 
;;;85     			while(res)//读出错
;;;86     			{
;;;87     				SD_Init();	//重新初始化SD卡
;;;88     				res=SD_ReadDisk(buff,sector,count);	
;;;89     				//printf("sd rd error:%d\r\n",res);
;;;90     			}
;;;91     			break;
;;;92     		case EX_FLASH://外部flash
;;;93     			for(;count>0;count--)
;;;94     			{
;;;95     				W25QXX_Read(buff,sector*FLASH_SECTOR_SIZE,FLASH_SECTOR_SIZE);
;;;96     				sector++;
;;;97     				buff+=FLASH_SECTOR_SIZE;
;;;98     			}
;;;99     			res=0;
;;;100    			break;
;;;101    		default:
;;;102    			res=1; 
;;;103    	}
;;;104       //处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值
;;;105        if(res==0x00)return RES_OK;	 
;;;106        else return RES_ERROR;	   
;;;107    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L3.24|
000018  b117              CBZ      r7,|L3.32|
00001a  2f01              CMP      r7,#1                 ;81
00001c  d122              BNE      |L3.100|
00001e  e012              B        |L3.70|
                  |L3.32|
000020  b2e2              UXTB     r2,r4                 ;84
000022  4629              MOV      r1,r5                 ;84
000024  4630              MOV      r0,r6                 ;84
000026  f7fffffe          BL       SD_ReadDisk
00002a  4680              MOV      r8,r0                 ;84
00002c  e007              B        |L3.62|
                  |L3.46|
00002e  f7fffffe          BL       SD_Init
000032  b2e2              UXTB     r2,r4                 ;88
000034  4629              MOV      r1,r5                 ;88
000036  4630              MOV      r0,r6                 ;88
000038  f7fffffe          BL       SD_ReadDisk
00003c  4680              MOV      r8,r0                 ;88
                  |L3.62|
00003e  f1b80f00          CMP      r8,#0                 ;85
000042  d1f4              BNE      |L3.46|
000044  e011              B        |L3.106|
                  |L3.70|
000046  e009              B        |L3.92|
                  |L3.72|
000048  0269              LSLS     r1,r5,#9              ;95
00004a  f44f7200          MOV      r2,#0x200             ;95
00004e  4630              MOV      r0,r6                 ;95
000050  f7fffffe          BL       W25QXX_Read
000054  1c6d              ADDS     r5,r5,#1              ;96
000056  f5067600          ADD      r6,r6,#0x200          ;97
00005a  1e64              SUBS     r4,r4,#1              ;93
                  |L3.92|
00005c  2c00              CMP      r4,#0                 ;93
00005e  d1f3              BNE      |L3.72|
000060  46a0              MOV      r8,r4                 ;99
000062  e002              B        |L3.106|
                  |L3.100|
000064  f04f0801          MOV      r8,#1                 ;102
000068  bf00              NOP                            ;81
                  |L3.106|
00006a  bf00              NOP                            ;91
00006c  f1b80f00          CMP      r8,#0                 ;105
000070  d101              BNE      |L3.118|
000072  2000              MOVS     r0,#0                 ;105
000074  e7ce              B        |L3.20|
                  |L3.118|
000076  2001              MOVS     r0,#1                 ;106
000078  e7cc              B        |L3.20|
;;;108    
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;59     //获得磁盘状态
;;;60     DSTATUS disk_status (
000000  4601              MOV      r1,r0
;;;61     	BYTE pdrv		/* Physical drive nmuber (0..) */
;;;62     )
;;;63     { 
;;;64     	return 0;
000002  2000              MOVS     r0,#0
;;;65     } 
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;114    #if _USE_WRITE
;;;115    DRESULT disk_write (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;116    	BYTE pdrv,			/* Physical drive nmuber (0..) */
;;;117    	const BYTE *buff,	/* Data to be written */
;;;118    	DWORD sector,		/* Sector address (LBA) */
;;;119    	UINT count			/* Number of sectors to write (1..128) */
;;;120    )
;;;121    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
;;;122    	u8 res=0;  
00000c  f04f0800          MOV      r8,#0
;;;123        if (!count)return RES_PARERR;//count不能等于0，否则返回参数错误		 	 
000010  b914              CBNZ     r4,|L5.24|
000012  2004              MOVS     r0,#4
                  |L5.20|
;;;124    	switch(pdrv)
;;;125    	{
;;;126    		case SD_CARD://SD卡
;;;127    			res=SD_WriteDisk((u8*)buff,sector,count);
;;;128    			while(res)//写出错
;;;129    			{
;;;130    				SD_Init();	//重新初始化SD卡
;;;131    				res=SD_WriteDisk((u8*)buff,sector,count);	
;;;132    				//printf("sd wr error:%d\r\n",res);
;;;133    			}
;;;134    			break;
;;;135    		case EX_FLASH://外部flash
;;;136    			for(;count>0;count--)
;;;137    			{										    
;;;138    				W25QXX_Write((u8*)buff,sector*FLASH_SECTOR_SIZE,FLASH_SECTOR_SIZE);
;;;139    				sector++;
;;;140    				buff+=FLASH_SECTOR_SIZE;
;;;141    			}
;;;142    			res=0;
;;;143    			break;
;;;144    		default:
;;;145    			res=1; 
;;;146    	}
;;;147        //处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值
;;;148        if(res == 0x00)return RES_OK;	 
;;;149        else return RES_ERROR;	
;;;150    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L5.24|
000018  b117              CBZ      r7,|L5.32|
00001a  2f01              CMP      r7,#1                 ;124
00001c  d122              BNE      |L5.100|
00001e  e012              B        |L5.70|
                  |L5.32|
000020  b2e2              UXTB     r2,r4                 ;127
000022  4629              MOV      r1,r5                 ;127
000024  4630              MOV      r0,r6                 ;127
000026  f7fffffe          BL       SD_WriteDisk
00002a  4680              MOV      r8,r0                 ;127
00002c  e007              B        |L5.62|
                  |L5.46|
00002e  f7fffffe          BL       SD_Init
000032  b2e2              UXTB     r2,r4                 ;131
000034  4629              MOV      r1,r5                 ;131
000036  4630              MOV      r0,r6                 ;131
000038  f7fffffe          BL       SD_WriteDisk
00003c  4680              MOV      r8,r0                 ;131
                  |L5.62|
00003e  f1b80f00          CMP      r8,#0                 ;128
000042  d1f4              BNE      |L5.46|
000044  e011              B        |L5.106|
                  |L5.70|
000046  e009              B        |L5.92|
                  |L5.72|
000048  0269              LSLS     r1,r5,#9              ;138
00004a  f44f7200          MOV      r2,#0x200             ;138
00004e  4630              MOV      r0,r6                 ;138
000050  f7fffffe          BL       W25QXX_Write
000054  1c6d              ADDS     r5,r5,#1              ;139
000056  f5067600          ADD      r6,r6,#0x200          ;140
00005a  1e64              SUBS     r4,r4,#1              ;136
                  |L5.92|
00005c  2c00              CMP      r4,#0                 ;136
00005e  d1f3              BNE      |L5.72|
000060  46a0              MOV      r8,r4                 ;142
000062  e002              B        |L5.106|
                  |L5.100|
000064  f04f0801          MOV      r8,#1                 ;145
000068  bf00              NOP                            ;124
                  |L5.106|
00006a  bf00              NOP                            ;134
00006c  f1b80f00          CMP      r8,#0                 ;148
000070  d101              BNE      |L5.118|
000072  2000              MOVS     r0,#0                 ;148
000074  e7ce              B        |L5.20|
                  |L5.118|
000076  2001              MOVS     r0,#1                 ;149
000078  e7cc              B        |L5.20|
;;;151    #endif
                          ENDP


                          AREA ||i.ff_memalloc||, CODE, READONLY, ALIGN=1

                  ff_memalloc PROC
;;;224    //动态分配内存
;;;225    void *ff_memalloc (UINT size)			
000000  b510              PUSH     {r4,lr}
;;;226    {
000002  4604              MOV      r4,r0
;;;227    	return (void*)mymalloc(SRAMIN,size);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       mymalloc
;;;228    }
00000c  bd10              POP      {r4,pc}
;;;229    //释放内存
                          ENDP


                          AREA ||i.ff_memfree||, CODE, READONLY, ALIGN=1

                  ff_memfree PROC
;;;229    //释放内存
;;;230    void ff_memfree (void* mf)		 
000000  b510              PUSH     {r4,lr}
;;;231    {
000002  4604              MOV      r4,r0
;;;232    	myfree(SRAMIN,mf);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       myfree
;;;233    }
00000c  bd10              POP      {r4,pc}
;;;234    
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;219    //15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */                                                                                                                                                                                                                                                
;;;220    DWORD get_fattime (void)
000000  2000              MOVS     r0,#0
;;;221    {				 
;;;222    	return 0;
;;;223    }			 
000002  4770              BX       lr
;;;224    //动态分配内存
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  FLASH_SECTOR_COUNT
000000  6000              DCW      0x6000

;*** Start embedded assembler ***

#line 1 "..\\FATFS\\src\\diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_e3159e14____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___8_diskio_c_e3159e14____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_e3159e14____REVSH|
#line 144
|__asm___8_diskio_c_e3159e14____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
